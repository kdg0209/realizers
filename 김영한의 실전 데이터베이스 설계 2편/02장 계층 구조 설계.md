# 계층 구조 설계

#### 계층 구조란?

- 간단히 표현하면 카테고리가 1:N:M의 형식인 구조

#### 학습 내용

- 데이터베이스는 기본적으로 평면적인 테이블 구조를 가짐, 이러한 구조에서 어떻게 계층 구조를 만들 수 있을까에 대해 학습 진행

<br>

## 1. 인접 리스트 모델

#### 인접 리스트 모델이란?

- 인접 리스트 모델은 각 행이 자신의 부모를 참조하는 방식

#### 예시

- 각 노드는 자신의 부모 노드를 가리키는 외래키(`parent_id`)를 가짐
- 최상위 노드는 부모 노드가 없으므로 **NULL*로 설정됨

```sql
CREATE TABLE category (
  category_id BIGINT   NOT NULL AUTO_INCREMENT,
  name     VARCHAR(100) NOT NULL,
  parent_id  BIGINT   NULL,
  PRIMARY KEY (category_id),
  FOREIGN KEY (parent_id) REFERENCES category(category_id)
);

-- 1단계: 최상위 카테고리 (루트)
INSERT INTO category (name, parent_id) VALUES ('전자제품', NULL); -- id:1
INSERT INTO category (name, parent_id) VALUES ('의류', NULL);  -- id:2
INSERT INTO category (name, parent_id) VALUES ('식품', NULL);  -- id:3

-- 2단계: 전자제품의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('컴퓨터', 1);  -- id:4
INSERT INTO category (name, parent_id) VALUES ('스마트폰', 1); -- id:5
INSERT INTO category (name, parent_id) VALUES ('가전제품', 1); -- id:6

-- 3단계: 컴퓨터의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('노트북', 4);
INSERT INTO category (name, parent_id) VALUES ('데스크탑', 4);
INSERT INTO category (name, parent_id) VALUES ('태블릿', 4);

-- 3단계: 스마트폰의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('애플', 5);
INSERT INTO category (name, parent_id) VALUES ('삼성', 5);

-- 3단계: 가전제품의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('TV', 6);
INSERT INTO category (name, parent_id) VALUES ('냉장고', 6);

-- 2단계: 의류의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('남성의류', 2);
INSERT INTO category (name, parent_id) VALUES ('여성의류', 2);

-- 3단계: 남성의류의 하위 카테고리
INSERT INTO category (name, parent_id) VALUES ('셔츠', 14);
INSERT INTO category (name, parent_id) VALUES ('바지', 14);
```

#### 단점

- 깊은 계층의 데이터를 한 번에 조회하기 어려움
- 전자제품 하위에 있는 모든 카테고리를 조회하는 것은 한 번의 쿼리만으로는 불가능함
  - 애플리케이션에서 계층의 깊이만큼 호출하여 만들 수는 있으나 비효율적
  - 계층의 깊이가 고정되어 있다면 JOIN 쿼리로 가능하긴 함
  - UNION ALL 쿼리를 사용할 수 있지만 비효율적

```txt
└── 전자제품
     ├── 컴퓨터
     │    └── 노트북
     ├── 스마트폰
     │    └── 애플
     └── 가전제품
          └── TV
```

<br>

## 2. CTE와 재귀 쿼리

- MySQL 8.0부터 재귀 CTE(`Recursive CTE`)를 지원하면서, 인접 리스트 모델의 한계를 해결할 수 있음

#### CTE란?

- CTE(Common Table Expression)는 쿼리 내에서 임시로 사용할 수 있는 **이름 있는 결과 집함**임
- `WITH`절을 사용하여 정의하며, 해당 SQL 내에서만 잠시 존재하는 임시 뷰

#### CTE 기본 문법

- CTE는 단일 SQL문에서만 유효한 임시 결과 집합이며, 쿼리 실행이 끝나면 사라짐

```sql
WITH top_categories AS (
  SELECT * FROM category WHERE parent_id IS NULL
)
SELECT * FROM top_categories;
```

<br>

#### 재귀 CTE 문법

- 재귀 CTE는 자기 자신을 참조하는 CTE임, `WITH RECURSIVE` 키워드 사용함
- 기본 케이스와 재귀 케이스를 구분하는 곳에 `UNION` 또는 `UNION ALL`을 반드시 작성해야하며, 이 부분은 **문법상 필수**
- 기본 케이스를 실행하여 초기 값을 얻고, 이 값을 사용하여 재귀 케이스를 수행한다. 즉 재귀 케이스가 없을 때까지 재귀는 반복됨

```sql
WITH RECURSIVE cte_name AS (
  -- 기본 케이스 (Anchor Member): 재귀의 시작점. 즉 처음 실행되는 쿼리
  SELECT ...
 
  UNION ALL
 
  -- 재귀 케이스 (Recursive Member): CTE 자신을 참조하여 반복 실행되는 쿼리
  SELECT ... FROM cte_name WHERE ...
)
SELECT * FROM cte_name;
```

<br>

#### 인접 리스트 모델의 한계를 재귀 CTE로 해결

```sql
WITH RECURSIVE descendants AS (
  -- 기본 케이스: 시작 노드 (전자제품)
  SELECT category_id, name, parent_id, 1 AS depth
  FROM category  WHERE category_id = 1
 
  UNION ALL
 
  -- 재귀 케이스: 이전 결과의 자식들을 찾음
  SELECT c.category_id, c.name, c.parent_id, d.depth + 1
  FROM category c JOIN descendants d ON c.parent_id = d.category_id
)
SELECT * FROM descendants;

-- ### 특정 깊이까지만 조회
WITH RECURSIVE descendants AS (
  SELECT category_id, name, parent_id, 1 AS depth
  FROM category
  WHERE category_id = 1
 
  UNION ALL
 
  SELECT c.category_id, c.name, c.parent_id, d.depth + 1
  FROM category c
  JOIN descendants d ON c.parent_id = d.category_id
  WHERE d.depth < 2 -- 2단계까지만 재귀
)
SELECT * FROM descendants;

```

<br>

#### CTE의 장점

- 쿼리 가독성 향상
- 같은 CTE를 여러 번 참조 가능
- 재귀 쿼리 작성 가능

<br>

## 3. 폐쇄 테이블 모델

#### 폐쇄 테이블 모델이란?

- 폐쇄 테이블 모델은 **모든 조상-자손 관계**를 미리 계산하여 별도의 테이블에 저장하는 방식

#### 폐쇄 테이블 모델을 사용하는 경우

- `CTE`를 사용하더라도 계층의 깊이가 깊어 비효율적인 경우

#### 테이블 설계 방법

- **노드 테이블**: 실제 데이터를 저장
- **관계 테이블**: 모든 조상-자손 관계를 저장

```sql
-- 카테고리 테이블 (노드 테이블)
CREATE TABLE category_closure (
  category_id BIGINT   NOT NULL AUTO_INCREMENT,
  name     VARCHAR(100) NOT NULL,
  PRIMARY KEY (category_id)
);

-- 경로 테이블 (관계 테이블)
CREATE TABLE category_path (
  ancestor_id BIGINT NOT NULL, -- 조상 노드
  descendant_id BIGINT NOT NULL, -- 자손 노드
  depth    INT  NOT NULL, -- 거리 (깊이 차이)
  PRIMARY KEY (ancestor_id, descendant_id),
  FOREIGN KEY (ancestor_id) REFERENCES category_closure(category_id),
  FOREIGN KEY (descendant_id) REFERENCES category_closure(category_id)
);

-- 조회 성능을 위한 인덱스
CREATE INDEX idx_descendant ON category_path(descendant_id);
CREATE INDEX idx_depth ON category_path(depth);

-- 카테고리 데이터
INSERT INTO category_closure (category_id, name) VALUES (1, '전자제품');
INSERT INTO category_closure (category_id, name) VALUES (2, '컴퓨터');
INSERT INTO category_closure (category_id, name) VALUES (3, '스마트폰');
INSERT INTO category_closure (category_id, name) VALUES (4, '노트북');
INSERT INTO category_closure (category_id, name) VALUES (5, '데스크탑');
INSERT INTO category_closure (category_id, name) VALUES (6, '애플');
INSERT INTO category_closure (category_id, name) VALUES (7, '삼성');

-- 경로 데이터
-- 자기 자신에 대한 경로 (depth = 0)
-- (ancestor_id, descendant_id, depth)
INSERT INTO category_path VALUES (1, 1, 0);
INSERT INTO category_path VALUES (2, 2, 0);
INSERT INTO category_path VALUES (3, 3, 0);
INSERT INTO category_path VALUES (4, 4, 0);
INSERT INTO category_path VALUES (5, 5, 0);
INSERT INTO category_path VALUES (6, 6, 0);
INSERT INTO category_path VALUES (7, 7, 0);

-- 전자제품(1)의 자식들
INSERT INTO category_path VALUES (1, 2, 1); -- 전자제품(1) -> 컴퓨터(2)
INSERT INTO category_path VALUES (1, 3, 1); -- 전자제품(1) -> 스마트폰(3)
INSERT INTO category_path VALUES (1, 4, 2); -- 전자제품(1) -> 노트북(4) (손자)
INSERT INTO category_path VALUES (1, 5, 2); -- 전자제품(1) -> 데스크탑(5) (손자)
INSERT INTO category_path VALUES (1, 6, 2); -- 전자제품(1) -> 애플(6) (손자)
INSERT INTO category_path VALUES (1, 7, 2); -- 전자제품(1) -> 삼성(7) (손자)

-- 컴퓨터(2)의 자식들
INSERT INTO category_path VALUES (2, 4, 1); -- 컴퓨터(2) -> 노트북(4)
INSERT INTO category_path VALUES (2, 5, 1); -- 컴퓨터(2) -> 데스크탑(5)

-- 스마트폰(3)의 자식들
INSERT INTO category_path VALUES (3, 6, 1); -- 스마트폰(3) -> 애플(6)
INSERT INTO category_path VALUES (3, 7, 1); -- 스마트폰(3) -> 삼성(7)
```

<br>

#### 특정 조상의 모든 자손 조회

```sql
-- 전자제품(id=1)의 모든 자손 조회
SELECT *
FROM category_closure c
JOIN category_path p ON c.category_id = p.descendant_id
WHERE p.ancestor_id = 1;
```

<br>

#### 노드 추가

- 새로운 노드가 추가되면 경로 데이블도 함께 업데이트해야함

```sql
-- 노드 테이블에 추가
INSERT INTO category_closure (category_id, name) VALUES (8, '게이밍노트북');

-- 경로 추가: 자기 자신
INSERT INTO category_path VALUES (8, 8, 0);

-- 경로 추가
-- 게이밍노트북의 모든 조상들
-- 노트북의 조상들을 찾아서 게이밍노트북과의 관계를 추가
INSERT INTO category_path (ancestor_id, descendant_id, depth)
SELECT ancestor_id, 8, depth + 1
FROM category_path
WHERE descendant_id = 4;
```

<br>

#### 단점

- 노드의 수정 및 삭제시 경로 데이블의 수정이 필요함
- 자식이 있는 노드를 삭제하려면 자손들의 경로도 함께 처리해야함
- 조회 성능은 극대화할 수 있지만, 저장, 수정, 삭제시에 추가적인 계산을 해야함

<br>

## 4. 정리

### 4-1. 인접 리스트 모델

- 계층 구조를 저장하는 가장 직관적이고 널리 사용되는 모델
- 각 행이 자신의 부모를 참조하는 자기 참조 방식
- **장점**: 구조가 직관적이며, 데이터의 추가/수정/이동이 간단하고 저장 공간 효율이 높음
- **단점**: 특정 깊이 이상의 모든 자손이나 조상을 한번의 쿼리로 조회 어려움

<br>

### 4-2. CTE

- **CTE**: 쿼리 내에서 임시로 사용하는 **이름 있는 결과 집합**이며, `WITH`절로 정의함
- **재귀 CTE**는 `WITH RECURSIVE`를 사용하여 자기 자신을 참조하는 CTE
- **장점**: 가변 깊이 지원, 단일 쿼리 처리, 표준 SQL 사용, 가독성 우수
- **단점**: `UNION` 사용 시 성능 저하 발생 우려

<br>

### 4-3. 폐쇄 테이블 모델

- 모든 조상-자손 관계를 미리 계산하여 별도의 경로 테이블에 저장하는 방식
- **장점**: 조회 시점의 재귀 연산을 저장 시점으로 옮기므로 조회 성능 극대화
- **단점**: 노드 추가/수정/삭제 시 모든 경로를 재수정해야하므로 관리가 복잡함

<br>

#### 개인적인 생각

- 인접 리스트 모델은 변화에 유연하게 대응할 수 있을까? 라는 생각이 있기 때문에 추후 `CTE`방법을 적용해보는것도 좋을거 같음


