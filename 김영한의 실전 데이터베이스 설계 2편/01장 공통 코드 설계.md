 # 공통 코드 설계

#### 공통 코드란?

- 공통 코드는 시스템 전체에서 사용하는 코드값과 그에 대한 설명을 중앙에서 관리하는 방식

<br>

## 1. 문제 상황

데이터베이스의 주문 상태 컬럼(`order_status`)에 다음과 같이 **서로 다른 표현**이 혼재되어 저장되고 있다.

- `주문완료`
- `주문 완료`
- `ORDER_COMPLETED`

이렇게 저장되면 아래 문제가 발생한다.

- 데이터 불일치로 인한 비지니스 오류
- 검색이 의도대로 동작하지 않음
- 데이터 마이그레이션 어려움
- 비지니스 확장에 대한 어려움
  - 추후 글로벌 서비스를 한다면 어떻게 대응할것인가

<br>

## 2. 해결책

### 2-1. 공통 테이블 설계

#### 예시

- 데이터베이스의 주문 상태 컬럼(`order_status`)에 `코드`만 저장
- 코드값과 표시 이름은 별도의 테이블에 저장

```sql
-- 주문 정보 저장
INSERT INTO orders (member_id, order_status, total_amount, created_at) VALUES
(1, 'ORDER', 50000, '2026-01-15 10:30:00'),
(2, 'PAID', 75000, '2026-01-15 11:00:00'),
(3, 'SHIPPING', 30000, '2026-01-15 12:00:00'),
(1, 'DELIVERED', 120000, '2026-01-14 09:00:00'),
(4, 'CANCEL', 45000, '2026-01-13 15:00:00');

-- 코드 테이블 생성
CREATE TABLE common_code (code VARCHAR(50) PRIMARY KEY, name VARCHAR(100) NOT NULL);

-- 주문 코드 정보 저장
INSERT INTO common_code (code, name) VALUES
('ORDER', '주문접수'),
('PAID', '결제완료'),
('SHIPPING', '배송중'),
('DELIVERED', '배송완료'),
('CANCEL', '주문취소');

-- 등급 코드 정보 저장
INSERT INTO common_code (code, name) VALUES
('NORMAL', '일반회원'),
('VIP', 'VIP회원'),
('VVIP', 'VVIP회원');
```

<br>

#### 장점

1. 데이터 일관성 보장 

   > 정해진 값이기 때문에 다른 값을 저장할 수 없음

2. 표시 이름 변경 용이

   > 사용자에게 노출되는 명칭을 변경하고 싶다면 대응되는 설명만 변경하면됨

3. 다국어 지원 용이

   > 코드마다 N개의 설명을 설정하면됨

4. 중앙 집중 관리

   > 모든 코드값을 한 곳에서 관리하기 때문에 한눈에 파악 가능

#### 단점

1. 불필요한 JOIN 증가

   > 공통 코드를 데이터베이스에 설정하는 경우 매번 JOIN이 필요할 수 있음
3. 유지보수 힘듬

   > 도메인별 코드를 하나의 테이블에서 관리하면 코드가 많아졌을 때 파악하기 힘듬 <br>
   > 도메인이 다르지만 비슷한 코드가 생겼을 때 어디서 사용되는지 역추적하기 힘듬 <br>
   > 코드값이 충돌할 수 있음

<br>

### 2-2. 그룹화된 공통 코드 테이블 설계

- `2-1`에서는 공통 코드가 그룹화되어 있지 않아 문제가 발생

#### 예시

- 그룹 코드 테이블에는 도메인이 설정됨
- 상세 코드 테이블에는 도메인의 코드가 설정됨

```sql
-- 그룹 코드 테이블
CREATE TABLE common_code_group (
  group_code VARCHAR(50) PRIMARY KEY,
  group_name VARCHAR(100) NOT NULL,
  description VARCHAR(500),
  use_yn CHAR(1) NOT NULL DEFAULT 'Y',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 상세 코드 테이블
CREATE TABLE common_code_detail (
  group_code VARCHAR(50) NOT NULL,
  code VARCHAR(50) NOT NULL,
  name VARCHAR(100) NOT NULL,
  description VARCHAR(500),
  sort_order INT NOT NULL DEFAULT 0,
  use_yn CHAR(1) NOT NULL DEFAULT 'Y',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (group_code, code),
  FOREIGN KEY (group_code) REFERENCES common_code_group(group_code)
);

-- 그룹 코드 입력
INSERT INTO common_code_group (group_code, group_name, description) VALUES
('ORDER_STATUS', '주문상태', '주문의 진행 상태를 나타내는 코드'),
('MEMBER_GRADE', '회원등급', '회원의 등급을 나타내는 코드'),
('PAYMENT_STATUS', '결제상태', '결제의 진행 상태를 나타내는 코드'),
('PAYMENT_METHOD', '결제수단', '결제 방법을 나타내는 코드');

-- 상세 코드 입력
INSERT INTO common_code_detail (group_code, code, name, sort_order) VALUES
-- 주문 상태
('ORDER_STATUS', 'ORDER', '주문접수', 1),
('ORDER_STATUS', 'PAID', '결제완료', 2),
('ORDER_STATUS', 'SHIPPING', '배송중', 3),
('ORDER_STATUS', 'DELIVERED', '배송완료', 4),
('ORDER_STATUS', 'CANCEL', '주문취소', 5),

-- 회원 등급
('MEMBER_GRADE', 'NORMAL', '일반회원', 1),
('MEMBER_GRADE', 'VIP', 'VIP회원', 2),
('MEMBER_GRADE', 'VVIP', 'VVIP회원', 3),

-- 결제 상태
('PAYMENT_STATUS', 'PENDING', '결제대기', 1),
('PAYMENT_STATUS', 'COMPLETE', '결제완료', 2),
('PAYMENT_STATUS', 'FAILED', '결제실패', 3),
('PAYMENT_STATUS', 'CANCEL', '결제취소', 4),
('PAYMENT_STATUS', 'REFUND', '환불완료', 5),

-- 결제 수단
('PAYMENT_METHOD', 'CARD', '신용카드', 1),
('PAYMENT_METHOD', 'BANK', '계좌이체', 2),
('PAYMENT_METHOD', 'VIRTUAL', '가상계좌', 3),
('PAYMENT_METHOD', 'MOBILE', '휴대폰결제', 4);
```

<br>

#### 장점

1. 상세 코드 테이블에 중복된 코드가 있더라도 그룹 코드가 다르기 때문에 파악이 쉬워짐

#### 단점

1. 비지니스가 복잡해질수록 쿼리가 복잡해짐

<br>

## 3. 새로운 추가 사항

#### 비지니스 변경에 따른 추가 속성

- 코드별로 추가 속성이 필요한 경우
  - 예를들어 회원 등급별 할인율, 결제 수단별 할인율의 정보를 별도 테이블에서 관리해도 되지만 공통 테이블에서 관리하는 경우

<br>

### 3-1. 상세 코드 테이블에 컬럼 추가하여 해결

#### 예시

```sql
-- 상세 코드 테이블에 속성 컬럼을 추가
ALTER TABLE common_code_detail ADD COLUMN attr1 VARCHAR(100), ADD COLUMN attr2 VARCHAR(100), ADD COLUMN attr3 VARCHAR(100);

-- 회원 등급별 할인율 설정
UPDATE common_code_detail SET attr1 = '0' WHERE group_code = 'MEMBER_GRADE' AND code = 'NORMAL';
UPDATE common_code_detail SET attr1 = '5' WHERE group_code = 'MEMBER_GRADE' AND code = 'VIP';
UPDATE common_code_detail SET attr1 = '10' WHERE group_code = 'MEMBER_GRADE' AND code = 'VVIP';

-- 결제 수단별 수수료율 설정
UPDATE common_code_detail SET attr1 = '2.5' WHERE group_code = 'PAYMENT_METHOD' AND code = 'CARD';
UPDATE common_code_detail SET attr1 = '0' WHERE group_code = 'PAYMENT_METHOD' AND code = 'BANK';
UPDATE common_code_detail SET attr1 = '0' WHERE group_code = 'PAYMENT_METHOD' AND code = 'VIRTUAL';
UPDATE common_code_detail SET attr1 = '3.0' WHERE group_code = 'PAYMENT_METHOD' AND code = 'MOBILE';
```

<br>
 
#### 장점

1. 추가 속성이 정말 적다면 간단하게 문제를 해결할 수 있음

#### 단점

1. 컬럼이 무엇을 의미하는지 파악하기 힘듬
2. 속성이 계속 추가될 경우 컬럼이 무자비하게 추가될 수 있음
3. 속성을 Json 컬럼을 사용하여 저장해도 되겠지만 경우에 따라 속성으로 검색을 해야하는 경우 프레임워크(ex: Spring Boot)에서 Native 쿼리를 사용해야함

<br>

### 3-2. EAV(Entity-Attribute-Value)방식으로 해결

- [EAV 란](https://medium.com/@qpark99/%EB%94%94%EB%B9%84-%EB%AA%A8%EB%8D%B8%EB%A7%81-%ED%8C%A8%ED%84%B4-eav-entity-attribute-value-7b296c603fc0)

<br>

## 4. 공통 코드의 단점

1. SQL이 복잡해짐 (JOIN 쿼리 증가)
2. 쿼리에 코드를 알기 위한 쿼리가 있을텐데 추후 변경이 발생한다면 모든 쿼리를 수정해야함

<br>

## 5. 공통 코드의 해결 방안 

### 5-1. 코드를 애플리케이션에서 관리

- Java 언어에서 Enum을 제공하고 있기 때문에 Enum으로 관리하는 방식

#### 예시

- 데이터베이스에는 Enum의 값을 저장하고 DB -> Entity 변환 시 Enum의 값으로 대체하여 애플리케이션에서 관리

```sql
-- order_status는 OrderStatus Enum의 값으로 저장
INSERT INTO orders (member_id, order_status, total_amount, created_at) VALUES
(1, 'ORDER', 50000, '2026-01-15 10:30:00'),
(2, 'PAID', 75000, '2026-01-15 11:00:00'),
(3, 'SHIPPING', 30000, '2026-01-15 12:00:00'),
(1, 'DELIVERED', 120000, '2026-01-14 09:00:00'),
(4, 'CANCEL', 45000, '2026-01-13 15:00:00');
```

```java
public enum OrderStatus {

    ORDER("주문접수"),
    PAID("결제완료"),
    SHIPPING("배송중"),
    DELIVERED("배송완료"),
    CANCEL("주문취소");
    
    public String description;
    
    OrderStatus(String description) {
        this.description = description;
    }
}
```

<br>

#### 단점

- Enum의 정보가 변경되면 배포가 필요함

<br>

### 5-2. 로컬 캐싱 사용

- 애플리케이션에서 공통 코드를 별도로 조회하면 SQL이 단순해지지만, 추가 쿼리가 발생하기 때문에 네트워크 I/O가 발생하는 단점이 존재함, 이를 줄이기 위해 캐싱 사용
- 애플리케이션 시작 시 DB에 있는 값을 조회하여 static 변수에 할당하여 사용하는 방식 

#### 1. 캐시 동기화 문제

- 운영 중 공통 코드 테이블의 정보가 변경된다면 데이터베이스에는 변경되었지만 캐시는 여전히 이전 정보를 가지고 있음

#### 2. 해결 방법(사실상 불가능)

- 관리자가 캐시를 갱신할 수 있도록 기능을 만든다. 그러나 서버는 N대이기 때문에 특정 요청이 특정 서버에게만 전달된다면 다른 서버의 캐시는 갱신안될 수 있음

<br>

### 5-3. Redis와 같은 중앙 캐시 사용

- 로컬 캐시는 캐시 동기화 문제가 발생하기 때문에 Redis와 같이 별도의 중앙에서 관리할 수 있도록 함
- 단, 동기화는 쉽지만 네트워크 I/O 발생함

<br>

### 5-4. TTL을 활용한 전략

- 로컬 캐싱 + TTL 전략
- **애플리케이션 시작 시 DB에 있는 값을 조회하여 static 변수에 할당하여 사용하는 방식 + TTL 설정**
- Spring Boot에서는 `Caffeine Cache`라는 라이브러리가 있는데, 이를 사용하면 쉽게 TTL을 설정하고 관리할 수 있음

<br>

## 6. 공통 코드와 Enum

- 실무를 하다보면 Enum의 값에 따라 특정 비지니스 로직을 수행햐야하는 경우가 생긴다.
- Enum을 사용하는 방식은 우리의 비지니스 로직이 코드값과 결합되는 경우 사용함

#### 예시

```java
public enum OrderStatus {

    ORDER("주문접수"),
    PAID("결제완료"),
    SHIPPING("배송중"),
    DELIVERED("배송완료"),
    CANCEL("주문취소");

    public String description;

    OrderStatus(String description) {
        this.description = description;
    }
}

public class Order {

    private OrderStatus orderStatus;

    public boolean canCancel() {
        // 주문상태가 `주문완료` 또는 `결제완료` 상태에서만 취소 가능
        if (this.orderStatus == OrderStatus.ORDER || this.orderStatus == OrderStatus.PAID) {
            return true;
        }
        return false;
    }

    public void startShopping() {
        if (this.orderStatus != OrderStatus.PAID) {
            throw new IllegalStateException("결제완료 상태에서만 배송시작할 수 있습니다.");
        }

        this.orderStatus = OrderStatus.SHIPPING;
    }
}
```

<br>

#### 장점

1. Enum을 사용하면 오타를 방지할 수 있음

   > 잘못된 Enum을 선언하면 컴파일 에러 발생함

2. 코드 변경 시 추적 용이

   > Enum의 값을 변경하면 컴파일 에러가 발생하기 때문에 변경이 필요한 모든 곳 파악 가능

3. IDE 자동 완성 지원

   > 세상이 좋아져서 자동 완성 👍

4. 타입 안정성 향상

   > Enum 값 외에 다른 값을 설정할 수 없음

5. 다양한 추가 속성 선언 가능

   > Enum 선언 시 도메인별 추가 속성 선언 가능

<br>

#### 단점

1. Enum의 속성 변경 시 배포 필요

   > Eunm에 정의된 속성이 변경된다면 배포를 해야함

<br>

## 7. 공통 코드 Vs Enum 선택 방법

- 두 방식은 `개발의 안정성`과 `운영의 유연성`사이의 트레이드 오프
- 공통 코드를 사용하면 디비의 값만 변경하면 되기 때문에 `운영의 유연성`이 증가되지만 `개발의 안정성`이 저하됨
- Enum을 사용하면 `개발의 안정성`이 증가되지만 `운영의 유연성`이 저하됨

### 7-3. 무엇을 선택해야 하는가?

1. 비지니스 로직에서 상태값에 따라 분기처리를 해야하는가?

   > Enum 사용

2. 단순하게 보여주기 위한 목적인가?

   > 공통 테이블 사용

4. 변경이 매우 빈번한가?

   > 공통 테이블 사용, 수시로 배포를 해야하기 때문에 운영 유연성이 중요함

<br>

## 8. 공통 코드와 Enum의 함께 사용

- 하이브리드 전략은 공통 코드 테이블과 Enum을 중복으로 유지하고 각자 역할에 나누어 분담하는 것

#### 공통 코드 테이블의 역할

- 표시 이름, 추가 속성, 운영 유연성

#### Enum의 역할

- 코드값 정의, 타입 안정성, 비지니스 로직

<br>

#### 나의 생각

- 현대 사회에서는 요구사항이 빈번하게 변경되고, 사용자에게 빠르게 가치를 제공해야하기 때문에 개발 생산성이 높아야하고 유지보수가 쉬워야 한다고 생각한다. <br>
그렇다는 것은 복잡한 SQL로 인해 힘들게 파악하는 것보다 애플리케이션에서 관리하는게 유용한거 같다.

<br>

#### 새로운 관점

- 기존에는 공통 코드를 Redis에 저장해야하나? 라고 생각했지만, `5-4. TTL을 활용한 전략`을 통해 새로운 관점을 얻음
  - Redis를 사용한다면 아래 문제점이 발생했을 때 **fallback**을 할텐데 이는 오히려 복잡성만 증가시키기 때문에 오히려 `5-4. TTL을 활용한 전략`이 좋은 선택지인거 같음
    1. Redis 서버의 다운
    2. TTL 만료 


