# 데이터 변경 이력 설계

#### 문제 상황

- 상품 테이블이 아래처럼 있을 경우 해당 테이블에서 `price`값이 수정된다면 어떻게 추적할 수 있을까?

```sql
CREATE TABLE product (
  product_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(200) NOT NULL,
  price INT NOT NULL,
  stock_quantity INT NOT NULL DEFAULT 0,
  status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE'
);
```

<br>

## 1. 변경 추적 컬럼 사용

### 1-1. created_xxx, updated_xxx 컬럼을 추가적으로 사용

#### 예시

```sql
CREATE TABLE product (
  product_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(200) NOT NULL,
  price INT NOT NULL,
  stock_quantity INT NOT NULL DEFAULT 0,
  status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
  -- 변경 추적 컬럼
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  created_by VARCHAR(100) NOT NULL,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  updated_by VARCHAR(100) NOT NULL
);
```

#### 한계 

- updated_xxx 컬럼이 있지만 어떤 데이터가 어떻게?, 왜? 변경되었는지 사실상 추적 불가능
  - 2026년 02월 01일 12:00시에 price값이 100,000으로 변경됨
  - 2026년 02월 01일 13:00시에 price값이 150,000으로 변경됨
  - 2026년 02월 01일 14:00시에 price값이 200,000으로 변경됨
  - 즉, 중간 수정 데이터는 파악 불가

<br>

### 1-2. 변경 사유 컬럼을 추가적으로 사용

- 변경 사유 컬럼에 어떤 데이터가 어떻게? 왜? 변경되었는지 작성

#### 예시

```sql
CREATE TABLE product (
  product_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(200) NOT NULL,
  price INT NOT NULL,
  stock_quantity INT NOT NULL DEFAULT 0,
  status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
  -- 기본 변경 추적 컬럼
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  created_by VARCHAR(100) NOT NULL,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  updated_by VARCHAR(100) NOT NULL,
  -- 변경 사유 컬럼 (추가됨)
  change_reason TEXT
);
```

#### 한계 

- `1-1`의 한계와 동일함, 즉 중간 수정 데이터는 파악 불가

<br>

### 1-3. 현재 테이블로 이력 관리(`is_current`)

- **product** 테이블을 로그 형식으로 구성하되 `is_current`컬럼을 사용하여 현재 사용중인 최신 데이터인지 판별

```sql
CREATE TABLE product (
  history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  product_id BIGINT NOT NULL,
  name VARCHAR(200) NOT NULL,
  price INT NOT NULL,
  stock_quantity INT NOT NULL DEFAULT 0,
  status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',

  -- 현재 여부 컬럼 추가
  is_current BOOLEAN NOT NULL DEFAULT TRUE,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  created_by VARCHAR(100) NOT NULL,
 
  INDEX idx_product_id (product_id),
  INDEX idx_is_current (is_current),
  INDEX idx_product_id2 (product_id, created_at)
);
```

#### 한계

1. 시점 조회와 통계 쿼리 작성의 복잡함

    > 시점 조회시 `is_current` 컬럼을 사용하여 매번 **true**인 데이터를 limit 1로 조회해야함 <br>
    > 통계 쿼리 작성시 상황에 따라 최신 데이터를 기반으로 계산하거나 집계해야함
2. 시점 조회와 통계 쿼리의 성능 문제
    > 데이터가 너무 많아지다보니 통계 쿼리 작성 시 느려질 수 있음
3. 하나의 테이블에 너무 많은 데이터 보유
    > 로그 테이블로 변질 우려

<br>

### 1-4. 현재 테이블로 이력 관리(`유효기간`)

- **valid_from**: 이 데이터가 유효해진 시점
- **valid_to**: 이 데이터가 더 이상 유효하지 않게 된 시점(현재 데이터는 NULL 또는 먼 미래)

```sql
CREATE TABLE product (
  history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  product_id BIGINT NOT NULL,
  name VARCHAR(200) NOT NULL,
  price INT NOT NULL,
  stock_quantity INT NOT NULL DEFAULT 0,
  status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
  -- 유효 기간
  valid_from DATETIME NOT NULL,
  valid_to DATETIME NOT NULL DEFAULT '9999-12-31 23:59:59',
  is_current BOOLEAN NOT NULL DEFAULT TRUE,
  created_by VARCHAR(100) NOT NULL,
 
  INDEX idx_product_id_valid_range (product_id, valid_from, valid_to),
  INDEX idx_valid_range (valid_from, valid_to),
  INDEX idx_is_current (is_current)
);
```

<br>

#### 초기 데이터 저장

- **valid_from**: 데이터가 유효해진 시점이므로 현재 날짜로 저장
- **valid_to**: 데이터가 더 이상 유효하지 않게 된 시점이므로 초기에는 먼 미래 저장

```sql
INSERT INTO product (product_id, name, price, stock_quantity, status, valid_from, valid_to, is_current, created_by)
VALUES (1, '스마트폰 케이스', 15000, 100, 'ACTIVE', '2026-02-02 10:00:00', '9999-12-31 23:59:59', TRUE, 'admin_kim');

INSERT INTO product (product_id, name, price, stock_quantity, status, valid_from, valid_to, is_current, created_by)
VALUES (2, '무선 이어폰', 89000, 50, 'ACTIVE', '2026-02-02 10:05:00', '9999-12-31 23:59:59', TRUE, 'admin_lee');
```

<br>

#### 데이터 수정

1. 기존 행의 `valid_to`를 현재 시점으로 변경하고, `is_current`를 **FALSE**로 변경
2. 새로운 행 추가

```sql
-- 1. 기존 행의 유효 기간 종료
UPDATE product
SET valid_to = NOW(), is_current = FALSE
WHERE product_id = 1 AND is_current = TRUE;

-- 2. 새로운 행 추가
INSERT INTO product (product_id, name, price, stock_quantity, status, valid_from, valid_to, is_current, created_by)
VALUES (1, '스마트폰 케이스', 12000, 100, 'ACTIVE', NOW(), '9999-12-31 23:59:59', TRUE, 'admin_park');
```

<br>

#### 현제 데이터 조회

- NOW() 함수를 사용하여 간단히 조회할 수 있음

```sql
SELECT product_id, name, price, valid_from, valid_to FROM product
WHERE NOW() >= valid_from  AND NOW() < valid_to
ORDER BY product_id;
```

#### 한계

1. 이력 테이블이 완전히 불변하지 않음

    > 데이터를 변경할 때마다 이전 행의 `valid_to`를 **UPDATE** 해야함
2. 트랜잭션 관리가 필요함

    > **UPDATE**와 **INSERT**가 원자적으로 실행되어야함, 중간에 실패하면 데이터 정합성이 깨짐
3. 하나의 테이블에 너무 많은 데이터 보유

    > 로그 테이블로 변질 우려

<br>

## 2. 전체 행 스냅샷 이력 테이블

- 현재 테이블과 이력 테이블을 분리하는 구조

## 2-1. 테이블 설계

#### 이력 테이블의 주요 컬럼

- **created_at**
    - 원본 테이블(`product`)의 **created_at**사용
- **history_created_at**
    - 이력 데이터가 저장되는 시점의 시간
    - 데이터 변경의 타임라인 제공

```sql
-- 현재 데이터 테이블
CREATE TABLE product (
  product_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(200) NOT NULL,
  price INT NOT NULL,
  stock_quantity INT NOT NULL DEFAULT 0,
  status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  created_by VARCHAR(100) NOT NULL,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  updated_by VARCHAR(100) NOT NULL
);

-- 이력 테이블
CREATE TABLE product_history (
  history_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  product_id BIGINT NOT NULL,
  name VARCHAR(200) NOT NULL,
  price INT NOT NULL,
  stock_quantity INT NOT NULL DEFAULT 0,
  status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
  created_at DATETIME NOT NULL,
  created_by VARCHAR(100) NOT NULL,
  -- 이력 관리 컬럼
  history_created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, -- 이력 데이터 저장 시점
  history_created_by VARCHAR(100) NOT NULL, -- 변경 주체
  change_reason VARCHAR(500), -- 변경 사유
 
  INDEX idx_product_id (product_id),
  INDEX idx_history_created_at (history_created_at)
);
```

<br>

### 2-2. 주의점

1. 변경 시점에만 이력을 저장하는 경우

    > 즉, 첫 데이터가 언제 생성되었는지, 최초의 데이터는 어떤 상태였는지 추적 불가

<br>

### 2-3. 올바른 설계

- 처음부터 데이터를 이력 테이블에 저장하는 경우

1. 단순 조회 가능

    > 과거 내역이나 특정 시점의 데이터가 필요하면 단순히 이력 테이블 조회 가능

2. 타임라인 가능

    > 생성, 수정, 삭제까지 모든 생애주기를 알 수 있음

3. 유지보수성 향상

    > 데이터 정합성을 맞추는 시간을 줄일 수 잇음

4. 원본 테이블 복원 가능

    > 이력 테이블의 첫 데이터부터 모든 데이터가 있기 때문에 언제든 복원 가능

<br>

### 2-4. 한계

- 용량이 문제라면 `cold storage`를 사용하는 것도 방법

1. 용량 문제

    > 전체 행 스냅샷은 데이터 변경이 발생했을 때마다 모든 컬럼의 값을 저장함

2. 불필요한 중복

    > 특정 컬럼만 변경되었는데도 불구하고 다른 컬럼의 데이터도 저장됨

3. 무엇이 변경되었는지 추적하기 어려움

    > 전체 행이 저장되므로 무엇이 어떻게 변경되었는지 파악하기 어려움






