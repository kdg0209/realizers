# 아키텍처

<br>

## 15장: 아키텍처란?

- 소프트웨어 아키텍처란 시스템이 구축했던 사람들이 만들어낸 시스템의 형태입니다. 그 모양은 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 분할된 컴포넌트끼리 통신하는 방법에 따라 정해집니다.
- 소프트웨어 아키텍트는 코드와 동떨어져서는 안되며 계속 프로그래밍 작업을 하면서 팀원들의 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끌어줍니다.

#### 💡 아키텍처의 주된 목적

- 아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것입니다. 좋은 아키텍처는 시스템을 쉽게 이해할 수 있도록 해주며 그로인해 쉽게 개발하고, 유지보수하고, 배포할 수 있도록 해줍니다.
- 즉 아키텍처의 궁극적인 목적은 유지보수 비용을 최소화하고 프로그래머의 생산성을 극대화하는 것입니다.

#### 개발 

- 개발하기 힘든 시스템이라면 수명이 길지도 않고 건강하지도 않을 것입니다. 따라서 아키텍트는 개발팀이 시스템을 쉽게 개발할 수 있도록 지원을 해야합니다.
- 개발팀 인원이 적으면 아키텍처가 걸림돌이 될 수도 있습니다. 하지만 최소한의 아키텍처는 정의가 되어 있어야 한다고 생각하고 있습니다. 또한 개발팀의 인원이 많으면 여러 프로젝트를 동시에 진행하고 있을것이기 때문에 시스템을 신뢰할 수 있는 안정된 인터페이스를 갖추기 위해 설계를 해야합니다.

#### 배포

- 소프트웨어 시스템이 사용될 수 있으려면 반드시 배포할 수 있어야 합니다. 그리고 배포 비용이 비싸다면 시스템의 유용성은 떨어지게 됩니다.
- 개발 초기 단계에서는 배포 전략을 거의 고려하지 않지만 시스템이 성장함에 따라서 배포 전략도 고려를 해야합니다. 

#### 운영

- 아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다는 덜합니다. 그 이유는 시스템에 문제가 발생하면 scale-up이나 scale-out을 할 수 있기 때문입니다. 즉 돈을 발라 현재 문제를 잠재울 수 있습니다. (근본적인 해결책은 아닙니다.)

> 시스템 아키텍처는 유스케이스(사용 사례), 기능, 시스템의 필수 행위를 일급 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야한다. 라는 문장이 있는데 무슨 의미일까?

> 구체적인 의미
>
> 1. 사용 사례 중심 설계: 시스템을 설계할 때 특정 기술이나 데이터 구조보다는 사용 사례에 집중하여 사용자가 시스템을 통해 이루고자 하는 목표를 정의합니다.
> 2. 기능: 시스템이 제공해야 하는 기능과 그 기능이 어떻게 작동해야 하는지를 명확하게 정의하고, 이것을 아키텍처의 중요한 요소로 삼아야 합니다.
> 3. 일급 엔티티로 격상: "일급 엔티티"라는 것은 코드에서 가장 중요한 구성 요소로 다뤄져야 한다는 것입니다. 즉 사용 사례와 기능이 부가적인 고려사항이 아닌 아키텍처 설계의 주요 목표로 설정되어야 한다는 의미입니다. 

#### 유지보수

- 유지보수는 모든 측면에서 소프트웨어 시스템에서 비용이 가장 많이 듭니다. 그 이유는 소프트웨어 시스템이 운영되는 과정에서 항상 새로운 기능을 추가하고 변경해야 하기 때문입니다.
- 유지보수의 가장 큰 비용은 "탐사"와 사이드 이펙트입니다. 새로운 기능을 추가하거나 기존 기능을 변경할 때 어디에 코드를 변경할지 "탐사"해야하고, 또한 사이드 이펙트의 가능성을 항상 염두해야하기 때문입니다.

#### 선택사항 열어두기

> 아키텍트는 어떤 일이든 용이하게 만들기 위해서는 가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 전략을 따라야 합니다.

- 소프트웨어는 두 종류의 가치를 가지는데, 첫번째는 행위적 가치(요구사항)이고 두번째는 구조적 가치인데, "구조적 가치"가 더 중요합니다.
- 소프트웨어를 만드는 이유는 요구사항을 빠르고 쉽게 변경할 수 있도록 하기 위함인데, 이러한 유연성은 시스템의 형태, 컴포넌트의 배치 방식, 컴포넌트의 조립 방식에 크게 의존합니다.
- 소프트웨어를 최대한 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 그리고 가능한 한 오래 열어두는 것입니다.

#### 🧐 가능한 한 많이, 가능한 한 오래 열어두는게 무엇을 의미하는걸까?

> 가능한 한 많이, 가능한 한 오래 열어두면 작업을 어떻게해야하지? 라는 의문점을 가질 수 있습니다.
> 나의 생각
> 1. 변하지 않는 것(정책)과 변하는 것(세부 구현 사항)을 최대한 구분하고 격리시켜 개발을 진행하라는 의미인거 같습니다. 즉 SOLID에서는 DIP를 의미하는 것이고, 컴포넌트 관점에서 바라본다면 CRP(공통 재사용 원칙)와 SDP(안정된 의존성 원칙), SAP(안정된 추상화 원칙)을 의미하는 것 같습니다.

#### 결론

- 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정첵이 세부사항과 결합되지 않도록 분리합니다. 이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 세부사항에 의존하지 않게 됩니다.
- 좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향을 정책을 설계합니다.

<br>

## 16장: 독립성

- 좋은 아키텍처는 유스케이스, 개발, 배포, 운영을 지원해야하는데 이러한 내용에 대해 살펴보겠습니다.

#### 유즈케이스

- 시스템의 아키텍처는 시스템의 의도를 지원해야 합니다. 예를들어 시스템이 장바구니 애플리케이션이라면 아키텍처는 장바구니와 관련된 유스케이스를 지원해야 합니다.
- 좋은 아키텍처는 행위(요구사항)를 지원하기 위해 가장 중요한 사항은 행위(요구사항)을 명확히하고, 외부로 드러내는 것입니다. 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있도록 만드는 것입니다.

#### 개발

- 아키텍처는 개발환경을 지원하는데 핵심적인 역할을 수행합니다. "콘웨이의 법치"이 작용하는 지점이 이 구간입니다.

> 콘웨이 법칙
> - 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 설계(아키텍처)를 만들어 낸다는 원칙입니다.
> - 조직의 구조 == 서비스의 구조

#### 배포

- 아키텍처는 배포 용이성을 결정하는데 중요한 역학을 담당합니다. 이때 목표는 "즉각적인 배포"입니다.

#### 운영

- 시스템이 모노리틱 구조로 갖는다면 마이크로 서비스 형태가 필요해질 때 개선하기 어려울 수도 있습니다. 그에 비해 아키텍처가 각 컴포넌트를 적절히 격리하여 유지하고, 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면 시간이 지나 운영에 필요한 요구시항이 바뀌더라고 적절히 대응할 수 있습니다.

#### 선택사항 열어놓기

- 현실세계에서 우리는 모든 유스케이스(사용 사례)를 알 수 없으며, 운영하는데 따르는 제약사항, 팀 구조, 배포 요구사항도 알지 못하며 더 심각한 문제는 시스템이 성장하면서 이 사항들도 변해갑니다. 하지만 이러한 변화 속에서도 사라지지 않는 것들이 있는데, 몇몇 "아키텍처 원칙"은 시스템을 제대로 격리된 컴포넌트 단위로 분할할 때 도움이 되며, 이를 통해 선택사항을 가능한 한 많이 그리고 가능한 한 오랫동안 열어둘 수 있도록 해줍니다.
- 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템이 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 해줍니다.
- 몇몇 "아키텍처 원칙"이 어떤 아키텍처 원칙인지 명확하게 언급하지는 않았지만 앞장에서 나온 REP, CCP, CDP, ADP, SDP를 의미하는게 아닌가 생각합니다.

#### 계층 결합 분리

- 아키텍트는 필요한 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만 아키텍트는 우리가 만들 시스템의 기본적인 의도는 알고 있지만 세세한 모든 것을 알 수는 없습니다.
- 따라서 아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여 맥락에 따라서 다른 이유로 변경되는 것을 분리하고, 동일한 이유로 변경되는 것들을 묶어야 합니다.
- 예를들어 사용자 입력값에 대한 유효성 검증은 애플리케이션 업무 규칙이고, 비지니스 로직은 도메인에 더 밀접하게 관련된 업무 규칙입니다. 따라서 서로 다른 유형의 규칙은 다른 속도로 그리고 다른 이유로 변경되기 때문에 분리되어 있어야 합니다.

#### 중복

- 소프트웨어에서 중복은 일반적으로 나쁜것입니다. 개발자는 중복 코드를 좋아하지 않으며, 중복을 최대한 제거하면서 개발을 하고싶어합니다. 하지만 이 중복이 "진짜 중복"인지 "거짓 중복"인지 잘 파악해야 합니다.
- "중복"이라는 것을 잘 파악하기 위해서는 우선 "중복"을 받아드리는 것입니다. 만약 같은 행위를 하는 코드가 3번이 된다면 그제서야 "중복"을 제거하기 위해 노력하면 됩니다. 

<br>

## 17장: 경계 (선 긋기)

- 경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는것입니다.

#### 경계는 언제, 어떻게 그어야할까?

🧐 언제 경계를 그어야하나요?

- 관련이 있는 것과 없는 것 사이에 선을 긋습니다.

> 켄트 벡: "같은 속도로 변하는 것은 함께 있어야 하며, 다른 속도로 변하는 것은 서로 떨어져 있어야 한다"

<br>

🧐 어떻게 경계를 그어야하나요?

- 의존성 역전의 원칙을 활용하여 경계를 그을 수 있습니다. 고수준과 저수준 사이에 인터페이스를 둠으로써 고수준의 무엇가는 저수준의 무엇가에 의존하지 않고, 인터페이스에 의존합니다. 또한 저수준의 무엇가도 고수준에 의존하는게 아닌 인터페이스에 의존하는 것입니다.

#### 결론

- 경게를 잘 긋기 위해서는 변하는 것과 변하지 않는 것을 잘 파악해야 합니다. 변하지 않는 것은 고수준의 무엇가로 두고, 변하는 것을 저수준의 무엇가로 두어야 합니다. 변하지 않는 것은 정책과 같고, 변하는 것은 정책의 세부 구현 사항과 같습니다. 그리고 이 둘을 적절히 분리했다면 그 사이에 경계를 둘 수 있습니다.
- 같은 속도로 변하는 것과 다른 속도로 변하는 것을 구분하여 이 사이에도 경계를 둘 수 있습니다.

<br>

## 18장: 경계 해부학

- 시스템 아키텍처는 소프트웨어 컴포넌트와 그 컴포넌트를 분리하는 경계에 의해 정의됩니다.

#### 경계 횡단하기

- "경게를 횡단한다" 함은 그저 경계 한쪽에 있는 기능에서 다른 반대편에 있는 기능을 호출하는 것입니다. 경계를 횡단하는 비결은 소스 코드 의존성 관리에 있습니다.
- 소스 코드 의존성에 있는 이유는 소스 코드에서 변경이 이루어지면 이를 의존하는 다른 소스 코드에서 변경이 이뤄져야하기 때문입니다.

#### 두려운 단일체

- 아키텍처 경계 중에서 가장 단순하며 가장 흔한 형태는 물리적으로 엄격하게 경계가 구분되지 않는 형태입니다. 이해를 돕기 위해 모노리식 아키텍처를 생각해주시면 됩니다.
- 단일체(모노리식 아키텍처)라 하더라도 경계가 실제로 존재하지 않거나, 경계가 무의미하다는게 아닙니다. 오히려 단일체(모노리식 아키텍처)에서 경계를 더 뚜렷이해야한다고 생각합니다. 그 이유는 단일체일수록 확장가능성을 더 염두해둬야 하기 때문입니다.
- 자바에서는 다형성을 토왜 고수준의 클라이언트가 저수준의 서비스를 호출해야한다면 런타임 시점에 제어흐름과는 반대 방향으로 의존성을 역전시킬 수 있습니다.

#### 서비스

- 물리적인 형태를 띠는 가장 강력한 경계는 서비스입니다. 서비스는 모든 통신이 네트워크를 통해 이뤄진다고 가정합니다. 그렇기 때문에 서비스 경계를 지나는 모든 통신은 함수 호출에 비해 매우 느릴수밖에 없습니다. 따라서 주의를 기울여서 가능하다면 빈번히 통신하는 일을 피해야합니다.
- 저수준 서비스는 반드시 고수준 서비스에 플러그인되어야 합니다.

<br>

## 19장: 정책과 수준

- 소프트웨어 아키텍처를 개발하는 기술에는 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함됩니다.
- 동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 합니다. 서로 다른 이유로 혹은 다른 시점에 변경되는 정책은 다른 수준에 위치하며, 반드시 다른 컴포넌트로 분리해야 합니다.
- 좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성 방향이 컴포넌트 수준을 기반으로 연결되도록 만들어야 합니다. 즉 저수준 컴포넌트가 고수준 컴포넌트에 의존하게 만들어야 합니다.

#### 수준

- '수준'을 엄밀하게 정의하자면 '입력과 출력까지의 거리'입니다. 시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다고 합니다.
- 아래 그림에서 주목할만한 점은 데이터 흐름과 소스 코드 의존성이 항상 같은 방향을 가리키지 않는다는 것입니다. 만약 잘모솬 소스 코드 의존성이였다면 문자읽기기 번역에 의존하고 있고, 번역이 문자쓰기에 의존하고 있을 것입니다.

<img width="1032" alt="스크린샷 2024-09-28 오후 3 15 09" src="https://github.com/user-attachments/assets/a4d43aab-6c72-4833-ac89-27008be0e687">

<br>

#### 조금 더 나은 아키텍처

- 단일 책임 원칙, 공통 폐쇄 원칙에 따르면 동일한 이유로 동일한 시점에 변경되는 정책은 함게 묶입니다. 즉 입력과 출력에서부터 멀리 떨어진 정책은 저수준 정책에 비해 덜 빈번히 변경되고, 보다 중요한 이유로 변경됩니다.

<img width="1032" alt="스크린샷 2024-09-28 오후 3 22 23" src="https://github.com/user-attachments/assets/ef9c5e72-0b60-49f7-b9d2-c6996c8b27c1">

<br>

#### 결론

- 소스 코드 의존성 방향이 고수준 정책을 향할 수 있도록 정책을 분리했다면 변경의 영향도를 줄일 수 있습니다.
- 시스템의 저수준에서 중요하지는 않지만 긴급한 변경이 발생하더라도 보다 높은 위치에 있는 중요한 수준에 미치는 영향은 거의 없게 됩니다.
- 19장에서는 단일 책임 원칙(SRP), 개방 폐쇄 원칙(OCP), 공통 폐쇄 원칫(CCP), 의존성 역전 원칙(DIP), 안정된 의존성 원칙(SDP), 안정된 추상화 원칙(SAP)을 포함합니다.

<br>

## 20장: 업무 규칙

- 업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차입니다. 더 엄밀히 말하면 컴퓨터로 구현했는지와 상관없이, 업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있어야 합니다.
- 예를들어 대출에 이자를 부과한다는 것은 은행의 업무 규칙입니다. 이를 컴퓨터로하든 직원이 하든 관계가 없습니다.

#### 엔티티(도메인)

- 엔티티는 객체로서 데이터를 기반으로 동작하는 업무 규칙을 구체화합니다. 엔티티 객체는 업무 규칙에 필요한 데이터를 직접적으로 가지고 있거나 해당 데이터에 쉽게 접근할 수 있습니다.
- 엔티티를 구성할 때 핵심적인 개념을 구현하는 소프트웨어를 한 곳에 모으고, 핵심적인게 아닌 것들을 분리시켜야 합니다. 즉 응집도를 높이고 결합도를 낮춰야 한다는 것입니다. 또한 엔티티는 가장 순수해야 합니다. 해당 엔티티를 굳이 객체 지향 언어가 아닌 노드나 PHP에서도 구성이 가능해야 한다는 것입니다.

#### 유스케이스

- 유스케이스는 시스템의 사용 사례를 설명합니다. 유스케이스는 사용자가 제공해야하는 입력, 사용자에게 보여줄 출력, 그리고 처리 단계를 기술합니다.
- 유스케이스는 애플리케이션에 특화된 업무 규칙을 구현하는 하나 이상의 함수를 제공합니다. 또한 유스케이스는 입력 데이터, 출력 데이터, 유스케이스가 상호작용하는 엔티티에 대한 참조 데이터 등의 데이터를 포함합니다.

#### 결론 

- 업무 규칙(엔티티)은 소프트웨어 시스템이 존재하는 이유이며, 핵심적인 기능입니다.
- 업무 규칙은 사용자 인터페이스나 데이터베이스와 같은 저수준의 관심사로 오염되서는 안되먀, 원래 그대로의 모습으로 남아 있어야 합니다.
- 업무 규칙은 시스템의 심장부에 위치해야하며, 덜 중요한 코드는 심장부의 플러그인이 되어야 합니다.

<br>

#### 참고

- https://yozm.wishket.com/magazine/detail/1494/






