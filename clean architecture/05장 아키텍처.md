# 아키텍처

<br>

## 15장: 아키텍처란?

- 소프트웨어 아키텍처란 시스템이 구축했던 사람들이 만들어낸 시스템의 형태입니다. 그 모양은 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 분할된 컴포넌트끼리 통신하는 방법에 따라 정해집니다.
- 소프트웨어 아키텍트는 코드와 동떨어져서는 안되며 계속 프로그래밍 작업을 하면서 팀원들의 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끌어줍니다.

#### 💡 아키텍처의 주된 목적

- 아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것입니다. 좋은 아키텍처는 시스템을 쉽게 이해할 수 있도록 해주며 그로인해 쉽게 개발하고, 유지보수하고, 배포할 수 있도록 해줍니다.
- 즉 아키텍처의 궁극적인 목적은 유지보수 비용을 최소화하고 프로그래머의 생산성을 극대화하는 것입니다.

#### 개발 

- 개발하기 힘든 시스템이라면 수명이 길지도 않고 건강하지도 않을 것입니다. 따라서 아키텍트는 개발팀이 시스템을 쉽게 개발할 수 있도록 지원을 해야합니다.
- 개발팀 인원이 적으면 아키텍처가 걸림돌이 될 수도 있습니다. 하지만 최소한의 아키텍처는 정의가 되어 있어야 한다고 생각하고 있습니다. 또한 개발팀의 인원이 많으면 여러 프로젝트를 동시에 진행하고 있을것이기 때문에 시스템을 신뢰할 수 있는 안정된 인터페이스를 갖추기 위해 설계를 해야합니다.

#### 배포

- 소프트웨어 시스템이 사용될 수 있으려면 반드시 배포할 수 있어야 합니다. 그리고 배포 비용이 비싸다면 시스템의 유용성은 떨어지게 됩니다.
- 개발 초기 단계에서는 배포 전략을 거의 고려하지 않지만 시스템이 성장함에 따라서 배포 전략도 고려를 해야합니다. 

#### 운영

- 아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다는 덜합니다. 그 이유는 시스템에 문제가 발생하면 scale-up이나 scale-out을 할 수 있기 때문입니다. 즉 돈을 발라 현재 문제를 잠재울 수 있습니다. (근본적인 해결책은 아닙니다.)

> 시스템 아키텍처는 유스케이스(사용 사례), 기능, 시스템의 필수 행위를 일급 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야한다. 라는 문장이 있는데 무슨 의미일까?

> 구체적인 의미
>
> 1. 사용 사례 중심 설계: 시스템을 설계할 때 특정 기술이나 데이터 구조보다는 사용 사례에 집중하여 사용자가 시스템을 통해 이루고자 하는 목표를 정의합니다.
> 2. 기능: 시스템이 제공해야 하는 기능과 그 기능이 어떻게 작동해야 하는지를 명확하게 정의하고, 이것을 아키텍처의 중요한 요소로 삼아야 합니다.
> 3. 일급 엔티티로 격상: "일급 엔티티"라는 것은 코드에서 가장 중요한 구성 요소로 다뤄져야 한다는 것입니다. 즉 사용 사례와 기능이 부가적인 고려사항이 아닌 아키텍처 설계의 주요 목표로 설정되어야 한다는 의미입니다. 

#### 유지보수

- 유지보수는 모든 측면에서 소프트웨어 시스템에서 비용이 가장 많이 듭니다. 그 이유는 소프트웨어 시스템이 운영되는 과정에서 항상 새로운 기능을 추가하고 변경해야 하기 때문입니다.
- 유지보수의 가장 큰 비용은 "탐사"와 사이드 이펙트입니다. 새로운 기능을 추가하거나 기존 기능을 변경할 때 어디에 코드를 변경할지 "탐사"해야하고, 또한 사이드 이펙트의 가능성을 항상 염두해야하기 때문입니다.

#### 선택사항 열어두기

> 아키텍트는 어떤 일이든 용이하게 만들기 위해서는 가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 전략을 따라야 합니다.

- 소프트웨어는 두 종류의 가치를 가지는데, 첫번째는 행위적 가치(요구사항)이고 두번째는 구조적 가치인데, "구조적 가치"가 더 중요합니다.
- 소프트웨어를 만드는 이유는 요구사항을 빠르고 쉽게 변경할 수 있도록 하기 위함인데, 이러한 유연성은 시스템의 형태, 컴포넌트의 배치 방식, 컴포넌트의 조립 방식에 크게 의존합니다.
- 소프트웨어를 최대한 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 그리고 가능한 한 오래 열어두는 것입니다.

#### 🧐 가능한 한 많이, 가능한 한 오래 열어두는게 무엇을 의미하는걸까?

> 가능한 한 많이, 가능한 한 오래 열어두면 작업을 어떻게해야하지? 라는 의문점을 가질 수 있습니다.
> 나의 생각
> 1. 변하지 않는 것(정책)과 변하는 것(세부 구현 사항)을 최대한 구분하고 격리시켜 개발을 진행하라는 의미인거 같습니다. 즉 SOLID에서는 DIP를 의미하는 것이고, 컴포넌트 관점에서 바라본다면 CRP(공통 재사용 원칙)와 SDP(안정된 의존성 원칙), SAP(안정된 추상화 원칙)을 의미하는 것 같습니다.

#### 결론

- 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정첵이 세부사항과 결합되지 않도록 분리합니다. 이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 세부사항에 의존하지 않게 됩니다.
- 좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향을 정책을 설계합니다.

<br>

## 16장: 독립성

- 좋은 아키텍처는 유스케이스, 개발, 배포, 운영을 지원해야하는데 이러한 내용에 대해 살펴보겠습니다.

#### 유즈케이스

- 시스템의 아키텍처는 시스템의 의도를 지원해야 합니다. 예를들어 시스템이 장바구니 애플리케이션이라면 아키텍처는 장바구니와 관련된 유스케이스를 지원해야 합니다.
- 좋은 아키텍처는 행위(요구사항)를 지원하기 위해 가장 중요한 사항은 행위(요구사항)을 명확히하고, 외부로 드러내는 것입니다. 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있도록 만드는 것입니다.

#### 개발

- 아키텍처는 개발환경을 지원하는데 핵심적인 역할을 수행합니다. "콘웨이의 법치"이 작용하는 지점이 이 구간입니다.

> 콘웨이 법칙
> - 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 설계(아키텍처)를 만들어 낸다는 원칙입니다.
> - 조직의 구조 == 서비스의 구조

#### 배포

- 아키텍처는 배포 용이성을 결정하는데 중요한 역학을 담당합니다. 이때 목표는 "즉각적인 배포"입니다.

#### 운영

- 시스템이 모노리틱 구조로 갖는다면 마이크로 서비스 형태가 필요해질 때 개선하기 어려울 수도 있습니다. 그에 비해 아키텍처가 각 컴포넌트를 적절히 격리하여 유지하고, 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면 시간이 지나 운영에 필요한 요구시항이 바뀌더라고 적절히 대응할 수 있습니다.

#### 선택사항 열어놓기

- 현실세계에서 우리는 모든 유스케이스(사용 사례)를 알 수 없으며, 운영하는데 따르는 제약사항, 팀 구조, 배포 요구사항도 알지 못하며 더 심각한 문제는 시스템이 성장하면서 이 사항들도 변해갑니다. 하지만 이러한 변화 속에서도 사라지지 않는 것들이 있는데, 몇몇 "아키텍처 원칙"은 시스템을 제대로 격리된 컴포넌트 단위로 분할할 때 도움이 되며, 이를 통해 선택사항을 가능한 한 많이 그리고 가능한 한 오랫동안 열어둘 수 있도록 해줍니다.
- 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템이 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 해줍니다.
- 몇몇 "아키텍처 원칙"이 어떤 아키텍처 원칙인지 명확하게 언급하지는 않았지만 앞장에서 나온 REP, CCP, CDP, ADP, SDP를 의미하는게 아닌가 생각합니다.

#### 계층 결합 분리

- 아키텍트는 필요한 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만 아키텍트는 우리가 만들 시스템의 기본적인 의도는 알고 있지만 세세한 모든 것을 알 수는 없습니다.
- 따라서 아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여 맥락에 따라서 다른 이유로 변경되는 것을 분리하고, 동일한 이유로 변경되는 것들을 묶어야 합니다.
- 예를들어 사용자 입력값에 대한 유효성 검증은 애플리케이션 업무 규칙이고, 비지니스 로직은 도메인에 더 밀접하게 관련된 업무 규칙입니다. 따라서 서로 다른 유형의 규칙은 다른 속도로 그리고 다른 이유로 변경되기 때문에 분리되어 있어야 합니다.

#### 중복

- 소프트웨어에서 중복은 일반적으로 나쁜것입니다. 개발자는 중복 코드를 좋아하지 않으며, 중복을 최대한 제거하면서 개발을 하고싶어합니다. 하지만 이 중복이 "진짜 중복"인지 "거짓 중복"인지 잘 파악해야 합니다.
- "중복"이라는 것을 잘 파악하기 위해서는 우선 "중복"을 받아드리는 것입니다. 만약 같은 행위를 하는 코드가 3번이 된다면 그제서야 "중복"을 제거하기 위해 노력하면 됩니다. 

<br>

## 17장: 경계 (선 긋기)

<br>

#### 참고

- https://yozm.wishket.com/magazine/detail/1494/






