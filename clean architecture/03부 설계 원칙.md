# 설계 원칙

- SOLID 원칙은 데이터와 메서드를 클래스로 배치하는 방법과 각 클래스들을 결합하는 방법을 알려줍니다.

<br>

## 07장 SRP: 단일 책임 원칙

- 단일 책임 원칙이란 클래스나 메서드는 단 하나의 책임만을 가져야한다는 것입니다. 즉 변경에 대한 이유가 하나여야 한다는 것입니다.
- 단일 책임 원칙은 갓 클래스를 더 작게 리팩토링하는 과정에 쓰일 수 있습니다.
- 단일 책임 원칙에서의 소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경이 되어야 한다고 합니다. 즉 클래스나 메서드는 오직 하나의 사용자나 이해관계자에 대해서만 책임을 지고 변경이 이루어져야 한다는 것입니다.

<br>

## 08장 OCP: 개방 폐쇄 원칙

- 개방 폐쇄 원칙은 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다는 원칙입니다.

#### 가정

- 사용자가 회원가입을 하면 이메일로 회원가입 축하 메일을 보낸다고 가정합시다.

```java
@Service
@Transactional
@RequiredArgsConstructor
public class MemberCreateService {

    private final MemberCreateRepository repository;

    public void create(String name, int age, String email, String phone, LocalDate createDate) {

        // 사용자 회원가입 및 DB 저장
        ...
    }
    
    private void sendToClient(String name, String email) {
        // 회원가입한 사용자에게 메일 발송
        ...
    }
}
```

<br>

#### 요구사항 추가

- 시간이 지나 이해관계자가 회원가입한 사용자에게 축하 안내를 메일뿐만 아니라 알림톡 및 푸시 기능을 넣고싶다고 하였습니다. 어떻게 대처해야할까요? 가장 쉬운 방법은 MemberCreateService 클래스에 필요한 의존성을 주입 받은 후에 private 메서드를 통해 기능을 만들 수 있습니다.
- 하지만 이렇게 코드를 작성하면 MemberCreateService 클래스는 점차 뚱뚱해질뿐만 아니라 다른 변경 사항들로 인해 기존 기능들에 오류가 발생할 가능성이 높아질 수 있습니다.

<br>

#### 🤔 어떻게 개선할건가?

- 아래 코드는 개선된 코드입니다. 우선 DIP 원칙을 적용하여 의존성을 느슨하게 만들었으며, SRP 원칙을 적용하여 하나의 클래스는 하나의 책임만을 갖도록 구조화하였습니다.

```java
@Service
@Transactional
@RequiredArgsConstructor
public class MemberCreateService {

    private final MemberCreateRepository repository;
    private final List<NotificationChannel> channels;

    public void create(String name, int age, String email, String phone, LocalDate createDate) {

        // 사용자 회원가입 및 DB 저장
        ...

        // 회원가입한 사용자에게 메일 발송
        for (NotificationChannel channel : channels) {
            boolean supported = channel.support(...);
            if (supported) {
                channel.notification(...);
            }
        }
    }
}

public enum NotificationType {

    EMAIL, ALIM_TALK, FCM
}

public record Notification(String name, String email, String phone) {

}

public interface NotificationChannel {

    boolean support(Set<NotificationType> types);
    void notification(Notification notification);
}

@Component
public class EmailNotification implements NotificationChannel {

    @Override
    public boolean support(Set<NotificationType> types) {
        return types.contains(NotificationType.EMAIL);
    }

    @Override
    public void notification(Notification notification) {
        System.out.println("이메일을 통해 전송");
    }
}

@Component
public class FcmNotification implements NotificationChannel {

    @Override
    public boolean support(Set<NotificationType> types) {
        return types.contains(NotificationType.FCM);
    }

    @Override
    public void notification(Notification notification) {
        System.out.println("FCM을 통해 전송");
    }
}

@Component
public class AlimTalkNotification implements NotificationChannel {

    @Override
    public boolean support(Set<NotificationType> types) {
        return types.contains(NotificationType.ALIM_TALK);
    }

    @Override
    public void notification(Notification notification) {
        System.out.println("알림톡을 통해 전송");
    }
}
```

<br>

#### 🤔 개방 폐쇄 원칙을 어떻게 하면 준수할 수 있을까?

- 서로 다른 목적으로 변경되는 요소들을 적절히 분리하고, 이들 요소 사이의 의존성을 추이 의존성이 아닌 인터페이스를 두어 의존성을 약하게 만드는 것입니다.
- 즉 단일 책임 원칙을 적용하고, 의존성 역전 원칙을 적용한다는 것입니다. 또한 이 둘을 적용하다보면 인터페이스 분리 원칙도 함께 적용되곤 합니다.

#### 🧐 기존 코드를 수정한다면 OCP 원칙을 위배하는 것인가?

- 개발을 하다보면 기존 클래스에 속성을 추가하든 메서드를 추가하든 합니다. 근데 이러한 행위가 OCP를 위배한다고 보는게 맞을까요?
- 기존 코드를 수정했으니 OCP 원칙을 위배했다고 볼 수 있습니다. 하지만 이 변경점이 기존 속성을 변경했는지? 기존 메서드를 변경했는지? 아님 새로운 것을 추가했는지? 잘 파악해야합니다. 기존 속성이나 메서드를 변경했다면 OCP 원칙을 위배했다고 볼 수 있지만 새로운 것을 추가했을 때 OCP 원칙을 위배한게 아닐 수도 있습니다. 그 이유는 아래와 같습니다.

이유 (디자인 패턴의 아름다움 03장 참고)

- 코드의 수정이 기존에 작성되어 있던 로직이나 테스트를 깨트리지 않는 한 OCP를 위반하지 않았다고 판단해도 무방합니다.
- 즉 새로운 기능을 추가했을 때 기존 코드를 전혀 수정하지 않는 것은 불가능에 가깝습니다. 따라서 우리는 수정을 아예 안하는게 아니라 수정을 가능한 한 내부 구현에 대한 수정이 아닌 상위 수준에서의 작업이 이루어져야 합니다.

#### 결론

- 개방 폐쇄 원칙의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있습니다.

<br>

## 09장 LSP: 리스코프 치환 원칙

<br>

## 10장 ISP: 인터페이스 분리 원칙

- 인터페이스 분리 원칙은 자신이 사용하지 않는 인터페이스 또는 매서드 시그니처에 의존해서는 안된다는 원칙입니다.

#### ISP와 언어

- 정적 타입 언어는 개발자가 import, use, include 와 같은 선언문을 사용하도록 강제합니다. 이러한 선언문으로 인해 소스 코드 의존성이 발생하고, 이로인해 재컴파일 또는 재배포가 강제되는 상황이 초래된다고 합니다.
- 루비나 파이썬과 같은 동적 타입 언어에서는 이러한 선언문이 없기 때문에 런타임에 추론이 발생하고, 재컴파일 및 재배포가 필요없다고 합니다. 따라서 ISP는 아키텍처가 아닌 언어와 관련된 문제라고도 볼 수 있습니다.

#### ISP와 아키텍처

- 일반적으로 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일입니다.
- 개발자 A는 "System A"를 만들기 위해서 "Framework F"를 사용하려고 하는데 "Framework F"를 사용하기 위해서는 "Database D"를 무조건 사용되어야 하는데, 이때 만약 "Database D"에 문제가 생기면 결국 개발자 A는 신경써야 하는 범위가 더 늘어나게 된 것입니다.

![스크린샷 2024-09-19 오후 9 58 22](https://github.com/user-attachments/assets/38030e5a-a6b1-43d6-8fa5-783c0f532b24)

<br>

#### 응집도와 ISP

- 하나의 인터페이스에 많은 메서드를 두고 해당 인터페이스를 구현하는 구현체 클래스를 만들어 응집도를 높여야지! 라는 생각을 가질 수도 있습니다. 하지만 이 또한 양날의 검입니다. 응집도를 높일 수 있는 반면에 변경에는 취약해질 수 있습니다.
- 응집도를 높이는 행위는 어떻게 보면 좋을 수도 있지만 그만큼 희생해야하는 부분도 있습니다. (결국 트레이드 오프)

<br>

## 11장 DIP: 의존성 역전 원칙
















