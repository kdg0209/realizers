# 02 벽돌부터 시작하기: 프로그래밍 패러다임

<br>

## 03장 패러다임 개요

#### 구조적 프로그래밍

- 최초로 만들어진 패러다임은 아니지만 최초로 적용된 패러다임이라고 합니다.

#### 객체지향 프로그래밍

- 구조적 프로그래밍보다 2년 앞선 1966년 올레 요한 달과 크리스텐 니가드에 의해 등장했다고 합니다.

#### 함수형 프로그래밍

- 컴퓨터 프로그래밍보다 앞선 수학적 문제를 해결하는 과정에서 람다 계산법의 영향을 받아 만들어졌다고 합니다.

<br>

## 04장 구조적 프로그래밍

- 에츠허르 비버 데이크스트라에 의해 구조적 프로그래밍이 등장하였습니다.

#### 테스트

- 데이트스트라는 '테스트는 버그가 있음음 보여줄 뿐, 버그가 없음을 보여줄 수는 없다.' 라고 말하였습니다.
- 즉 프로그램이 테스트를 통해 잘못되었음을 증명할 순 있지만 프로그램이 맞다고 증명할 수는 없다는 것입니다.
- 테스트에 충분한 노력을 들였다면 테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있도록 해주는 것이 전부라 합니다.

<br>

## 05장 객체 지향 프로그래밍

#### 객체지향이란 무엇인가?

- 역할, 책임, 협력을 통해 하나의 애플리케이션을 구축하는 과정입니다.

#### 캡슐화

- 객체지향에서 캡슐화를 빼놓고 이야기할 수는 없습니다. 캡슐화는 응집도를 높이고 결합도를 낮출 수 있는 가본 개념입니다.
- 캡슐화를 방해하는 요소 중 하나는 setter를 사용하는 것입니다. setter의 사용을 지양해야 하는 이유 증 하나는 객체지향에서는 해당 정보(데이터)를 가지고 있는 객체에게 작업을 수행해달라고 요청을 해야합니다. 즉 협력을 통해 우리의 목표를 이뤄야하며 여기에는 '디미터의 법칙'을 적용할 수 있습니다.

#### 상속

- 상속은 공통된 무엇인가를 계층형으로 묶기 위한 좋은 수단 중 하나입니다.
- 상속은 좋은 수단 중 하나이지만 오히려 잘 못 사용하면 개발자에게 인지부조화와 과도한 결합도를 유발시킬 수 있으며, 생각보다 LSP원칙을 적용하는데 난이도가 있다고 생각합니다. 그래서 저는 최대한 2뎁스가 넘어가지 않도록 설계하는게 좋다고 생각합니다.

#### 다형성

- 다형성은 자바에서 꽃이라고 생각합니다. 즉 다형성이 있기 때문에 여러 상황을 유연하게 대처할 수 있으며, 테스트 가능성 또한 증가시킬 수 있습니다.
- 자바에서 다형성은 '의존성 역전 원칙'을 통해 적용할 수 있습니다.

#### DIP 예제

- 예를들면 사용자가 글을 등록했을 때 로그를 어딘가에 남겨야하는데, 로그를 남기기 위해 외부 모듈을 사용해야한다면 DIP 원칙을 아래처럼 적용할 수 있습니다.
- DIP 원칙에서는 고수준은 저수준에 의존해서는 안됩니다. 마찬가지로 저수준 또한 고수준에 의존해서는 안됩니다. 둘 다 추상화에 의존해야 합니다. 만약 저수준의 어떤 행위가 고수준에 존재한다면 다시말해 feignClient, webclient와 같은 외부 모듈과 연동하기 위한 저수준 모듈이 PostCreateService 클래스에 위치하게 된다면 PostCreateService는 DIP 원칙을 위배할 뿐만 아니라 위부 모듈의 변경으로 인해 영향을 받는 범위 또한 넓어지게 됩니다. 그리고 테스트 가능성이 저하됩니다.

```java
@Service
@Transactional
@RequiredArgsConstructor
public class PostCreateService {
    
    private final LogService logService;
    
    public void save(String title, String content) {

        // 비지니스 로직 수행
        
        var now = LocalDateTime.now();
        logService.save(title, content, now);
    }
}

public interface LogService {

    void save(String title, String content, LocalDateTime createDatetime);
}

@Component
@RequiredArgsConstructor
public class LogServiceImpl implements LogService {

    @Override
    public void save(String title, String content, LocalDateTime createDatetime) {
        // 해당 구현에서는 feignClient, restTemplate, restClient, webclient 중 어떤 것을 사용해도 무방하다.
    }
}
```

<br>

## 06장 함수형 프로그래밍

- 함수형 패러다임에서 핵심이 되는 기반은 람다 계산법으로 알론조 처치가 1930년대에 발명했습니다.

#### 불변성과 아키텍처

- 멀티 스레드 환경에서의 애플리케이션은 race-condition, deadlock, concurrent-update 등 다양한 동시성 문제가 발생할 수 있습니다. 이 대부분은 가변성 변수로 인해 발생하는 문제점들이며 아키텍처를 고려할 때 이러한 문제가 발생하지 않도록 관심을 가져야합니다.

#### 가변성의 분리

- 상태가 변하는 것과 변하지 않는 것을 분리하여 여러가지 사이드 이펙트가 발생할 수 있는 상황을 분리하는 것입니다. 보통 CQS(Command Query Separation)라 불리는 원칙을 적용할 수도 있습니다.


