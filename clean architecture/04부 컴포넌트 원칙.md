# 컴포넌트 원칙

<br>

## 12장: 컴포넌트

- 컴포넌트는 배포 단위입니다. 컴포넌트는 시스템의 구성 요소로서 배포할 수 있는 가장 작은 단위입니다.
- 잘 설계된 컴포넌트라면 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 합니다.

### 컴포넌트의 간략한 역사

- 소프트웨어 초창기에는 프로그래머가 프로그램을 메모리의 어느 위치에 적재시킬지 고민하였다고 합니다. 또한 한번 적재를 시키면 재배치가 불가능한 구조였습니다.
- 예전에는 장치가 느리고 메모리가 너무 비싸서 소스 코드 전체를 메모리에 올려놓을 수 없었습니다. 결국 컴파일러는 느린 장치를 이용해서 소스 코드를 여러번 읽어야했습니다. 이 과정은 느리고 소스 코드가 클수록 많은 시간이 소요되었습니다.

#### 그 당시에 무엇이 문제였는가?

- 메모리는 한정적입니다. 하지만 애플리케이션은 점점 몸집이 커지고 결국 한정된 메모리에 애플리케이션을 적재시켜야하는데, 할당된 공간을 넘게되니 애플리케이션을 N개의 주소 세그먼트로 분리하여 메모리에 적재시키곤 했습니다. 하지만 외부 단편화 문제도 발생하고, 내부 단편화 문제도 발생하게 됩니다.

<br>

### 재배치성

- 로더를 사용해서 이 문제를 해결하였습니다.

#### 로더는 무엇인가?

- 로더는 바이너리 실행 파일을 메모리에 적재할 때 사용이 됩니다. Linker가 어떠한 프로그램을 실행시키기 위해 소스코드를 기계어로 변환(컴파일링)하여 실행 가능한 파일로 만듭니다. 그리고 Loader는 이 실행 가능한 파일을 메모리에 적재하는 역할을 수행합니다.

#### 재배치 가능 코드

- 재배치 가능 코드는 실행 시점에 주소를 바인딩하는 기법에 사용되는 방법입니다.
- 어떠한 프로그램이 메모리의 어디 위치로 적재되어야할지 컴파일 시점에 알지 못한다면 재배치 가능 코드를 생성해야 합니다. 이러한 재배치 가능 코드는 메모리의 어느 위치에서나 수행될 수 있는 기계 언어 코드인데 Loader가 프로그램을 메모리에 적재하는 시점에 물리 주소가 결정되게 됩니다. 그렇기 때문에 논리 주소와 물리 주소는 다를 수 있습니다.
- 논리 주소와 물리 주소가 다르므로 보통 MMU라는 것을 사용하여 논리 주소를 물리 주소로 변환하곤합니다.

#### 링커의 등장

- 1970년대 프로그래머들은 더 큰 야심을 품기 시작했고, 프로그램도 더욱 더 커졌습니다. 프로그램이 더 커질수록 링킹 로더가 너무 느려졌으며 결국 로더와 링크가 두 단계로 나뉘게 되었습니다.
- 클래스 파일을 오브젝트 파일로 컴파일한 후 링커로 전달되어 실행 가능한 파일로 만들었습니다.

<br>

## 13장: 컴포넌트 응집도

- 어떤 클래스를 어느 컴포넌트에 포함시켜야할지에 대해 알아봅니다.

<br>

### REP: 재사용/릴리스 등가 원칙

> 재사용 단위는 릴리스 단위와 같다라는 원칙입니다.

- 소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수 없고, 하지도 않을 것입니다.
- 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없으며, 무엇이 변했는지도 파악할 수 없습니다.
- 새로운 릴리스가 나온다면 개발자는 새 릴리스의 변경 사항일 살펴보고 기존 버전과 비교를 합니다. 그리고 계속 기존 버전을 사용할지 새로운 버전을 사용할지 결정하게 됩니다.

#### 이 원칙을 소프트웨어 아키텍처 관점에서 보자.

- 단일 컴포넌트는 응집도가 높은 클래스와 모듈들로 구성되어야 함을 뜻합니다. 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 합니다.
- 하나의 컴포넌트로 묶은 클래스와 모듈은 반드시 함께 릴리스되거나 릴리스 번호가 같아야하며 추적 관리나 동일한 릴리스 문서에 포함되어 있어야 합니다.

<br>

### CCP: 공통 패쇄 원칙

> "동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌틀로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 묶어라" 이 원칙은 SRP 원칙을 컴포넌트 관점에서 다시 쓴 것입니다. <br>
> 공통 폐쇄 원칙에서도 마찬가지로 단일 컴포넌트의 변경 이유는 하나여야라는 것입니다.

- CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한 곳으로 묶는것을 권장합니다. 물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야한다는 것입니다.

<br>

### CRP: 공통 재사용 원칙

> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라

- CRP에서는 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함되어야 한다고 말합니다.
- 어떤 컴포넌트가 다른 컴포넌트의 일부를 사용하더라도 우선 의존성이 생깁니다. 이러한 의존성으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트 역시 재컴파일, 재검증, 재배포를 해야할 가능성이 생깁니다. 그렇기 때문에 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지하고 있어야 합니다.

#### ISP와의 관계

- CRP는 인터페이스 분리 원칙의 포괄적인 버전입니다.
- ISP는 사용하지 않는 인터페이스에 의존하지 말라고 조언하는데, CRP도 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언합니다.
- 즉 ISP와 CRP는 필요하지 않는 것에 의존하지 말라고 말하고 있습니다.

<br>

### 컴포넌트 응집도에 대한 균형 다이어그램

- 아래 그림은 각 원칙들간의 상호작용을 나타내는 것이며 다이어그램의 각 변은 반대편 꼭지점에 있는 원칙을 포기할 때 감수해야하는 비용을 나타내는 것입니다.

<img width="1032" alt="스크린샷 2024-09-21 오후 5 19 50" src="https://github.com/user-attachments/assets/bc2901d6-1c76-4e6a-abdf-1ec231af9728">

<br>
<br>


## 14장: 컴포넌트 결합


<br>

#### 궁금증

- 멀티 모듈을 구성할 때 REP, CCP, CRP를 적용할 수 있을까?
- 멀티 모듈이 아니라면 하나의 프로젝트에서 인프라스트럭처 레벨에 해당하는 어떠한 컴포넌트들을 REP, CCP, CRP를 어떻게 적용할 수 있을까?




