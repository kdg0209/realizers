# 컴포넌트 원칙

<br>

## 12장: 컴포넌트

- 컴포넌트는 배포 단위입니다. 컴포넌트는 시스템의 구성 요소로서 배포할 수 있는 가장 작은 단위입니다.
- 잘 설계된 컴포넌트라면 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 합니다.

### 컴포넌트의 간략한 역사

- 소프트웨어 초창기에는 프로그래머가 프로그램을 메모리의 어느 위치에 적재시킬지 고민하였다고 합니다. 또한 한번 적재를 시키면 재배치가 불가능한 구조였습니다.
- 예전에는 장치가 느리고 메모리가 너무 비싸서 소스 코드 전체를 메모리에 올려놓을 수 없었습니다. 결국 컴파일러는 느린 장치를 이용해서 소스 코드를 여러번 읽어야했습니다. 이 과정은 느리고 소스 코드가 클수록 많은 시간이 소요되었습니다.

#### 그 당시에 무엇이 문제였는가?

- 메모리는 한정적입니다. 하지만 애플리케이션은 점점 몸집이 커지고 결국 한정된 메모리에 애플리케이션을 적재시켜야하는데, 할당된 공간을 넘게되니 애플리케이션을 N개의 주소 세그먼트로 분리하여 메모리에 적재시키곤 했습니다. 하지만 외부 단편화 문제도 발생하고, 내부 단편화 문제도 발생하게 됩니다.

<br>

### 재배치성

- 로더를 사용해서 이 문제를 해결하였습니다.

#### 로더는 무엇인가?

- 로더는 바이너리 실행 파일을 메모리에 적재할 때 사용이 됩니다. Linker가 어떠한 프로그램을 실행시키기 위해 소스코드를 기계어로 변환(컴파일링)하여 실행 가능한 파일로 만듭니다. 그리고 Loader는 이 실행 가능한 파일을 메모리에 적재하는 역할을 수행합니다.

#### 재배치 가능 코드

- 재배치 가능 코드는 실행 시점에 주소를 바인딩하는 기법에 사용되는 방법입니다.
- 어떠한 프로그램이 메모리의 어디 위치로 적재되어야할지 컴파일 시점에 알지 못한다면 재배치 가능 코드를 생성해야 합니다. 이러한 재배치 가능 코드는 메모리의 어느 위치에서나 수행될 수 있는 기계 언어 코드인데 Loader가 프로그램을 메모리에 적재하는 시점에 물리 주소가 결정되게 됩니다. 그렇기 때문에 논리 주소와 물리 주소는 다를 수 있습니다.
- 논리 주소와 물리 주소가 다르므로 보통 MMU라는 것을 사용하여 논리 주소를 물리 주소로 변환하곤합니다.

#### 링커의 등장

- 1970년대 프로그래머들은 더 큰 야심을 품기 시작했고, 프로그램도 더욱 더 커졌습니다. 프로그램이 더 커질수록 링킹 로더가 너무 느려졌으며 결국 로더와 링크가 두 단계로 나뉘게 되었습니다.
- 클래스 파일을 오브젝트 파일로 컴파일한 후 링커로 전달되어 실행 가능한 파일로 만들었습니다.

<br>

## 13장: 컴포넌트 응집도

- 어떤 클래스를 어느 컴포넌트에 포함시켜야할지에 대해 알아봅니다.

<br>

### REP: 재사용/릴리스 등가 원칙

> 재사용 단위는 릴리스 단위와 같다라는 원칙입니다.

- 소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수 없고, 하지도 않을 것입니다.
- 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없으며, 무엇이 변했는지도 파악할 수 없습니다.
- 새로운 릴리스가 나온다면 개발자는 새 릴리스의 변경 사항일 살펴보고 기존 버전과 비교를 합니다. 그리고 계속 기존 버전을 사용할지 새로운 버전을 사용할지 결정하게 됩니다.

#### 이 원칙을 소프트웨어 아키텍처 관점에서 보자.

- 단일 컴포넌트는 응집도가 높은 클래스와 모듈들로 구성되어야 함을 뜻합니다. 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 합니다.
- 하나의 컴포넌트로 묶은 클래스와 모듈은 반드시 함께 릴리스되거나 릴리스 번호가 같아야하며 추적 관리나 동일한 릴리스 문서에 포함되어 있어야 합니다.

<br>

### CCP: 공통 패쇄 원칙

> "동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌틀로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 묶어라" 이 원칙은 SRP 원칙을 컴포넌트 관점에서 다시 쓴 것입니다. <br>
> 공통 폐쇄 원칙에서도 마찬가지로 단일 컴포넌트의 변경 이유는 하나여야라는 것입니다.

- CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한 곳으로 묶는것을 권장합니다. 물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야한다는 것입니다.

<br>

### CRP: 공통 재사용 원칙

> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라

- CRP에서는 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함되어야 한다고 말합니다.
- 어떤 컴포넌트가 다른 컴포넌트의 일부를 사용하더라도 우선 의존성이 생깁니다. 이러한 의존성으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트 역시 재컴파일, 재검증, 재배포를 해야할 가능성이 생깁니다. 그렇기 때문에 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지하고 있어야 합니다.

#### ISP와의 관계

- CRP는 인터페이스 분리 원칙의 포괄적인 버전입니다.
- ISP는 사용하지 않는 인터페이스에 의존하지 말라고 조언하는데, CRP도 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언합니다.
- 즉 ISP와 CRP는 필요하지 않는 것에 의존하지 말라고 말하고 있습니다.

<br>

### 컴포넌트 응집도에 대한 균형 다이어그램

- 아래 그림은 각 원칙들간의 상호작용을 나타내는 것이며 다이어그램의 각 변은 반대편 꼭지점에 있는 원칙을 포기할 때 감수해야하는 비용을 나타내는 것입니다.

<img width="1032" alt="스크린샷 2024-09-21 오후 5 19 50" src="https://github.com/user-attachments/assets/bc2901d6-1c76-4e6a-abdf-1ec231af9728">

<br>
<br>

## 14장: 컴포넌트 결합

### ADP: 의존성 비순환 원칙

> 컴포넌트 의존성 그래프에 순환이 있어서는 안된다는 것입니다.

- 많은 개발자가 동일한 소소 파일을 수정하는 환경에서 '숙취 증후군'이 발생할 수 있습니다. '숙취 증후군'이란 내가 잘 동작하게 만들어 놓은 소스 코드가 다음날에 다른 사람의 수정으로 인하여 정상적으로 동작하지 않는 현상을 말합니다.

<br>

#### 순환 의존성 제거하기

- 의존성을 관리하기 위해서는 아래 그림처럼 컴포넌트 사이의 의존성 구조를 반드시 관리해야합니다. 의존성 구조에 순환이 있어서는 안됩니다.
- 아래 그림에서 어느 컴포넌트에서 시작하더라도 의존성 관계를 따라가면 최초의 컴포넌트로 되돌아갈 수 없습니다, 즉 구조에 순환이 없습니다. 이러한 구조를 비순환 방향 그래프(Directed Acyclic Graph)라고 합니다.
- 아래 그림에서 시스템 전체를 배포해야하는 경우에는 배포를 상향식으로 진행하면 됩니다. 즉 가장 아래부터 컴파일하고, 테스트하고 배포하면서 위로 올라오면 됩니다.

<img width="1032" alt="스크린샷 2024-09-22 오후 2 32 15" src="https://github.com/user-attachments/assets/640b6fde-f97e-474e-834f-5d221cf7d32d">

<br><br>

#### 순환이 컴포넌트 의존성 그래프에 미치는 영향

- 새로운 요구사항으로 인해 Entities 컴포넌트에 포함된 클래스 하나가 Authorizer 컴포넌트에 포함된 클래스 하나를 사용하게 되었다고 가정해봅시다.
- 예를들어 Database 컴포넌트를 개발하는 개발자는 컴포넌트를 배포하려고하면 Entities 컴포넌트와 반드시 호환해야 된다는 사실을 알고 있는데, Entities 컴포넌트는 Authorizer 컴포넌트에 의존하고 있으므로 관리 포인트가 늘어가게 됩니다.

<img width="1032" alt="스크린샷 2024-09-22 오후 2 38 21" src="https://github.com/user-attachments/assets/02de1e84-a74f-4e72-a68f-46aca0181b11">

<br><br>

#### 문제 해결 방법 1. 순환 끊기

- 의존성이 생기는 곳에 DIP를 적용함으로써 의존성을 끊어낼 수 있습니다.

<img width="1032" alt="스크린샷 2024-09-22 오후 2 49 43" src="https://github.com/user-attachments/assets/8e83d45c-744b-447c-9614-6f4511823a18">

<br><br>

#### 문제 해결 방법 2. 구조 개선

- 요구사항이 변경되면 기존 컴포넌트의 구조도 변경될 수 있습니다. 실제 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 흐트러지면서 또 성정합니다.
- 이 또한 그 당시에 맞는 컴포넌트 구조였지만 애플리케이션이 성장함에 따라 구조 개선이 이뤄져야 한다는 것을 시사합니다.

<br>

### 하향식 설계

 - 컴포넌트 구조는 하향식으로 설계될 수 없습니다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화합니다.
 - 컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도와 같습니다. 이러한 이유로 컴포넌트 구조를 프로젝트 초기에 설계할 수 없으며 컴포넌트들이 점차 쌓이면서 의존성 관리에 대한 요구가 중가하게 됩니다. 이때부터 REP, CCP, CDP에 관심을 가지게 됩니다.

<br>

### SDP: 안정된 의존성 원칙

> 안정성의 방향으로 의존하라.

- 설계는 결코 정적일 수 없으며, 설계를 유지하다 보면 변경은 불가피합니다. 공통 폐홰 원칙(CCP)을 준수함으로써, 컴포넌트가 다른 유형의 변경에는 영향을 받지 않으면서 특정 유형의 변경에만 민감하게 만들 수 있습니다. 이처럼 컴포넌트 중 일부는 변동성을 지니게 설계됩니다.
- 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대 안됩니다. 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워지게 됩니다.

#### 안정성

- 안정성은 변경을 만들기 위해 필요한 작업량과 관련됩니다. 예를들어 옆면으로 선 동전이 안정적이지 않은 이유는 힘을 조금만써도 넘어트릴 수 있기 때문입니다. 반면 탁자는 상당히 안정적인데 탁자를 뒤집으려면 상당한 힘들 써야하기 때문입니다.
- 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 방법 중 하나는 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것입니다. 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있는데, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하기란 매우 어렵고 시간이 많이 소요되기 때문입니다.

#### 안정된 컴포넌트

- 아래 그림에서 X 컴포넌트는 안정된 컴포넌트입니다. 3개의 컴포넌트가 X 컴포넌트에 의존하고 있으며, X 컴포넌트는 변경되지 말아야 할 이유를 세 가지나 가지고 있게되는 것입니다.
- X 컴포넌트는 3개의 컴포넌트를 책임지고 있으며, 반대로 X 컴포넌트는 어디에도 의존하지 않으므로 X 컴포넌트가 변경되도록 만들 수 있는 외적인 영향이 전혀 없고 X 컴포넌트는 독립적이라고 말할 수 있습니다.

<img width="1032" alt="스크린샷 2024-09-22 오후 3 30 49" src="https://github.com/user-attachments/assets/e00b14bc-6dde-4c91-9c7e-41f9cdbcc7c4">

<br><br>

#### 불안정한 컴포넌트

- 아래 그림에서 Y 컴포넌트는 상당히 불안정한 컴포넌트입니다. 어떤 컴포넌트도 Y 컴포넌트에 의존하지 않으므로 Y 컴포넌트는 책임성이 없다고 표현할 수 있지만 Y 컴포넌트는 세 개의 컴포넌트에 의존하고 있으므로 변경이 발생할 수 있는 이유가 세 가지가 되는 것입니다.

<img width="1032" alt="스크린샷 2024-09-22 오후 3 34 29" src="https://github.com/user-attachments/assets/915e8a21-103c-4007-9acf-74b3d460d0ef">

<br><br>

#### 모든 컴포넌트가 안정적이어야 하는 것은 아니다

- 모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능 합니다. 이는 바람직한 상황이 아닙니다. 우리는 안정된 컴포넌트와 불안정한 컴포넌트를 만들되 의존성을 어떻게 구성할것이냐를 중점적으로 생각해야 합니다.
- 모든 컴포넌트를 안정적으로 만들 수 없기 때문에 우리는 인터페이스나 추상 클래스를 활용하여 DIP를 적용해야 합니다.

<br>

### SAP: 안정된 추상화 원칙

> 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

#### 고수준 정책을 어디에 위치시켜야 하는가?

- 특정 상품에 대해 결제를 할 수 있다와 같은 업무 로직은 고수준 정책입니다. 이때 결제를 한다와 같은 고수준의 행위와 실제 특정 카드를 사용하여 결제가 이루어지는 행위는 저수준입니다. 이 또한 DIP를 생각해보면 어디에 무엇을 둬야할지 대략적으로 알 수 있습니다.

#### 안정된 추상화 원칙

- 안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의합니다.
- 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다고 말합니다. 다른 한편으로는 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 하는데, 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문입니다.
- 즉 안정적인 컼포넌트라면 반드시 인터페이스와 추상 클래스로 구성하고 쉽게 확장할 수 있어야 합니다.

<br>

#### 정리

- 이번장에서는 수 많은 원칙(REP, CCP, CDP, ADP, SDP, SAP)들이 등장합니다. 하지만 이 원칙들도 SOLID에서 개념이 확장된 것이므로 결국 SOLID에 대해 더 깊게 이해를 하고 해당 원칙들을 어떻게 컴포넌트를 설계할 떄 적용할 수 있는지를 보여주고 있습니다.

<br>

#### 궁금증

- 멀티 모듈을 구성할 때 REP, CCP, CRP를 적용할 수 있을까?
- 멀티 모듈이 아니라면 하나의 프로젝트에서 인프라스트럭처 레벨에 해당하는 어떠한 컴포넌트들을 REP, CCP, CRP를 어떻게 적용할 수 있을까?





