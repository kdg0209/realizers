# 프로그램이 실행되었지만 뭐가 뭔지 하나도 모르겟다

<br>

## 1. 운영 체제, 프로세스, 스레드의 근본 이해하기

#### 1-1. 모든 것은 CPU에서 시작된다

- CPU는 사실 스레드, 프로세스, 운영 체제와 같은 것들을 모르고 있습니다. CPU가 아는 것은 단 2가지 밖에 없습니다.
  - 메모리에서 명령어를 가져옵니다.
  - 가져온 명령어를 실행합니다.

🚗 과정

- CPU는 메모리에서 명령어를 가져와 실행하고, 다시 명령어를 가져와 실행하고 이 과정을 반복하게 됩니다. 그럼 CPU는 어떤 기준으로 명령어를 가져오게 되는걸까요?
- 그 답은 "프로그램 카운터(PC)"를 활용하여 CPU는 명령어를 가져오게 됩니다. 프로그램 카운터는 CPU가 다음에 실행해야할 명령어의 주소를 가리키고 있습니다. 그럼 가장 처음의 프로그램 카운터는 어떤걸까요? 바로 "실행 파일(object file)"에 그 답이 있습니다. 실행 파일에는 반드시 프로그램의 시작 지점이 있어야 하는데 그 지점이 바로 "main" 함수입니다. 
- 즉, 실행 파일이 메모리에 적재되어 실행되면 가장 먼저 main 함수가 실행되고, 여기서 프로그램 카운터가 처음으로 시작되며 이어서 다음 프로그램 카운터가 계속 진행되는 것입니다.

![스크린샷 2024-10-14 오후 11 36 57](https://github.com/user-attachments/assets/1fdc69ae-9772-464b-a5d9-6329e18dc2d6)

<br>

#### 1-2. CPU의 멀티 태스킹

- CPU의 자원은 한정적입니다. 그렇기 때문에 A 작업과 B 작업을 동시에 작업할 수 없습니다. 그래서 A 작업을 잠깐 하다가 멈추고, B 작업으로 넘어가 작업을 잠깐 하다가 멈추고, 다시 A 작업을 하고 .... 이 과정을 반복해야 한정적인 CPU의 자원을 효율적으로 사용할 수 있습니다.
그리고 A 작업으로 되돌아오거나, B 작업으로 되돌아갈때 특정 작업이 어디까지 했는지에 대한 정보를 어딘가에 보관해야 하는데, 그것을 문맥(context)이라 하고, 작업이 스레드에 한정된다면 TCB(Thread Control Block)에 저장되며, 프로세스라면 PCB(Process Control Block)에 저장됩니다.

#### 1-3. 프로세스의 주소 공간

- 프로세스의 정보(PCB)는 메모리내의 커널 영역에 저장됩니다.
- 프로세스가 메모리에 적재되면 아래와 같은 4개의 영역이 생성됩니다.
- <b>코드 영역</b>: CPU가 실행할 수 있는 명령어들이 저장되어 있습니다. 해당 영역은 읽기 전용입니다.
- <b>데이터 영역</b>: 프로그렘 전반에 사용되는 전역 변수들이 저장되어 있습니다.
- <b>힙 영역</b>: 여러 스레드들이 참조할 수 있는 영역이며, 동적 메모리 공간입니다.
- <b>스택 영역</b>: 함수 호출시 매개변수, 지역변수, 반환 주소등이 저장되어 있습니다. 각 스레드마다 생성되는 공간입니다.

#### 1-4. 스레드의 주소 공간

- 하나의 프로세스에서 코드 영역, 데이터 영역, 힙 영역을 공유하고, 각 스레드마다 스택 영역을 가집니다. 그렇기 때문에 프로세스를 생성해서 특정 작업을 실행시키는 것보다 스레드를 생성하여 특정 작업을 실행시키는게 더 효율적입니다. 그래서 스레드를 경량 프로세스라고도 부릅니다.
- 스택은 각 스레드마다 가지게 되며, 스택에는 함수의 매개변수, 지역변수, 반환 주소가 담겨있습니다.
- 스레드는 프로세스 내에서 실행되고, 스레드마다 아이디가 있으며, 프로그램 카운터를 비롯한 다양한 레지스터 값들이 있습니다. (TCB)

#### 1-5. 스레드 풀이란?

- 스레드를 사용자의 요청이 들어올때마다 생성하여, 작업을 실행시킨 뒤 작업을 완료하게되면 삭제하고 ... 이러한 과정을 반복하면 결국 메모리도 낭비하게 되고, 오버헤드도 증가하게 됩니다.
  1. 스레드의 생성과 종료에 많은 시간을 소요하게 됩니다. (오버헤드 증가)
  2. 스레드마다 각자의 메모리 공간을 소요하게 됩니다. (스택 영역)
  3. 스레드 수가 많으면 context-switch 비용 발생 (오버헤드 증가)

💡 그래서 스레드 풀!

- 스레드 풀의 개념은 간단합니다. 미리 스레드를 N개 생성하여 풀에 넣어놓고, 사용자의 요청이 들어올때마다 하나씩 할당해주는 것입니다. 그리고 작업이 끝나면 다시 풀로 반환시키면 됩니다.

#### 1-6. 적절한 스레드 풀의 수는?

- 스레드 풀에 스레드가 너무 많다면 오히려 context-switch 비용이 많이 발생하게 되고, 스레드 수가 적다면 CPU를 최대한 활용할 수 없게됩니다. 그래서 적절한 스레드의 수를 찾아야 합니다.

💡 CPU 버스트 Vs I/O 버스트

- 연산 작업이 많은 경우 CPU 버스트가 많은 작업들이고, 네트워크 접근, 데이터베이스 접근, 파일 접근 등이 많을 때는 I/O 버스트가 많은 작업들입니다. 따라서 애플리케이션이 어떤 작업들이 많은지 파악한 뒤에 적절한 테스트를 통해 스레드의 개수를 조정해야 합니다.

<br>

## 2. 스레드 간 공유되는 프로세스 리소스

#### 2-1. 스레드 전용 리소스

- 스레드의 정보는 스택 영역에 저장됩니다. 스택 영역에 저장되는 내용은 매개변수, 지역변수, 함수의 반환 주소, 스택 포인터, 프로그램 카운터(PC)등과 같은 레지스터 정보들이 저장됩니다.

코드 영역이란?

- CPU가 실행할 수 있는 명령어들이 저장되어 있는 영역이며, 읽기 전용(read-only)입니다.
- 실행할 수 있는 명령어란 프로그래머가 작성한 코드를 컴파일러가 컴파일한 후 생성된 실행 가능한 명령어를 말합니다.

데이터 영역이란?

- 프로그램 전반에 사용되는 전역 변수들이 저장되어 있는 영역입니다.

힙 영역이란?

- 프로그래머가 new와 같은 키워드를 사용하여 객체를 생성하면 힙 영역에 할당됩니다.
- 힙 영역은 프로그래머가 조절 할 수 있는 동적인 메모리 공간입니다.
- 힙 영역에서 사용한 메모리를 반환하지 않으면 메모리 공간에 계속 남게되며, 이는 결국 메모리 누수로 이어집니다.
- 힙 영역은 메모리의 낮은 주소에서 높은 주소로 할당되고, 스택 영역은 메모리의 높은 주소에서 낮은 주소로 할당됩니다. 그래야만 힙 영역과 스택 영역에 데이터가 쌓이더라도 겹칠일이 없어집니다.

스택 영역이란?

- 함수 호출시 매개변수, 지역변수, 함수 종료 후 반환 주소, 프로그램 카운터, 스택 포인터 등의 레지스터가 저장되는 영역입니다.
- 데이터를 일시적으로 저장하는 공간이기도 합니다. 예를들어 스레드가 특정 함수를 실행하면 지역변수를 사용하였다가 함수가 종료되면 사용한 지역변수는 메모리 내에서 없어집니다.
- 스택 영역에 있다고 해서 무조건 안전한 것은 아닙니다. 스택 영역에서 힙 영역에 있는 변수를 참조하고 있다면 해당 변수에 대해 동시성 이슈 문제는 발생할 수 있습니다.

![스크린샷 2024-10-16 오후 10 50 10](https://github.com/user-attachments/assets/1f6eae03-3f69-4324-9f5e-b90995badbd4)

<br>

#### 2-2. 스레드 전용 저장소

- 스레드 전용 저장소란 각 스레드마다의 보관함을 의미합니다.
- 모든 스레드가 동일한 변수에 접근하는 것처럼 보이지만, 사실 변수의 인스턴스는 각각의 스레드에 속합니다. 따라서 하나의 스레드에서 변수의 값을 변경해도 다른 스레드의 변수에는 영향을 미치지 않습니다.
- 스레드 전용 저장소를 사용하면 각각의 스레드에서 독점적으로 변수를 사용할 수 있습니다. 즉, 이 변수들은 모든 스레드에서 접근할 수 있지만 해당 변수는 초기화한 후 각각의 스레드가 복사본을 가지게 되며, 하나의 스레드에서 변수값을 변경하더라도 다른 스레드의 변수에는 영향을 미치지 않게 되는것입니다.
- 자바에서는 ThreadLocal 라는 클래스를 활용할 수 있습니다.

<br>

## 3. 스레드 안전한 코드는 어떻게 작성해야할까?

#### 3-1. 자유와 제약

- 누구나 자신의 집에서는 자유로움을 느낍니다. 하지만 공공장소에서는 집에서 하던것처럼 자유롭게 행동할 수 없습니다. 예를들어 공중 화장실에 가려면 줄을 서야하고, 자신의 차례가 오면 입장이 가능합니다. 여기서 공중 화장실을 공유 자원에 빗대어 표현할 수 있습니다. 즉 공유 자원을 사용하기 위해서는 제약이 따르며, 순서를 지켜야 한다는 것입니다.

#### 3-2. 스레드 안전이란 무엇인가?

- 스레드 안전이란 여러 스레드가 동일한 변수에 접근하더라도 변수의 값에 이상이 생기지 않고, 항상 올바른 값을 출력하는 것입니다.
- 스레드 안전하기 위해서는 다양한 Lock 기법이나, 세마포어 기법들을 사용할 수도 있습니다. 또한 이때 데드락이 발생하지 않도록 공유 리소스에 접근할 때 순차적으로 접근할 수 있도록 구성해야 합니다.

상황 1. 지역 변수 사용

- 지역 변수는 스레드의 스택 영역에 생성되여, 함수 호출시 메모리에 데이터가 생성되고 함수가 종료되면 메모리에서 제거됩니다. 각 스레드의 스택 영역에 데이터가 생성되니 스레드 안전합니다.

```java
public Integer sum() {
    Integer a = 5;
    Integer b = 5;

    return a + b;
}
```

상황 2. 매개변수 사용

- 함수 호출시 매개변수로 데이터를 전달하더라도 여전히 스레드 안전합니다.
- 하지만 객체를 넘기게 되면 스레드에 안전하지 않을 수 있습니다.

```java
public Integer sum(Integer b) {
    Integer a = 5;

    return a + b;
}
```

상황 3. 전역 변수 사용

- 전역 변수를 사용하여 여러 스레드에서 값을 변경하면 동시성 이슈로 인해 스레드 안전에 문제가 발생하게 됩니다.

```java
public class Example {

    // 전역 변수
    private int num = 100;

    @Test
    void example() throws InterruptedException {

        int threadCount = 1000;
        CountDownLatch latch = new CountDownLatch(threadCount);

        for (int i = 0; i < threadCount; i++) {
            try {
                CompletableFuture.runAsync(() -> num++);
            } finally {
                latch.countDown();
            }
        }
        
        latch.await();
        System.out.println(num);
    }
}
```

#### 💡 스레드 안전한 코드를 어떻게 작성할 수 있을까?

스레드 전용 저장소

- 공유 리소스를 사용하는 경우 스레드 전용 저장소를 사용하면 공유 리소스를 복제하여 사용하기 때문에 스레드 안전합니다.

읽기 전용

- 공유 리소스를 사용하더라도 값을 변경하지 않고 읽기만 한다면 스레드 안전합니다.

불변 객체 사용

- 값을 변경한다면 기존 값에 어떠한 값을 변경하는게 아니라 새로운 객체를 만드는 방법입니다.

원자성 연산

- 값을 변경하는 행위가 원자적으로 이루어진다면 스레드간 context-swich가 발생하지 않기 때문에 스레드 안전합니다.

동기화시 상호 배제

- 뮤텍스, 세마포어, 모니터 락, 스핀 락과 같은 다양한 잠금 기법을 사용하여 임계 영역을 생성하면 스레드 안전한 코드를 작성할 수 있습니다.

<br>

## 4. 코루틴을 어떻게 이해해야할까?
























