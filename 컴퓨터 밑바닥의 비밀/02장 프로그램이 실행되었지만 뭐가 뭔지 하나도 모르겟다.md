# 프로그램이 실행되었지만 뭐가 뭔지 하나도 모르겟다

<br>

## 1. 운영 체제, 프로세스, 스레드의 근본 이해하기

#### 1-1. 모든 것은 CPU에서 시작된다

- CPU는 사실 스레드, 프로세스, 운영 체제와 같은 것들을 모르고 있습니다. CPU가 아는 것은 단 2가지 밖에 없습니다.
  - 메모리에서 명령어를 가져옵니다.
  - 가져온 명령어를 실행합니다.

🚗 과정

- CPU는 메모리에서 명령어를 가져와 실행하고, 다시 명령어를 가져와 실행하고 이 과정을 반복하게 됩니다. 그럼 CPU는 어떤 기준으로 명령어를 가져오게 되는걸까요?
- 그 답은 "프로그램 카운터(PC)"를 활용하여 CPU는 명령어를 가져오게 됩니다. 프로그램 카운터는 CPU가 다음에 실행해야할 명령어의 주소를 가리키고 있습니다. 그럼 가장 처음의 프로그램 카운터는 어떤걸까요? 바로 "실행 파일(object file)"에 그 답이 있습니다. 실행 파일에는 반드시 프로그램의 시작 지점이 있어야 하는데 그 지점이 바로 "main" 함수입니다.
- 즉, 실행 파일이 메모리에 적재되어 실행되면 가장 먼저 main 함수가 실행되고, 여기서 프로그램 카운터가 처음으로 시작되며 이어서 다음 프로그램 카운터가 계속 진행되는 것입니다.

![스크린샷 2024-10-14 오후 11 36 57](https://github.com/user-attachments/assets/1fdc69ae-9772-464b-a5d9-6329e18dc2d6)

<br>

#### 1-2. CPU의 멀티 태스킹

- CPU의 자원은 한정적입니다. 그렇기 때문에 A 작업과 B 작업을 동시에 작업할 수 없습니다. 그래서 A 작업을 잠깐 하다가 멈추고, B 작업으로 넘어가 작업을 잠깐 하다가 멈추고, 다시 A 작업을 하고 .... 이 과정을 반복해야 한정적인 CPU의 자원을 효율적으로 사용할 수 있습니다.
  그리고 A 작업으로 되돌아오거나, B 작업으로 되돌아갈때 특정 작업이 어디까지 했는지에 대한 정보를 어딘가에 보관해야 하는데, 그것을 문맥(context)이라 하고, 작업이 스레드에 한정된다면 TCB(Thread Control Block)에 저장되며, 프로세스라면 PCB(Process Control Block)에 저장됩니다.

#### 1-3. 프로세스의 주소 공간

- 프로세스의 정보(PCB)는 메모리내의 커널 영역에 저장됩니다.
- 프로세스가 메모리에 적재되면 아래와 같은 4개의 영역이 생성됩니다.
- <b>코드 영역</b>: CPU가 실행할 수 있는 명령어들이 저장되어 있습니다. 해당 영역은 읽기 전용입니다.
- <b>데이터 영역</b>: 프로그렘 전반에 사용되는 전역 변수들이 저장되어 있습니다.
- <b>힙 영역</b>: 여러 스레드들이 참조할 수 있는 영역이며, 동적 메모리 공간입니다.
- <b>스택 영역</b>: 함수 호출시 매개변수, 지역변수, 반환 주소등이 저장되어 있습니다. 각 스레드마다 생성되는 공간입니다.

#### 1-4. 스레드의 주소 공간

- 하나의 프로세스에서 코드 영역, 데이터 영역, 힙 영역을 공유하고, 각 스레드마다 스택 영역을 가집니다. 그렇기 때문에 프로세스를 생성해서 특정 작업을 실행시키는 것보다 스레드를 생성하여 특정 작업을 실행시키는게 더 효율적입니다. 그래서 스레드를 경량 프로세스라고도 부릅니다.
- 스택은 각 스레드마다 가지게 되며, 스택에는 함수의 매개변수, 지역변수, 반환 주소가 담겨있습니다.
- 스레드는 프로세스 내에서 실행되고, 스레드마다 아이디가 있으며, 프로그램 카운터를 비롯한 다양한 레지스터 값들이 있습니다. (TCB)

#### 1-5. 스레드 풀이란?

- 스레드를 사용자의 요청이 들어올때마다 생성하여, 작업을 실행시킨 뒤 작업을 완료하게되면 삭제하고 ... 이러한 과정을 반복하면 결국 메모리도 낭비하게 되고, 오버헤드도 증가하게 됩니다.
  1. 스레드의 생성과 종료에 많은 시간을 소요하게 됩니다. (오버헤드 증가)
  2. 스레드마다 각자의 메모리 공간을 소요하게 됩니다. (스택 영역)
  3. 스레드 수가 많으면 context-switch 비용 발생 (오버헤드 증가)

💡 그래서 스레드 풀!

- 스레드 풀의 개념은 간단합니다. 미리 스레드를 N개 생성하여 풀에 넣어놓고, 사용자의 요청이 들어올때마다 하나씩 할당해주는 것입니다. 그리고 작업이 끝나면 다시 풀로 반환시키면 됩니다.

#### 1-6. 적절한 스레드 풀의 수는?

- 스레드 풀에 스레드가 너무 많다면 오히려 context-switch 비용이 많이 발생하게 되고, 스레드 수가 적다면 CPU를 최대한 활용할 수 없게됩니다. 그래서 적절한 스레드의 수를 찾아야 합니다.

💡 CPU 버스트 Vs I/O 버스트

- 연산 작업이 많은 경우 CPU 버스트가 많은 작업들이고, 네트워크 접근, 데이터베이스 접근, 파일 접근 등이 많을 때는 I/O 버스트가 많은 작업들입니다. 따라서 애플리케이션이 어떤 작업들이 많은지 파악한 뒤에 적절한 테스트를 통해 스레드의 개수를 조정해야 합니다.

<br>

## 2. 스레드 간 공유되는 프로세스 리소스

#### 2-1. 스레드 전용 리소스

- 스레드의 정보는 스택 영역에 저장됩니다. 스택 영역에 저장되는 내용은 매개변수, 지역변수, 함수의 반환 주소, 스택 포인터, 프로그램 카운터(PC)등과 같은 레지스터 정보들이 저장됩니다.

코드 영역이란?

- CPU가 실행할 수 있는 명령어들이 저장되어 있는 영역이며, 읽기 전용(read-only)입니다.
- 실행할 수 있는 명령어란 프로그래머가 작성한 코드를 컴파일러가 컴파일한 후 생성된 실행 가능한 명령어를 말합니다.

데이터 영역이란?

- 프로그램 전반에 사용되는 전역 변수들이 저장되어 있는 영역입니다.

힙 영역이란?

- 프로그래머가 new와 같은 키워드를 사용하여 객체를 생성하면 힙 영역에 할당됩니다.
- 힙 영역은 프로그래머가 조절 할 수 있는 동적인 메모리 공간입니다.
- 힙 영역에서 사용한 메모리를 반환하지 않으면 메모리 공간에 계속 남게되며, 이는 결국 메모리 누수로 이어집니다.
- 힙 영역은 메모리의 낮은 주소에서 높은 주소로 할당되고, 스택 영역은 메모리의 높은 주소에서 낮은 주소로 할당됩니다. 그래야만 힙 영역과 스택 영역에 데이터가 쌓이더라도 겹칠일이 없어집니다.

스택 영역이란?

- 함수 호출시 매개변수, 지역변수, 함수 종료 후 반환 주소, 프로그램 카운터, 스택 포인터 등의 레지스터가 저장되는 영역입니다.
- 데이터를 일시적으로 저장하는 공간이기도 합니다. 예를들어 스레드가 특정 함수를 실행하면 지역변수를 사용하였다가 함수가 종료되면 사용한 지역변수는 메모리 내에서 없어집니다.
- 스택 영역에 있다고 해서 무조건 안전한 것은 아닙니다. 스택 영역에서 힙 영역에 있는 변수를 참조하고 있다면 해당 변수에 대해 동시성 이슈 문제는 발생할 수 있습니다.

![스크린샷 2024-10-16 오후 10 50 10](https://github.com/user-attachments/assets/1f6eae03-3f69-4324-9f5e-b90995badbd4)

<br>

#### 2-2. 스레드 전용 저장소

- 스레드 전용 저장소란 각 스레드마다의 보관함을 의미합니다.
- 모든 스레드가 동일한 변수에 접근하는 것처럼 보이지만, 사실 변수의 인스턴스는 각각의 스레드에 속합니다. 따라서 하나의 스레드에서 변수의 값을 변경해도 다른 스레드의 변수에는 영향을 미치지 않습니다.
- 스레드 전용 저장소를 사용하면 각각의 스레드에서 독점적으로 변수를 사용할 수 있습니다. 즉, 이 변수들은 모든 스레드에서 접근할 수 있지만 해당 변수는 초기화한 후 각각의 스레드가 복사본을 가지게 되며, 하나의 스레드에서 변수값을 변경하더라도 다른 스레드의 변수에는 영향을 미치지 않게 되는것입니다.
- 자바에서는 ThreadLocal 라는 클래스를 활용할 수 있습니다.

<br>

## 3. 스레드 안전한 코드는 어떻게 작성해야할까?

#### 3-1. 자유와 제약

- 누구나 자신의 집에서는 자유로움을 느낍니다. 하지만 공공장소에서는 집에서 하던것처럼 자유롭게 행동할 수 없습니다. 예를들어 공중 화장실에 가려면 줄을 서야하고, 자신의 차례가 오면 입장이 가능합니다. 여기서 공중 화장실을 공유 자원에 빗대어 표현할 수 있습니다. 즉 공유 자원을 사용하기 위해서는 제약이 따르며, 순서를 지켜야 한다는 것입니다.

#### 3-2. 스레드 안전이란 무엇인가?

- 스레드 안전이란 여러 스레드가 동일한 변수에 접근하더라도 변수의 값에 이상이 생기지 않고, 항상 올바른 값을 출력하는 것입니다.
- 스레드 안전하기 위해서는 다양한 Lock 기법이나, 세마포어 기법들을 사용할 수도 있습니다. 또한 이때 데드락이 발생하지 않도록 공유 리소스에 접근할 때 순차적으로 접근할 수 있도록 구성해야 합니다.

상황 1. 지역 변수 사용

- 지역 변수는 스레드의 스택 영역에 생성되여, 함수 호출시 메모리에 데이터가 생성되고 함수가 종료되면 메모리에서 제거됩니다. 각 스레드의 스택 영역에 데이터가 생성되니 스레드 안전합니다.

```java
public Integer sum() {
    Integer a = 5;
    Integer b = 5;

    return a + b;
}
```

상황 2. 매개변수 사용

- 함수 호출시 매개변수로 데이터를 전달하더라도 여전히 스레드 안전합니다.
- 하지만 객체를 넘기게 되면 스레드에 안전하지 않을 수 있습니다.

```java
public Integer sum(Integer b) {
    Integer a = 5;

    return a + b;
}
```

상황 3. 전역 변수 사용

- 전역 변수를 사용하여 여러 스레드에서 값을 변경하면 동시성 이슈로 인해 스레드 안전에 문제가 발생하게 됩니다.

```java
public class Example {

    // 전역 변수
    private int num = 100;

    @Test
    void example() throws InterruptedException {

        int threadCount = 1000;
        CountDownLatch latch = new CountDownLatch(threadCount);

        for (int i = 0; i < threadCount; i++) {
            try {
                CompletableFuture.runAsync(() -> num++);
            } finally {
                latch.countDown();
            }
        }
        
        latch.await();
        System.out.println(num);
    }
}
```

#### 💡 스레드 안전한 코드를 어떻게 작성할 수 있을까?

스레드 전용 저장소

- 공유 리소스를 사용하는 경우 스레드 전용 저장소를 사용하면 공유 리소스를 복제하여 사용하기 때문에 스레드 안전합니다.

읽기 전용

- 공유 리소스를 사용하더라도 값을 변경하지 않고 읽기만 한다면 스레드 안전합니다.

불변 객체 사용

- 값을 변경한다면 기존 값에 어떠한 값을 변경하는게 아니라 새로운 객체를 만드는 방법입니다.

원자성 연산

- 값을 변경하는 행위가 원자적으로 이루어진다면 스레드간 context-swich가 발생하지 않기 때문에 스레드 안전합니다.

동기화시 상호 배제

- 뮤텍스, 세마포어, 모니터 락, 스핀 락과 같은 다양한 잠금 기법을 사용하여 임계 영역을 생성하면 스레드 안전한 코드를 작성할 수 있습니다.

<br>

## 4. 코루틴을 어떻게 이해해야할까?

#### 일반 함수

- 아래 두 메서드가 있을 때 bar() 메서드를 호출하면 foo() 메서드가 호출됩니다. 이때 foo() 메서드에서는 순차적으로 "a", "b", "c"가 출력됩니다.

```java
void bar() {
    foo();
}

void foo() {
    System.out.println("a");
    System.out.println("b");
    System.out.println("c");
}
```

<img width="1032" alt="스크린샷 2024-10-18 오후 8 45 48" src="https://github.com/user-attachments/assets/8c5d9c4a-b92f-48f6-be82-5158760bdbfa">

<br>

#### 코루틴 함수

- 코루틴은 자신의 실행 상태를 저장할 수 있기 때문에 코루틴이 반환된 후에도 계속 호출이 가능하며, 더군다나 일시 중지된 지점에서 다시 이어서 작업을 실행시킬 수 있습니다.
- 코루틴의 함수가 반환될 때 함수의 실행 정보를 저장할 필요가 있는데, 그 이유는 코루틴이 실행이 멈추었던 지점에서 다시 실행할 때 이 정보가 필요하기 때문입니다.
- 컴퓨터 시스템은 주기적으로 타이머 인터럽트를 생성하고, 이 인터럽트에 의해 운영체제는 스레드에게 CPU를 할당하고, 작업을 실행시킨 뒤 다른 스레드에게 CPU를 할당하고 작업을 시키고 이러한 과정들을 번갈아 수행하게 됩니다. 하지만 User Mode에서는 운영체제처럼 타이머 인터럽트가 존재하지 않기 때문에 코루틴에서는 반드시 특정 키워드(yield)를 사용하여 어디에서 일시 중지하고 CPU 자원을 내어줄지 명시적으로 선언해야합니다.
- 코루틴은 User Mode에서 구현된 것이기 때문에 운영체제는 이를 알 수 없습니다.

```java
void bar() {
    foo();
}

void foo() {
    System.out.println("a");
    // 일시 중지 및 반환
    System.out.println("b");
    // 일시 중지 및 반환
    System.out.println("c");
}
```

<img width="1032" alt="스크린샷 2024-10-18 오후 8 46 59" src="https://github.com/user-attachments/assets/858a0669-32f0-4801-9823-b9a8d303d9ed">

<br>

#### 코루틴의 구현

- 코루틴의 구현은 사실 스레드와 본질적인 차이가 없다고 합니다. 코루틴도 동일하게 일시 중지되었다가 다시 실행할 수 있으며, 일시 중지될 때 상태 정보를 반드시 어딘가에 저장하고 다시 실행될 때 상태 정보를 가져와 실행되게 됩니다.
- 코루틴의 상태 정보에는 CPU 레지스터의 정보, 함수 실행시 상태 정보들이 포함되어 있습니다.
- 코루틴의 스택 프레임 정보는 힙 영역에 저장되며, 힙 영역이 충분하다면 코루틴 개수에는 제한이 없으며 코루틴 간 전환이나 스케줄링은 User Mode에서 일어나기 때문에 운영체제가 개입할 필요가 없습니다. 또한 코루틴간에 전환할 때 저장 또는 복구되는 정보도 가볍기 때문에 효율성이 높습니다.

<br>

## 5. 콜백 함수

#### 일반 함수

- bar() 메서드 호출시 foo() 메서드가 내부적으로 수행되는데, foo() 메서드의 수행시간이 오래걸리거나, 많은 요청으로 인해 처리량이 늦어질 때 아래 로직을 개선해야합니다. 이때 콜백 함수를 사용해서 어떻게 개선할 수 있는지 살펴보겠습니다.

```java
void bar() {
    foo();
}

void foo() {
    System.out.println("a");
    System.out.println("b");
    System.out.println("c");
}
```

#### 콜백 함수

- 콜백 함수란 다른 코드의 매개변수로 넘겨주는 실행 가능한 코드를 의미합니다.
- 아래 예제를 보면 자바의 함수형 인터페이스인 Function를 사용하여 함수의 매개변수로 실행가능한 코드를 넘겨주고 있습니다.

```java
void bar() {
    foo(List.of("a", "b", "c"), (o1) -> o1.toUpperCase());
}

void foo(List<String> list, Function<String, String> function) {
    list.forEach(s -> {
        String temp = function.apply(s);
        System.out.println(temp);
    });
}
```

#### 비동기 콜백 함수

- 다양한 프로그래밍 언어에서는 비동기 콜백 함수의 방법을 지원한고 있습니다. 자바에서는 Future, CompletableFuture 등을 자유롭게 사용할 수 있습니다.
- 함수를 호출한 스레드에서 작업이 처리되지 않고, 다른 스레드에서 작업이 처리됩니다.

<br>

## 6. 동기와 비동기

### 동기란 무엇일까?

- 예를들어 직장 상사가 프로그래머에게 어떠한 작업을 부탁하였는데, 해당 작업이 완료될때까지 옆에서 지켜보는 것입니다. 그럼 직장 상사는 아무런 작업을 못하고 프로그래머에게 부탁한 작업이 완료되어야 직장 상사는 자신의 작업을 이어서할 수 있게 됩니다.

#### 동기 예제 코드

- 아래 예제 코드를 보면 bar() 메서드 내부에서 foo() 메서드를 호출하고 있습니다. 이때 bar() 메서드는 foo() 메서드의 작업이 완료되어야 이후 작업을 수행할 수 있습니다.

```java
void bar() {

    // foo 메서드의 작업이 완료될때까지 기다리고 이후 작업 수행
    foo();
    
    // ... foo 메서드의 작업이 완료되면 이후 작업 진행
}

String foo() {
    StringBuilder sb = new StringBuilder();

    Path path = Paths.get("file.txt");
    try (BufferedReader reader = Files.newBufferedReader(path)) {
        String line;

        while ((line = reader.readLine()) != null) {
            sb.append(line.toUpperCase());
        }
    }

    return sb.toString();
}
```
<br>

### 비동기란 무엇일까?

- 예를들어 직장 상사가 프로그래머에게 어떠한 작업을 부탁하였는데, 해당 작업이 완료될때까지 옆에서 지켜보는게 아니라, 작업이 완료되면 슬랙으로 알려줘~라고 한 뒤, 직장 상사는 자신의 업무를 이어나가는 것입니다. 위 예제랑 보면 효율성이 더 높아지겠구나!라는 생각이 들 수 있습니다.

#### 비동기 예제 코드

- 아래 예제 코드를 보면 bar() 메서드 내부에서 foo() 메서드를 호출하고 있습니다. 하지만 foo() 메서드의 작업은 비동기로 작업을 처리하고 있어 bar() 메서드는 그 다음 로직을 수행할 수 있습니다.

```java
void bar() {

    // foo 메서드의 작업이 완료될때까지 기다리지 않고 다음 작업 수행
    foo();

    // ... foo 메서드의 작업이 완료되지 않아도 수행 가능
}

String foo() {
    Path path = Paths.get("file.txt");

    AsynchronousFileChannel channel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    long position = 0;

    Future<Integer> operation = channel.read(buffer, position);

    while(!operation.isDone());

    buffer.flip();
    byte[] data = new byte[buffer.limit()];
    buffer.get(data);
    buffer.clear();
    return new String(data);
}
```
<br>

### 💡 비동기는 동기에 비해 무엇이 좋을까?

- 비동기 메서드를 호출하면 호출자는 호출한 메서드의 작업이 끝나지 않아도 다른 작업을 이어나갈 수 있습니다. 하지만 비동기 메서드는 다른 스레드에 의해 작업이 진행되므로 작업의 결과를 어떻게 전달받을 것인지 고려할 필요가 있습니다. 물론 작업의 결과를 신경쓰지 않아도 되는 경우가 있지만 이번에는 작업의 결과를 어떻게 전달받을지에 대한 내용으로 작성하겠습니다.

#### 1. 콜백 함수로 전달받기

- 아래 그림처럼 함수 호출시 매개변수에 콜백 함수를 전달하여, 특정 작업이 완료되면 콜백 함수를 실행시켜 이후 작업을 이어나갈 수 있도록 하는 것입니다.

<img width="1032" alt="스크린샷 2024-10-20 오후 4 33 21" src="https://github.com/user-attachments/assets/5e7bc2ec-c22a-43a2-a5c0-180cd9be2521">

<br>

#### 2. 알림 사용하기

- 아래 그림처럼 함수의 특정 작업이 완료되면 알림을 발생시켜, 호출자에게 특정 작업이 완료되었다 라는것을 알려주는 것입니다. 그럼 호출자는 자신의 작업을 잠시 중지하고 알림을 통해 이전 직업의 남은 작업들을 완료할 수 있습니다.

<img width="1032" alt="스크린샷 2024-10-20 오후 4 35 39" src="https://github.com/user-attachments/assets/d8c91a3f-9c36-4497-bc4c-a526a74f1e02">

<br>

### 비동기 작업의 예제들

- 아래 그림을 보면 사용자의 요청이 들어왔을때 A-> B -> C -> DB -> D -> E -> F 순으로 작업을 요청하게 됩니다. 이때 DB는 다른 작업들에비해 더 많은 작업의 시간이 소요되게 되는데, 어떻게 개선할 수 있을까요?

<img width="1032" alt="스크린샷 2024-10-20 오후 4 44 03" src="https://github.com/user-attachments/assets/04a25169-dff7-4c47-b199-3d88e1daf6ad">

<br>

#### 🧐 주 스레드가 DB 처리 결과를 신경쓰지 않는 경우

- 주 스레드가 작업의 결과를 신경쓰지 않는다면 DB 호출 함수에 콜백 함수를 인자로 넘겨 DB의 작업이 끝나면 콜백 함수를 통해 특정 작업이 실행가능하도록 구현할 수 있습니다.

<img width="1032" alt="스크린샷 2024-10-20 오후 4 47 18" src="https://github.com/user-attachments/assets/c3dcab50-ea37-4b6e-9c6d-7f93d396688b">

<br>

#### 🧐 주 스레드가 DB 처리 결과를 관심을 가지는 경우

- 주 스레드가 작업의 결과에 대해 관심을 가지는 경우 알림을 통해서 주 스레드에게 알릴 수 있습니다. 그리고 알림을 전달받은 주 스레드는 특정 작업을 수행할 수 있게 됩니다.

<img width="1032" alt="스크린샷 2024-10-20 오후 4 51 12" src="https://github.com/user-attachments/assets/4a7ca76e-156f-4d94-859c-2a34764a859b">

<br><br>

## 7. 블로킹와 논블로킹

### 블로킹이란 무엇일까?

- 함수 A와 함수 B가 있다고 가정해봅시다. 함수 A가 함수 B를 호출할 때, 운영체제가 함수 A를 실행시킨 스레드를 일시중지한다면 함수 B에 대한 호출 방식은 블로킹 방식입니다.
- 만약 아래와 같은 코드가 있다고 무조건 블로킹 방식의 코드는 아닙니다. 위에서 언급한 것처럼 운영체제가 해당 스레드를 일시중지하고 다른 스레드에게 CPU 자원을 할당할 때 블로킹이 되는 것입니다. 대표적인 예로는 파일 I/O나 네트워크 I/O가 해당됩니다.
- 프로그래밍 관점에서 동기 호출은 반드시 블로킹 호출이 아닙니다. 아래 예제가 설명에 해당됩니다. 반면에 블로킹 호출은 무조건 동기 호출입니다.

```java
void bar() {

  foo(10, 20);
}

int foo(int a, int b) {

  return a + b;
}
```

![스크린샷 2024-10-20 오후 9 53 11](https://github.com/user-attachments/assets/caa08738-bd99-4877-a002-19efb9788d1c)

<br>

### 논블로킹이란 무엇일까?

- 함수 A와 함수 B가 있다고 가정해봅시다. 함수 A가 함수 B를 호출할 때, 운영체제가 함수 A를 실행시킨 스레드를 일시중지하지 않고, 특정 데이터를 바로 반환하는 것입니다. 이후 함수 A를 실행시킨 스레드는 계속 작업을 처리하게 되고 함수 B는 다른 스레드나 커널이 대신 처리하게 됩니다.

#### 🧐 데이터의 결과값을 언제 받게 될까?

1. 결과를 확인할 수 있는 함수를 제공받아 주기적으로 해당 함수를 호출하여 결과값을 확인하는 방법입니다. 주기적으로 결과값을 확인해야하기 때문에 busy-waiting이 발생하며, 결국 CPU 낭비가 발생할 수 있게 됩니다. (무조건 나쁜 방법은 아닙니다!)
2. 데이터를 전달 받은 스레드에서 작업이 완료되면 호출자 스레드에게 알림을 보낼 수 있습니다.
3. 특정 함수를 호출할 때 매개변수로 콜백 함수를 인자로 넣어 데이터를 처리할 수 있습니다.

<br>

## 8. 높은 동시성과 고성능을 갖춘 서버






