# 프로그램이 실행되었지만 뭐가 뭔지 하나도 모르겟다

<br>

## 1. 운영 체제, 프로세스, 스레드의 근본 이해하기

#### 1-1. 모든 것은 CPU에서 시작된다

- CPU는 사실 스레드, 프로세스, 운영 체제와 같은 것들을 모르고 있습니다. CPU가 아는 것은 단 2가지 밖에 없습니다.
  - 메모리에서 명령어를 가져옵니다.
  - 가져온 명령어를 실행합니다.

🚗 과정

- CPU는 메모리에서 명령어를 가져와 실행하고, 다시 명령어를 가져와 실행하고 이 과정을 반복하게 됩니다. 그럼 CPU는 어떤 기준으로 명령어를 가져오게 되는걸까요?
- 그 답은 "프로그램 카운터(PC)"를 활용하여 CPU는 명령어를 가져오게 됩니다. 프로그램 카운터는 CPU가 다음에 실행해야할 명령어의 주소를 가리키고 있습니다. 그럼 가장 처음의 프로그램 카운터는 어떤걸까요? 바로 "실행 파일(object file)"에 그 답이 있습니다. 실행 파일에는 반드시 프로그램의 시작 지점이 있어야 하는데 그 지점이 바로 "main" 함수입니다. 
- 즉, 실행 파일이 메모리에 적재되어 실행되면 가장 먼저 main 함수가 실행되고, 여기서 프로그램 카운터가 처음으로 시작되며 이어서 다음 프로그램 카운터가 계속 진행되는 것입니다.

![스크린샷 2024-10-14 오후 11 36 57](https://github.com/user-attachments/assets/1fdc69ae-9772-464b-a5d9-6329e18dc2d6)

<br>

#### 1-2. CPU의 멀티 태스킹

- CPU의 자원은 한정적입니다. 그렇기 때문에 A 작업과 B 작업을 동시에 작업할 수 없습니다. 그래서 A 작업을 잠깐 하다가 멈추고, B 작업으로 넘어가 작업을 잠깐 하다가 멈추고, 다시 A 작업을 하고 .... 이 과정을 반복해야 한정적인 CPU의 자원을 효율적으로 사용할 수 있습니다.
그리고 A 작업으로 되돌아오거나, B 작업으로 되돌아갈때 특정 작업이 어디까지 했는지에 대한 정보를 어딘가에 보관해야 하는데, 그것을 문맥(context)이라 하고, 작업이 스레드에 한정된다면 TCB(Thread Control Block)에 저장되며, 프로세스라면 PCB(Process Control Block)에 저장됩니다.

#### 1-3. 프로세스의 주소 공간

- 프로세스의 정보(PCB)는 메모리내의 커널 영역에 저장됩니다.
- 프로세스가 메모리에 적재되면 아래와 같은 4개의 영역이 생성됩니다.
- <b>코드 영역</b>: CPU가 실행할 수 있는 명령어들이 저장되어 있습니다. 해당 영역은 읽기 전용입니다.
- <b>데이터 영역</b>: 프로그렘 전반에 사용되는 전역 변수들이 저장되어 있습니다.
- <b>힙 영역</b>: 여러 스레드들이 참조할 수 있는 영역이며, 동적 메모리 공간입니다.
- <b>스택 영역</b>: 함수 호출시 매개변수, 지역변수, 반환 주소등이 저장되어 있습니다. 각 스레드마다 생성되는 공간입니다.

#### 1-4. 스레드의 주소 공간

- 하나의 프로세스에서 코드 영역, 데이터 영역, 힙 영역을 공유하고, 각 스레드마다 스택 영역을 가집니다. 그렇기 때문에 프로세스를 생성해서 특정 작업을 실행시키는 것보다 스레드를 생성하여 특정 작업을 실행시키는게 더 효율적입니다. 그래서 스레드를 경량 프로세스라고도 부릅니다.
- 스택은 각 스레드마다 가지게 되며, 스택에는 함수의 매개변수, 지역변수, 반환 주소가 담겨있습니다.
- 스레드는 프로세스 내에서 실행되고, 스레드마다 아이디가 있으며, 프로그램 카운터를 비롯한 다양한 레지스터 값들이 있습니다. (TCB)

#### 1-5. 스레드 풀이란?

- 스레드를 사용자의 요청이 들어올때마다 생성하여, 작업을 실행시킨 뒤 작업을 완료하게되면 삭제하고 ... 이러한 과정을 반복하면 결국 메모리도 낭비하게 되고, 오버헤드도 증가하게 됩니다.
  1. 스레드의 생성과 종료에 많은 시간을 소요하게 됩니다. (오버헤드 증가)
  2. 스레드마다 각자의 메모리 공간을 소요하게 됩니다. (스택 영역)
  3. 스레드 수가 많으면 context-switch 비용 발생 (오버헤드 증가)

💡 그래서 스레드 풀!

- 스레드 풀의 개념은 간단합니다. 미리 스레드를 N개 생성하여 풀에 넣어놓고, 사용자의 요청이 들어올때마다 하나씩 할당해주는 것입니다. 그리고 작업이 끝나면 다시 풀로 반환시키면 됩니다.

#### 1-6. 적절한 스레드 풀의 수는?

- 스레드 풀에 스레드가 너무 많다면 오히려 context-switch 비용이 많이 발생하게 되고, 스레드 수가 적다면 CPU를 최대한 활용할 수 없게됩니다. 그래서 적절한 스레드의 수를 찾아야 합니다.

💡 CPU 버스트 Vs I/O 버스트

- 연산 작업이 많은 경우 CPU 버스트가 많은 작업들이고, 네트워크 접근, 데이터베이스 접근, 파일 접근 등이 많을 때는 I/O 버스트가 많은 작업들입니다. 따라서 애플리케이션이 어떤 작업들이 많은지 파악한 뒤에 적절한 테스트를 통해 스레드의 개수를 조정해야 합니다.

<br>

## 2. 스레드 간 공유되는 프로세스 리소스
















