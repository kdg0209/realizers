# 트랜지스터에서 CPU로 이보다 더 중요한 것은 없다

<br>

## 1. 이 작은 장난감을 CPU라고 부른다.

#### 트랜지스터의 발명

- 트랜지스터의 기능은 간단합니다. 단자 한쪽에 전류를 흘리면 나머지 단자 두개에 전류를 흐르게할 수도 있고, 흐르지 않게 할 수도 있습니다.
- 프로그래머가 작성한 코드가 아무리 복잡하더라도 소프트웨어가 수행되는 기능은 최종적으로 트랜지스터로 인해 작동됩니다.

#### 논리곱, 논리합, 논리부정

- 트랜지스터는 논리곱, 논리합, 논리부정 게이트로 모든 논리 함수를 표현할 수 있습니다. 그리고 이것을 논리적 완전성이라 합니다.
- 충분한 논리곱, 논리합, 논리부정 게이트가 있으면 어떤 논리 함수도 구현할 수 있습니다. 이외에는 어떤 형태의 논리 게이트 회로도 필요하지 않습니다.

<img width="1032" alt="스크린샷 2024-10-27 오후 2 34 32" src="https://github.com/user-attachments/assets/6cc87373-ee6b-4716-81cf-915cc74c01c8">

<br>

#### CPU의 연산 능력

- CPU에는 전문적으로 계산을 담당하는 곳이 있는데, 바로 ALU(산술 논리 장치)라고 불리는 장치가 있습니다.

🧐 1 + 2 연산이 어떻게 수행될까?

1. "데이터 레지스터"가 연산에 사용되는 데이터(1, 2)를 일시적으로 저장합니다.
2. "가산기"에 의해 데이터 레지스터에 저장된 값을 연산한 후 누산기에 저장하는 역할을 합니다.
3. "누산기"는 산술 및 논리 연산의 결과를 일시적으로 저장합니다.

#### CPU의 레지스터

- 레지스터는 CPU 내부에 있는 작고 빠른 메모리 공간입니다. 이 공간은 임시 메모리 공간이기 때문에 새로운 데이터가 전송되면 기존 데이터는 지워지고 새로운 데이터만 저장하게 됩니다. (초기화)

#### CPU와 명령어

- CPU는 어떻게 자신이 덧셈을 하는지, 뺄셈을 하는지 다른 기타 작업을 하는지 알 수 있을까요?
- 명령어는 연산 코드와 오퍼랜드로 구성되어 있습니다.
  - 연산 코드란 수행해야할 연산을 의미합니다.
  - 오퍼랜드란 연산에 사용될 데이터 또는 연산에 사용될 데이터가 저장되어 있는 주소를 의미합니다.
- [명령어의 구조 보기.](https://github.com/kdg0209/realizers/blob/main/self-learning-cs/3%EC%9E%A5%20%EB%AA%85%EB%A0%B9%EC%96%B4.md)

<img width="1032" alt="스크린샷 2024-10-27 오후 2 56 11" src="https://github.com/user-attachments/assets/6bbca1b5-ff88-4592-a927-1c8e439664e8">

<br>

#### 조금 더 구체적으로

- 아래 명령어는 16비트로 구성되어 있습니다. 이 명령어는 CPU에 덧셈을 수행하라고 지시하고 있으며(연산 코드), 나머지 비트에서 어떻게 작업해야 하는지 알려주고 있습니다.
- 레지스터 R6과 레지스터 R2 값을 더한 후 레지스터 R6에 기록합니다.

<img width="1032" alt="스크린샷 2024-10-27 오후 2 57 29" src="https://github.com/user-attachments/assets/9171da9e-c0a4-4bec-b567-a9bf367cc545">

<br><br>

## 2. CPU는 유휴 상태일 때 무엇을 할까?

#### 프로세스 관리와 스케줄링

- 프로그램이 메모리에 적재되면, 프로세스 형태로 존재하게 되고 이제 운영체제가 관리하고 CPU 자원을 할당하게 됩니다.

<img width="1032" alt="스크린샷 2024-10-27 오후 3 35 33" src="https://github.com/user-attachments/assets/bd791810-0f02-4152-8cae-7986517dc1fc">

<br>

#### System Idle Process

- 준비 완료 대기열이 비어있다면 이는 현재 운영체제가 스케줄링해야하는 프로세스가 없고 CPU가 유휴 상태에 있다는 것을 의미합니다.
- 만약 준비 완료 대기열이 비어있다면 특정 작업이 수행될 수 있도록 처리해야하는데, 커널 입장에서 아래와 같은 if문은 다소 번거러울 수 있습니다. 따라서 좋은 설계가 아닙니다. 차라리 계속 대기열을 가득 채워 스케줄러가 대기열에서 항상 실행할 수 있는 프로세스를 찾을 수 있도록 하는 것입니다. 따라서 우선 순위가 가장 낮은 "System Idle Process"가 등장하게 되었습니다.
- 즉, 스케줄링 가능한 프로세스가 더 이상 존재하지 않으면 스케줄러가 유휴 프로세스를 실행시키게 됩니다. (내부적으로 halt 명령어를 수행시킵니다.)

```java
if (queue.isEmpty()) {
    ... do something
}
```

<br>

## 3. CPU는 숫자를 어떻게 인식할까?

#### 부호 있는 정수

- 비트 k가 주어지면 정수 2k개를 표현할 수 있습니다. 즉 k가 4라면 정수 16개를 표현할 수 있는데, 부호 있는 정수(음수)를 표현하려면 정수 16개를 반으로 나눠 절반을 음수로 표현하면 됩니다. 이러한 방식에서는 최상위 비트가 정수 부호를 결정하며 이 값이 0이면 양수 그렇지 않으면 음수입니다.

#### 음수를 표현 하는 방법 1. sign magnitude

#### 음수를 표현 하는 방법 2. 1의 보수

#### 음수를 표현 하는 방법 3. 2의 보수

<br>

## 4. CPU가 if문을 만났을 떄

#### branch-misses

- 리눅스의 perf 도구를 사용해 분기 예측을 측정할 수 있습니다.
- 예측을 통해 미리 로드한 명령어가 예측과 달리 사용되지 않는 횟수를 나타냅니다. 높을수록 비효율적입니다.
- CPU는 명령어를 처리할 때 명령어 인출, 명령어 해독, 실행, 다시 쓰기 이렇게 네 단계로 구분할 수 있습니다. CPU는 if문을 만나면 분기 예측을 통해 실행됩니다.

#### 분기 예측

- CPU는 if문을 만나면 어디로 분기할 가능성이 있는지 추측합니다. 추측이 맞으면 분기문에 해당하는 작업으로 향하고, 그렇지 않다면 잘못된 분기 명령어를 전부 무효화합니다. 이때 CPU의 분기 예측 추측이 틀리면 명령어를 전부 무효화해야하기 때문에 성능 손실이 발생하게 됩니다.
- 분기 예측은 참조 지역성의 원리도 함께 사용되는게 아닐까? 생각이 듭니다.

<br>

## 5. CPU 코어수와 스레드 수 사이의 관계는 무엇일까?

- 다중 코어를 최대한 활용하기 위해서는 시스템에 코어가 몇개가 있는지 확인해야 합니다. 그리고 일반적으로 생성되는 스레드 수는 코어 수와 일정한 선형 관계를 유지해야 합니다.

#### 🤔 스레드 수가 많으면 항상 좋은가?

- 보통 스레드 수가 많으면 더 많은 작업을 처리할 수 있으니까 TPS가 높아지지 않을까? 라는 생각을 할 수 있습니다. 하지만 오히려 많은 스레드 수에 의해 ccontext switching 비용이 증가하게 되어 오히려 성능이 더 안좋아질 수 있습니다. 따라서 테스트를 통해 적절한 스레드 수를 찾아야 합니다.

<br>

## 6. CPU 진화론(상): 복잡 명령어 집합의 탄생

#### 명령어 집합

- 명령어 집합은 우리에게 CPU가 할 수 있는 작업을 알려줍니다. 예를들어 ADD 명령어를 사용하면 CPU는 덧셈 연산을 할 수 있다는 것입니다.
- 이 시기 대부분의 프로그램들은 어셈블리어로 작성되었기 때문에 일반적으로 명령어 집합들이 더 풍부했어야 합니다. ADD 명령어를 통해 덧셈은 할 수 있지만 "물을 갖다줘"와 같은 복잡한 명령어를 수행하기 위해서는 수 많은 명령어를 입력했어야 합니다. 그리고 명령어를 많이 입력한다는 것은 저장 공간 또한 많이 사용한다는 것이였습니다.

#### 마이크로코드의 등장과 문제점

- 저장 공간을 절약하고 복잡 명령어 집합을 사용하기 위해 마이크로코드가 등장하게 되었습니다. 하지만 마이크로코드에 버그가 발생하면 일반적인 프로그램의 버그를 수정하는 것보다 더 어려웠고 마이크로코드의 설계가 트랜지스터를 매우 많이 소모하고 있었습니다.

<br>

## 7. CPU 진화론(중): 축소 명령어 집합의 탄생

#### 축소 명령어 집합의 철학

- 축소 명령어 집합의 특징 중 하나는 복잡한 명령어를 제거하고 대신 간단한 명령어 여러개로 대처합니다. 이 사상으로 인해 마이크로코드를 사용하지 않게 됩니다.
- 컴파일러에게 더 많은 제어권은 넘깁니다.
- store/load 구조를 사용하게 되었습니다.

#### 곱셉 연산 명령어 수행 과정

1. 메모리 주소 A의 데이터를 읽어 레지스터에 저장합니다.
2. 메모리 주소 B의 데이터를 읽어 레지스터에 저장합니다.
3. ALU가 레지스터 값을 이용해 곱셈 연산을 수행합니다.
4. 곱셈 결과를 다시 메모리에 저장합니다.

#### 복잡 명령어의 예시

- 복잡 명령어 집합을 사용하면 하나의 명령어를 통해 위 4가지 과정을 진행되게 됩니다.

```text
MULT A B
```

#### 축소 명령어의 예시

- 축소 명령어 집합을 사용하면 명령어 4개를 사용해야 곱셈 연산을 할 수 있습니다.
- 축소 명령어를 사용하면 복잡 명령어 집합보다 더 많은 저장 공간을 사용해야 하지만 축소 명령어 집합의 의도는 개발자가 이러한 명령어를 하나하나 작성하는게 아니라 이 작업을 컴파일러에게 맡기는 것입니다.
- CPU는 이러한 코드를 해석하는데 많은 연산이 필요하지 않아 트랜지스터를 절약할 수 있으며, 절약한 트랜지스터는 CPU의 다른 기능에 활용할 수 있습니다.

```text
LOAD RA, A
LOAD RB, B
PROD RA, RB
STORE A, RA
```

<br>

## 8. CPU 진화론(하): 절체절명의 위기에서 반격

#### 복잡 명령어 집합의 변환

- 복잡 명령어 집합은 파이프라인 기술을 적용할 수 없으므로 CPU 내부에서 축소 명령어 집합의 간단한 명령어로 변환하게 됩니다. 이를 축소 명령어 집합과 유사한 마이크로 명령어라고 합니다.
- 축소 명령어 집합과 마찬가지로 마이크로 명령어 또한 매우 간단하며, 실행 시간도 거의 비슷하기 때문에 파이프라인 기술을 적용할 수 있었습니다.

#### 하이퍼 스레딩

- CPU는 한번에 하나의 스레드에 속한 명령어만 실행할 수 있었습니다. 하지만 하이퍼 스레딩이라는 기술을 이용하면 물리 CPU가 하나만 있지만 운영체제는 논리적으로 CPU가 여러개 있는거처럼 인식하게 됩니다. 따라서 하이퍼 스레딩 기술을 사용하면 CPU 코어가 동시에 스레드 두 개를 실행할 수 있게 됩니다.

![스크린샷 2024-11-01 오후 11 31 15](https://github.com/user-attachments/assets/c7dc0e16-0713-42e7-9102-ec540a86ad84)

<br>

## 9. CPU, 스택과 함수 호출, System call, 스레드 전환, 인터럽트 처리








