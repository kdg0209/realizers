# 트랜지스터에서 CPU로 이보다 더 중요한 것은 없다

<br>

## 1. 이 작은 장난감을 CPU라고 부른다.

#### 트랜지스터의 발명

- 트랜지스터의 기능은 간단합니다. 단자 한쪽에 전류를 흘리면 나머지 단자 두개에 전류를 흐르게할 수도 있고, 흐르지 않게 할 수도 있습니다.
- 프로그래머가 작성한 코드가 아무리 복잡하더라도 소프트웨어가 수행되는 기능은 최종적으로 트랜지스터로 인해 작동됩니다.

#### 논리곱, 논리합, 논리부정

- 트랜지스터는 논리곱, 논리합, 논리부정 게이트로 모든 논리 함수를 표현할 수 있습니다. 그리고 이것을 논리적 완전성이라 합니다.
- 충분한 논리곱, 논리합, 논리부정 게이트가 있으면 어떤 논리 함수도 구현할 수 있습니다. 이외에는 어떤 형태의 논리 게이트 회로도 필요하지 않습니다.

<img width="1032" alt="스크린샷 2024-10-27 오후 2 34 32" src="https://github.com/user-attachments/assets/6cc87373-ee6b-4716-81cf-915cc74c01c8">

<br>

#### CPU의 연산 능력

- CPU에는 전문적으로 계산을 담당하는 곳이 있는데, 바로 ALU(산술 논리 장치)라고 불리는 장치가 있습니다.

🧐 1 + 2 연산이 어떻게 수행될까?

1. "데이터 레지스터"가 연산에 사용되는 데이터(1, 2)를 일시적으로 저장합니다.
2. "가산기"에 의해 데이터 레지스터에 저장된 값을 연산한 후 누산기에 저장하는 역할을 합니다.
3. "누산기"는 산술 및 논리 연산의 결과를 일시적으로 저장합니다.

#### CPU의 레지스터

- 레지스터는 CPU 내부에 있는 작고 빠른 메모리 공간입니다. 이 공간은 임시 메모리 공간이기 때문에 새로운 데이터가 전송되면 기존 데이터는 지워지고 새로운 데이터만 저장하게 됩니다. (초기화)

#### CPU와 명령어

- CPU는 어떻게 자신이 덧셈을 하는지, 뺄셈을 하는지 다른 기타 작업을 하는지 알 수 있을까요?
- 명령어는 연산 코드와 오퍼랜드로 구성되어 있습니다.
  - 연산 코드란 수행해야할 연산을 의미합니다.
  - 오퍼랜드란 연산에 사용될 데이터 또는 연산에 사용될 데이터가 저장되어 있는 주소를 의미합니다.
- [명령어의 구조 보기.](https://github.com/kdg0209/realizers/blob/main/self-learning-cs/3%EC%9E%A5%20%EB%AA%85%EB%A0%B9%EC%96%B4.md)

<img width="1032" alt="스크린샷 2024-10-27 오후 2 56 11" src="https://github.com/user-attachments/assets/6bbca1b5-ff88-4592-a927-1c8e439664e8">

<br>

#### 조금 더 구체적으로

- 아래 명령어는 16비트로 구성되어 있습니다. 이 명령어는 CPU에 덧셈을 수행하라고 지시하고 있으며(연산 코드), 나머지 비트에서 어떻게 작업해야 하는지 알려주고 있습니다.
- 레지스터 R6과 레지스터 R2 값을 더한 후 레지스터 R6에 기록합니다.

<img width="1032" alt="스크린샷 2024-10-27 오후 2 57 29" src="https://github.com/user-attachments/assets/9171da9e-c0a4-4bec-b567-a9bf367cc545">

<br><br>

## 2. CPU는 유휴 상태일 때 무엇을 할까?

#### 프로세스 관리와 스케줄링

- 프로그램이 메모리에 적재되면, 프로세스 형태로 존재하게 되고 이제 운영체제가 관리하고 CPU 자원을 할당하게 됩니다.

<img width="1032" alt="스크린샷 2024-10-27 오후 3 35 33" src="https://github.com/user-attachments/assets/bd791810-0f02-4152-8cae-7986517dc1fc">

<br>

#### System Idle Process

- 준비 완료 대기열이 비어있다면 이는 현재 운영체제가 스케줄링해야하는 프로세스가 없고 CPU가 유휴 상태에 있다는 것을 의미합니다.
- 만약 준비 완료 대기열이 비어있다면 특정 작업이 수행될 수 있도록 처리해야하는데, 커널 입장에서 아래와 같은 if문은 다소 번거러울 수 있습니다. 따라서 좋은 설계가 아닙니다. 차라리 계속 대기열을 가득 채워 스케줄러가 대기열에서 항상 실행할 수 있는 프로세스를 찾을 수 있도록 하는 것입니다. 따라서 우선 순위가 가장 낮은 "System Idle Process"가 등장하게 되었습니다.
- 즉, 스케줄링 가능한 프로세스가 더 이상 존재하지 않으면 스케줄러가 유휴 프로세스를 실행시키게 됩니다. (내부적으로 halt 명령어를 수행시킵니다.)

```java
if (queue.isEmpty()) {
    ... do something
}
```

<br>

## 3. CPU는 숫자를 어떻게 인식할까?

#### 부호 있는 정수

- 비트 k가 주어지면 정수 2k개를 표현할 수 있습니다. 즉 k가 4라면 정수 16개를 표현할 수 있는데, 부호 있는 정수(음수)를 표현하려면 정수 16개를 반으로 나눠 절반을 음수로 표현하면 됩니다. 이러한 방식에서는 최상위 비트가 정수 부호를 결정하며 이 값이 0이면 양수 그렇지 않으면 음수입니다.

#### 음수를 표현 하는 방법 1. sign magnitude

#### 음수를 표현 하는 방법 2. 1의 보수

#### 음수를 표현 하는 방법 3. 2의 보수

<br>

## 4. CPU가 if문을 만났을 떄

#### branch-misses

- 리눅스의 perf 도구를 사용해 분기 예측을 측정할 수 있습니다.
- 예측을 통해 미리 로드한 명령어가 예측과 달리 사용되지 않는 횟수를 나타냅니다. 높을수록 비효율적입니다.
- CPU는 명령어를 처리할 때 명령어 인출, 명령어 해독, 실행, 다시 쓰기 이렇게 네 단계로 구분할 수 있습니다. CPU는 if문을 만나면 분기 예측을 통해 실행됩니다.

#### 분기 예측

- CPU는 if문을 만나면 어디로 분기할 가능성이 있는지 추측합니다. 추측이 맞으면 분기문에 해당하는 작업으로 향하고, 그렇지 않다면 잘못된 분기 명령어를 전부 무효화합니다. 이때 CPU의 분기 예측 추측이 틀리면 명령어를 전부 무효화해야하기 때문에 성능 손실이 발생하게 됩니다.
- 분기 예측은 참조 지역성의 원리도 함께 사용되는게 아닐까? 생각이 듭니다.

<br>

## 5. CPU 코어수와 스레드 수 사이의 관계는 무엇일까?

- 다중 코어를 최대한 활용하기 위해서는 시스템에 코어가 몇개가 있는지 확인해야 합니다. 그리고 일반적으로 생성되는 스레드 수는 코어 수와 일정한 선형 관계를 유지해야 합니다.

#### 🤔 스레드 수가 많으면 항상 좋은가?

- 보통 스레드 수가 많으면 더 많은 작업을 처리할 수 있으니까 TPS가 높아지지 않을까? 라는 생각을 할 수 있습니다. 하지만 오히려 많은 스레드 수에 의해 ccontext switching 비용이 증가하게 되어 오히려 성능이 더 안좋아질 수 있습니다. 따라서 테스트를 통해 적절한 스레드 수를 찾아야 합니다.

<br>

## 6. CPU 진화론(상): 복잡 명령어 집합의 탄생

#### 명령어 집합

- 명령어 집합은 우리에게 CPU가 할 수 있는 작업을 알려줍니다. 예를들어 ADD 명령어를 사용하면 CPU는 덧셈 연산을 할 수 있다는 것입니다.
- 이 시기 대부분의 프로그램들은 어셈블리어로 작성되었기 때문에 일반적으로 명령어 집합들이 더 풍부했어야 합니다. ADD 명령어를 통해 덧셈은 할 수 있지만 "물을 갖다줘"와 같은 복잡한 명령어를 수행하기 위해서는 수 많은 명령어를 입력했어야 합니다. 그리고 명령어를 많이 입력한다는 것은 저장 공간 또한 많이 사용한다는 것이였습니다.

#### 마이크로코드의 등장과 문제점

- 저장 공간을 절약하고 복잡 명령어 집합을 사용하기 위해 마이크로코드가 등장하게 되었습니다. 하지만 마이크로코드에 버그가 발생하면 일반적인 프로그램의 버그를 수정하는 것보다 더 어려웠고 마이크로코드의 설계가 트랜지스터를 매우 많이 소모하고 있었습니다.

<br>

## 7. CPU 진화론(중): 축소 명령어 집합의 탄생

#### 축소 명령어 집합의 철학

- 축소 명령어 집합의 특징 중 하나는 복잡한 명령어를 제거하고 대신 간단한 명령어 여러개로 대처합니다. 이 사상으로 인해 마이크로코드를 사용하지 않게 됩니다.
- 컴파일러에게 더 많은 제어권은 넘깁니다.
- store/load 구조를 사용하게 되었습니다.

#### 곱셉 연산 명령어 수행 과정

1. 메모리 주소 A의 데이터를 읽어 레지스터에 저장합니다.
2. 메모리 주소 B의 데이터를 읽어 레지스터에 저장합니다.
3. ALU가 레지스터 값을 이용해 곱셈 연산을 수행합니다.
4. 곱셈 결과를 다시 메모리에 저장합니다.

#### 복잡 명령어의 예시

- 복잡 명령어 집합을 사용하면 하나의 명령어를 통해 위 4가지 과정을 진행되게 됩니다.

```text
MULT A B
```

#### 축소 명령어의 예시

- 축소 명령어 집합을 사용하면 명령어 4개를 사용해야 곱셈 연산을 할 수 있습니다.
- 축소 명령어를 사용하면 복잡 명령어 집합보다 더 많은 저장 공간을 사용해야 하지만 축소 명령어 집합의 의도는 개발자가 이러한 명령어를 하나하나 작성하는게 아니라 이 작업을 컴파일러에게 맡기는 것입니다.
- CPU는 이러한 코드를 해석하는데 많은 연산이 필요하지 않아 트랜지스터를 절약할 수 있으며, 절약한 트랜지스터는 CPU의 다른 기능에 활용할 수 있습니다.

```text
LOAD RA, A
LOAD RB, B
PROD RA, RB
STORE A, RA
```

<br>

## 8. CPU 진화론(하): 절체절명의 위기에서 반격

#### 복잡 명령어 집합의 변환

- 복잡 명령어 집합은 파이프라인 기술을 적용할 수 없으므로 CPU 내부에서 축소 명령어 집합의 간단한 명령어로 변환하게 됩니다. 이를 축소 명령어 집합과 유사한 마이크로 명령어라고 합니다.
- 축소 명령어 집합과 마찬가지로 마이크로 명령어 또한 매우 간단하며, 실행 시간도 거의 비슷하기 때문에 파이프라인 기술을 적용할 수 있었ㅌ습니다.

#### 하이퍼 스레딩

- CPU는 한번에 하나의 스레드에 속한 명령어만 실행할 수 있었습니다. 하지만 하이퍼 스레딩이라는 기술을 이용하면 물리 CPU가 하나만 있지만 운영체제는 논리적으로 CPU가 여러개 있는거처럼 인식하게 됩니다. 따라서 하이퍼 스레딩 기술을 사용하면 CPU 코어가 동시에 스레드 두 개를 실행할 수 있게 됩니다.

![스크린샷 2024-11-01 오후 11 31 15](https://github.com/user-attachments/assets/c7dc0e16-0713-42e7-9102-ec540a86ad84)

<br>

## 9. CPU, 스택과 함수 호출, System call, 스레드 전환, 인터럽트 처리

#### 레지스터

- CPU에 레지스터가 필요한 이유는 바로 "속도" 때문입니다. CPU가 레지스터에 접근하는 속도는 메모리에 접근하는 속도의 대략 100분의 1이므로 CPU가 레지스터 없이 메모리에만 의존한다면 속도가 많이 느려지게 됩니다.
- 사실 레지스터와 메모리는 본질적인 차이가 없으며, 둘 다 정보를 저장하는데 사용됩니다. 단지 레지스터가 읽고 쓰는데 속도가 더 빠릅니다. 하지만 레지스터는 비싸기 때문에 한계가 있으며, 어쩔 수 없이 프로세스의 실행 시 정보를 모두 메모리에 저장하고 CPU가 사용할 때만 임시로 레지스터에 데이터를 보관하는 것입니다.

#### 스택 포인터

- 실행되는 모든 함수는 스택 포인터를 가집니다.
- 함수가 실행될 때 함수에 정의된 매개변수, 지역변수 등을 저장하는 독립적인 메모리 공간이 있는데, 이 공간을 스택 프레임이라 부릅니다. 함수 호출의 단계가 깊어질 수록 스택 프레임의 수도 증가되며, 함수 호출이 완료되면 반대로 스택 프레임의 수도 줄어들게 됩니다.

#### 명령어 주소 레지스터

- 명령어 주소 레지스터는 보통 프로그램 카운터(PC)라고 불립니다. 이 "프로그램 카운터"는 CPU가 다음에 실행해야할 명령어의 주소를 담고 있습니다.
- 프로그램이 실행되면 보통 main 함수가 실행되고, 그 다음에는 어떤 함수가 호출되어야 할지는 main 함수 실행 후 프로그램 카운터 값이 순차적으로 증가되어 다음 함수가 호출되곤 합니다.
- 프로그램 카운터의 값은 순차적으로 증가되지만 if문, 함수 호출 등과 같은 제어문이 등장하면 새로운 명령어 주소를 프로그램 카운터에 저장하게 됩니다.

#### 상태 레지스터

- x86 시스템에서는 flag 레지스터라고도 하며, ARM 시스템에서는 상태 레지스터라고 부릅니다.
- 상태 레지스터에는 산술 연산에서의 자리 올림수나 넘침(overflow)이 발생할 수 있는데, 이러한 정보를 상태 레지스터에 저장합니다.
- 또한 CPU가 사용자 상태인지 커널 상태인지에 대한 정보도 상태 레지스터에 저장됩니다.

#### 상황 정보

- 함수 호출로 인한 제어권 전환, 스레드 전환, system call, 인터럽트 전환 시 스레드의 실행 시 정보들은 커널 영역에 저장되며, 스레드가 다시 작업을 할 때 실행 시 정보들을 다시 불러와 작업을 이어나가게 됩니다.

#### system call

- 운영체제가 디스크에 파일을 읽고 쓰거나 새로운 스레드를 생성할 때 응용 프로그램은 system call을 통해 운영체제에게 해당 작업을 요청하게 됩니다.
- 사용자 스레드가 운영체제의 서비스를 요청해야 하는 경우 system call을 호출해야 합니다. 이때 system call은 특정 명령어에 대응하며 32비트 x86 시스템에서는 INT 명령어가 이에 해당합니다.
- CPU가 해당 명령어를 실행할 때 사용자 상태에서 커널 상태로 전환되며, 커널 상태에서 사용자 스레드와 대응되는 커널 상태 스택을 찾은 후 여기에서 대응하는 커널 코드를 수행하여 system call 요청을 처리하게 됩니다.

#### 인터럽트와 인터럽트 함수 스택

- 인터럽트가 발생하면 CPU는 사용자 상태에서 커널 상태로 전환되며, 사용자 상태 스레드에 대응되는 커널 상태 스택을 찾아 커널 스택 상태에 사용자 상태 스레드의 실행 상황 정보를 저장합니다. 이후 CPU는 인터럽트 처리 함수의 주소로 점프하게되고, 인터럽트 처리 함수가 실행되는 동안 커널 상태 스택은 사용자 상태 실행 시간 스택과 마찬가지로 함수의 호출과 반환에 따라 그 크기가 증가하거나 줄어듭니다.
- 인터럽트 처리 함수의 실행이 완료되면 커널 상태 스택에 저장된 상항 정보에 따라 CPU 상태가 복원되며, 커널 상태에서 사용자 상태로 전환되어 작업을 계속 이어나가게 됩니다.


