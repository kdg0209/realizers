# 트랜지스터에서 CPU로 이보다 더 중요한 것은 없다

<br>

## 1. 이 작은 장난감을 CPU라고 부른다.

#### 트랜지스터의 발명

- 트랜지스터의 기능은 간단합니다. 단자 한쪽에 전류를 흘리면 나머지 단자 두개에 전류를 흐르게할 수도 있고, 흐르지 않게 할 수도 있습니다.
- 프로그래머가 작성한 코드가 아무리 복잡하더라도 소프트웨어가 수행되는 기능은 최종적으로 트랜지스터로 인해 작동됩니다.

#### 논리곱, 논리합, 논리부정

- 트랜지스터는 논리곱, 논리합, 논리부정 게이트로 모든 논리 함수를 표현할 수 있습니다. 그리고 이것을 논리적 완전성이라 합니다.
- 충분한 논리곱, 논리합, 논리부정 게이트가 있으면 어떤 논리 함수도 구현할 수 있습니다. 이외에는 어떤 형태의 논리 게이트 회로도 필요하지 않습니다.

<img width="1032" alt="스크린샷 2024-10-27 오후 2 34 32" src="https://github.com/user-attachments/assets/6cc87373-ee6b-4716-81cf-915cc74c01c8">

<br>

#### CPU의 연산 능력

- CPU에는 전문적으로 계산을 담당하는 곳이 있는데, 바로 ALU(산술 논리 장치)라고 불리는 장치가 있습니다.

🧐 1 + 2 연산이 어떻게 수행될까?

1. "데이터 레지스터"가 연산에 사용되는 데이터(1, 2)를 일시적으로 저장합니다.
2. "가산기"에 의해 데이터 레지스터에 저장된 값을 연산한 후 누산기에 저장하는 역할을 합니다.
3. "누산기"는 산술 및 논리 연산의 결과를 일시적으로 저장합니다.

#### CPU의 레지스터

- 레지스터는 CPU 내부에 있는 작고 빠른 메모리 공간입니다. 이 공간은 임시 메모리 공간이기 때문에 새로운 데이터가 전송되면 기존 데이터는 지워지고 새로운 데이터만 저장하게 됩니다. (초기화)

#### CPU와 명령어

- CPU는 어떻게 자신이 덧셈을 하는지, 뺄셈을 하는지 다른 기타 작업을 하는지 알 수 있을까요?
- 명령어는 연산 코드와 오퍼랜드로 구성되어 있습니다.
  - 연산 코드란 수행해야할 연산을 의미합니다.
  - 오퍼랜드란 연산에 사용될 데이터 또는 연산에 사용될 데이터가 저장되어 있는 주소를 의미합니다.
- [명령어의 구조 보기.](https://github.com/kdg0209/realizers/blob/main/self-learning-cs/3%EC%9E%A5%20%EB%AA%85%EB%A0%B9%EC%96%B4.md)

<img width="1032" alt="스크린샷 2024-10-27 오후 2 56 11" src="https://github.com/user-attachments/assets/6bbca1b5-ff88-4592-a927-1c8e439664e8">

<br>

#### 조금 더 구체적으로

- 아래 명령어는 16비트로 구성되어 있습니다. 이 명령어는 CPU에 덧셈을 수행하라고 지시하고 있으며(연산 코드), 나머지 비트에서 어떻게 작업해야 하는지 알려주고 있습니다.
- 레지스터 R6과 레지스터 R2 값을 더한 후 레지스터 R6에 기록합니다.

<img width="1032" alt="스크린샷 2024-10-27 오후 2 57 29" src="https://github.com/user-attachments/assets/9171da9e-c0a4-4bec-b567-a9bf367cc545">

<br><br>

## 2. CPU는 유휴 상태일 때 무엇을 할까?

#### 프로세스 관리와 스케줄링

- 프로그램이 메모리에 적재되면, 프로세스 형태로 존재하게 되고 이제 운영체제가 관리하고 CPU 자원을 할당하게 됩니다.

<img width="1032" alt="스크린샷 2024-10-27 오후 3 35 33" src="https://github.com/user-attachments/assets/bd791810-0f02-4152-8cae-7986517dc1fc">

<br>

#### System Idle Process

- 준비 완료 대기열이 비어있다면 이는 현재 운영체제가 스케줄링해야하는 프로세스가 없고 CPU가 유휴 상태에 있다는 것을 의미합니다.
- 만약 준비 완료 대기열이 비어있다면 특정 작업이 수행될 수 있도록 처리해야하는데, 커널 입장에서 아래와 같은 if문은 다소 번거러울 수 있습니다. 따라서 좋은 설계가 아닙니다. 차라리 계속 대기열을 가득 채워 스케줄러가 대기열에서 항상 실행할 수 있는 프로세스를 찾을 수 있도록 하는 것입니다. 따라서 우선 순위가 가장 낮은 "System Idle Process"가 등장하게 되었습니다.
- 즉, 스케줄링 가능한 프로세스가 더 이상 존재하지 않으면 스케줄러가 유휴 프로세스를 실행시키게 됩니다. (내부적으로 halt 명령어를 수행시킵니다.)

```java
if (queue.isEmpty()) {
    ... do something
}
```

<br>

## 3. CPU는 숫자를 어떻게 인식할까?














