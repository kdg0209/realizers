# 프로그래밍 언어부터 프로그램 실행까지, 이렇게 진행된다.

- 프로그래머가 작성한 소스코드가 어떻게 실행이 되는지에 대한 과정을 전반적으로 설명합니다.

<br>

## 1. 여러분이 프로그래밍 언어를 발명한다면?

#### 1-1. 창세기: CPU는 똑똑한 바보

- CPU는 데이터를 한 곳에서 다른 곳으로 옮기고, 연산한 후 다시 그 데이터를 또 다른 자리로 옮기는 작업외에는 다른 것을 할 줄 모릅니다. 간단한 작업처럼 보일 수 있는데, CPU의 엄청난 장점은 이러한 간단한 작업이 엄청 빠르다는 것입니다. 이 빠른 속도는 CPU의 멍청함을 상쇄하고도 남으며, 인간은 절대 CPU를 따라잡을 수 없습니다.
- 이 시기에는 프로그래머가 CPU에게 작업을 시키기기 위해 천공 카드를 사용하였습니다.

#### 1-2. 어셈블리어의 등장

- 천공 카드를 사용하여 작업을 하는데 시간도 많이들고, 많은 고생을 하게되어 어셈블리어가 등장하게 되었습니다.
- 어셈블리어의 등장으로 인해 기계어와 해당 특정 작업을 간단하게 대응시켜 기계어를 인간이 읽고 이해할 수 있는 단어와 대응시켰습니다.

#### 1-3. 저수준 계층의 세부 사항 Vs 고수준 계층의 추상화

- 어셈블리어에는 인간이 인식할 수 있는 명령어가 포함되었지만 여전히 저수준의 언어였습니다. 즉, 구체적으로 어떠한 작업을 시키기위해서는 프로그래머가 세부 사항에 대해 신경을 써야했습니다. (정렬, 합계)
- 아래 예시처럼 사람은 "저에게 물 한 잔 주세요"와 같이 질문을 한다면 CPU가 이를 이해할 수 있도록 이 과정에 대한 것을 하나하나 상세히 설명해줘야 했습니다.

<img width="1032" alt="스크린샷 2024-10-13 오후 3 13 05" src="https://github.com/user-attachments/assets/504a670d-f1b1-44ad-8343-2958c967b55e">

<br>

#### 1-4. 가득한 규칙: 고급 프로그래밍 언어의 시작

- 세부 사항이 규칙 또는 패턴으로 가득하다는 것을 발견합니다.
- 명령어 중에는 구체적으로 특정 행동을 한다는 것 외에도 특정 상황에 따라 어떤 명령어를 실행해야할지 결정해야 하는 선택이 필요하다는 것도 발견하게 되었습니다.
- 여러 시도를 거쳐 구문을 만들고, 컴퓨터가 이를 이해하도록 프로그래밍 언어를 컴퓨터가 인식할 수 있는 기계 명령어로 변환하는 컴파일러도 등장하게 됩니다.

<img width="1032" alt="스크린샷 2024-10-13 오후 3 34 24" src="https://github.com/user-attachments/assets/df56207e-fe4f-4f91-8df7-ce990104990a">

<br>

#### 1-5. 컴파일러의 탄생

- 인간의 언어로 작성된 소스 코드를 컴퓨터가 이해할 수 있도록 변환해주는 컴파일러가 등장하게 되었습니다.
- 하지만 세상에는 각양각색의 다양한 CPU가 있는데 A 형식의 CPU에서 생성된 기계 명령어를 B 형식의 CPU에서는 실행할 방법이 없었습니다.
- 마치 x86 플랫폼으로 생성한 실행 파일을 ARM 플랫폼에서 직접 실행할 수 없는 것과 같습니다. 프로그래머가 작성한 코드가 가능한 많은 플랫폼에서 실행되길 원하지만 재컴파일하고 다시 작업을 진행했어야 합니다.
- 이를 해결하기 위해 가상 머신(Virtual Machine)이 등장하거나 인터프리터가 등장하게 되었습니다.

<img width="1032" alt="스크린샷 2024-10-13 오후 3 56 18" src="https://github.com/user-attachments/assets/b0154862-8195-43ae-a4c0-358c5b5c18b0">

<br><br>

## 2. 컴파일러는 어떻게 작동하는 것일까?

#### 2-1. 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다

- 컴파일언어는 고수준 언어를 저수준 언어로 변환하는 프로그램입니다.
- 프로그래머가 코드를 작성하면 텍스트 형태의 파일로 저장되는데, 이를 소스 파일(source file)이라 합니다. 이 소스 파일을 컴파일러에게 전달하면 컴파일러는 CPU가 이해할 수 있도록 변환해주며, 실행 파일(exe file)을 만들어 줍니다. 이 과정에서 중간에 생략된 것 과정들이 있으며 Linker의 과정은 조금 뒤에 세부적으로 알아보겠습니다.

#### 2-2. 각각의 토큰 추출

- 아래 간단한 소스 코드가 있으면 컴파일러는 먼저 각 항목을 잘게 쪼갭니다. 이때 각 항목이 가지고 있는 추가 정보를 함께 묶어서 관리하게 됩니다.
- T_Keyword int 처럼 각 항목의 정보를 결합한 것을 토큰이라 합니다. 이렇게 소스코드에서 토큰을 추출하는 과정을 "어휘 분석"이라고합니다. 그 뒤에 문법 적인 오류가 없는지 확인하는 과정을 거치게 됩니다. 이 과정을 "구문 분석"이라 합니다. 그 뒤에 구문에 이상이 없는지 확인을 하며 이 과정을 "의미 분석"이라 합니다.

```java
int a = 1;
int b = 2;
  
while (a < b) {
  b = b - 1;
}

// 토큰 추출
T_Keyword    int
T_Identifier a
T_Assign     =
T_Int        1
T_Semicolon  ;
T_Keyword    int
T_Identifier b
T_Assign     =
T_Int        2
T_Semicolon  ;
T_While      while
...
(각 행이 하나의 토큰을 의미)
```

#### 💡 컴파일러의 과정

- 소스 코드 > 어휘 분석 > 구문 분석 > 의미 분석

<br>

## 3. 링커의 말할 수 없는 비밀

- source code는 compiler에 의해 object file로 변환됩니다. 그리고 object file은 exe file이 되어야 하는데, 사실 object file에서 exe file로 변환해주는 작업은 compiler가 아닌 linker에 의해 수행되며 이 작업을 link라고 합니다.

#### 🚗 과정

- source code -> compiler -> object file -> linker -> link -> exe file -> loader -> load -> memory 적재 -> 살행
- 즉, 개발자가 작성한 소스코드가 컴파일러에 의해 오브젝트 파일이 생성되며, 링커에 의해 링크되면서 실행파일이 만들어지며, 로더에 의해 로드되며 메모리에 적재되고 실행됩니다.

#### 3-1. 링커는 이렇게 일한다.

- 링커는 압출 프로그램이 파일 여러개를 하나의 압출 파일로 묶어주는 것처럼, 컴파일러가 생성한 여러 오브젝트 파일을 하나로 묶어 실행 파일로 만드는 역할을 수행합니다.
- 소스 코드에서 외부 모듈을 참조하거나 변수를 참조하고 있을 때 링커는 외부 모듈에 대한 의존성이 올바르게 설정되었는지, 사용 가능한지 확인합니다. 이 과정을 "심벌 해석"이라 하고, 이 과정에서 오류가 없으면 "실행 파일"이 생성됩니다. 그리고 마지막으로 동적 라이브러리로 참조된 곳에 "재배치"가 이루어지게 됩니다.
- 링커는 심벌 해석 -> 실행 파일 -> 재배치 과정이 세부적으로 발생하게 됩니다.

#### 3-2. 심벌 해석이란?

- 심벌이란 전역 변수와 함수의 이름을 포함하는 모든 변수를 의미합니다. 지역 변수는 특정 지역에 국한되어 사용되기 때문에 외부 모듈에서 참조할 일이 없어 링커의 대상이 아닙니다. 즉 링커는 "외부에서 참조할 수 있는 변수"나 "사용 중인 외부 참조 변수"에만 관심을 가집니다.
- 링커는 전역 변수에만 관심을 가지며, 전역 변수가 외부 모듈에서 참조하여 사용하고 있다는 것은 컴파일러가 링커에게 알려줍니다.

<br>

🧐 컴파일러는 링커에게 어떻게 전역 변수에 대한 정보를 알려줄 수 있을까?

- 답은 메모리 영역에 있으며, 그 중에서 "데이터 영역"을 링커는 참고하게 됩니다.
- 코드 영역
  - 코드 영역은 텍스트 영역이라고도 부르며, CPU가 실행할 수 있는 명령어들이 저장되어 있고, 데이터는 저장되어 있지 않습니다. 그리고 해당 영역은 읽기 전용입니다.
- 데이터 영역
  - 데이터 영역은 프로그램 실행 전반에 사용되는 전역 변수가 저장되어 있습니다.

<br>

💡 심벌 테이블이란?

- 심벌 테이블이란 컴파일러가 소스 코드를 읽으면서 소스 코드마다 외부에서 참조 가능한 심벌이 어떤 것이 있는지, 반대로 어떤 외부 심벌을 참조하고 있는지 기록해주는 표를 "심벌 테이블" 이라 합니다.
  1. 현재 소스 코드에서 외부에서 참조할 수 있는 심벌
  2. 현재 소스 코드에서 사용중인 외부 심벌

<img width="1032" alt="스크린샷 2024-10-13 오후 5 04 07" src="https://github.com/user-attachments/assets/970cfa55-541d-4c1c-a13f-81151056590f">

<br>

#### 3-3. 정적 라이브러리, 동적 라이브러리, 실행 파일

정적 라이브러리란?

- 실행 파일을 생성할 때 사용할 다른 외부 라이브러리도 함께 컴파일하여 실행 파일을 생성하는 것입니다. 외부 라이브러리와 함께 실행 파일로 묶어져서 외부 라이브러리를 사용할 때 속도는 빠르지만 외부 라이브러리의 코드가 포함되어 있으므로 실행 파일이 커질 수 있으며, 디스크 낭비로 이어집니다.

동적 라이브러리란?

- 동적 라이브러리는 공유 라이브러리 또는 동적 링크 라이브러리라고도 하며, 참조된 동적 라이브러리는 이름, 심벌 테이블, 재배치 정보 등 필수 정보만 실행 파일에 포함됩니다. 이러한 필수 정보는 동적 링크가 일어날 때 사용되게 됩니다. 즉 동적 라이브러리는 의존하는 실행 파일에는 컴파일 단계에서 필수적인 정보만 저장되고 실제 사용될 때 참조를 하게 됩니다.

#### 3-4. 동적 라이브러리의 장단점

장점

- 메모리와 디스크를 절약할 수 있습니다.
- 동적 라이브러리 수정 시 동적 라이브러리만 재컴파일 하면 됩니다.
- 플러그인(plug-in)을 구현하는 방식 중 하나입니다.
- 성능을 위해 프로그램의 특정 부분을 다른 언어로 개발하고 동적 라이브러리 형태로 사용할 수 있습니다.

단점

- 적재/실행 시간에 링크되기 때문에 성능이 떨어질 수 있습니다.
- 해당 동적 라이브러리를 여러 프로세스가 공유해서 사용되기 때문에 임의의 메모리 주소를 참조할 수 없습니다.

#### 3-5. 재배치

- 링커가 실행 파일을 생성할 때 프로그램이 실행되는 시점에 함수가 적재될 메모리 주소를 확정해야 합니다.
- 외부 심벌처럼 특정 메모리 주소값을 확정할 수 없는 변수에 대해 임의적인 주소값(0x00)을 할당한 뒤에 컴파일러는 .relo.txt와 .relo.data에 기록해둡니다. 그리고 Linker가 object file을 만들 때 컴파일러가 기록한 내용을 참고하여 그때 외부 심벌에 대한 메모리 주소를 수정하게 됩니다.

<br>

## 4. 컴퓨터 과학에서 추상화가 중요한 이유
























