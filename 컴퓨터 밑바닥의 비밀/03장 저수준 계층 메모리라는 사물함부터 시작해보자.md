# 저수준 계층 메모리라는 사물함부터 시작해보자

<br>

## 1. 변수의 의미

#### 예시

- 아래 예시를 보면 값 1을 메모리 주소 6에 저장하는 것인지, 메모리 주소 1에 값 6을 저장하는 것인지 명확하지 않습니다.

```text
store 1 6
# 값 1을 메모리 주소 6에 저장하라는 의미입니다.
```

#### 변수의 탄생

- 아래 예시는 변수 a에 1이라는 값이 할당되어 있습니다.
- 변수 a에 특정 값이 할당되어있는 단순한 예시이지만 사실 중요한게 숨겨져 있습니다. 바로 변수 a가 나타내는 숫자 1이 특정 메모리 주소에 저장되어 있다는 것입니다. 변수를 사용함으로써 우리는 이 값이 메모리에 적재되었겠구나 생각하며 구체적으로 어느 위치에 적재되는지 알 필요가 없게 되는 것입니다.
- 주소라는 개념은 변수로 추상화되어 있기 때문에 a가 어디에 적재되는지 신경쓸 필요없이 이런 변수가 존재한다라는 것만 알고있으면 됩니다.

```text
a = 1
```

<br>

## 2. 프로세스는 메모리안에서 어떤 모습을 하고 있을까?

#### 64비트 시스템에서의 메모리 레이아웃

- 메모리의 모든 프로세스는 아래 그림처럼 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 구성되어 있습니다.
- 가장 흥미로운 점은 모든 프로세스의 코드 영역이 0x400000에서 시작하며, 서로 다른 프로세스를 메모리에 적재할 때 malloc system call을 호출하면 동일한 시작 주소를 반환할 가능성이 매우 높습니다. 근데 서로 다른 프로세스가 동일한 메모리 주소를 가진다는게 말이 안됩니다. 어떻게 된 걸까요?

#### 🤔 어떻게 동일한 메모리 주소를 가질 수 있는걸까?

- 사실 이는 가짜 주소입니다. 즉 가상 메모리 주소 또는 가상 주소라고 불리며, 실제 메모리 데이터에 접근할 때는 물리 주소로 변환되어 접근하게 됩니다.

![스크린샷 2024-10-23 오후 10 39 14](https://github.com/user-attachments/assets/c468804e-ca6a-4b63-9019-701d04043009)

<br>

#### 가상 메모리와 물리 메모리

- 가상 메모리의 주소는 실제로 물리 메모리 이곳저곳에 흩어져 있습니다.
- 가상 메모리와 물리 메모리 사이의 사상(mapping) 관계를 유지해야 합니다.
- 가상 메모리 주소와 물리 메모리 주소의 사상 관계만 유지되면 프로세스 주소 공간의 데이터가 실제 물리 메모리에 어디에 위치하는지 신경쓸 필요가 없습니다.
- 사상 관계를 유지하는 것을 페이지 테이블이라고 하며, 각각의 프로세스에는 단 하나의 페이지 테이블만 있어야 합니다.
- 그렇기 때문에 두 프로세스가 동일한 메모리 주소에 기록하더라도 물리 메모리 주소는 다르기 때문에 문제가 발생하지 않게 되는 것입니다.

![스크린샷 2024-10-23 오후 10 47 22](https://github.com/user-attachments/assets/783ed142-94b5-4b26-8e26-0dc49eb63477)

<br>

## 3. 스택 영역
























