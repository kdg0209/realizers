# 저수준 계층 메모리라는 사물함부터 시작해보자

<br>

## 1. 변수의 의미

#### 예시

- 아래 예시를 보면 값 1을 메모리 주소 6에 저장하는 것인지, 메모리 주소 1에 값 6을 저장하는 것인지 명확하지 않습니다.

```text
store 1 6
# 값 1을 메모리 주소 6에 저장하라는 의미입니다.
```

#### 변수의 탄생

- 아래 예시는 변수 a에 1이라는 값이 할당되어 있습니다.
- 변수 a에 특정 값이 할당되어있는 단순한 예시이지만 사실 중요한게 숨겨져 있습니다. 바로 변수 a가 나타내는 숫자 1이 특정 메모리 주소에 저장되어 있다는 것입니다. 변수를 사용함으로써 우리는 이 값이 메모리에 적재되었겠구나 생각하며 구체적으로 어느 위치에 적재되는지 알 필요가 없게 되는 것입니다.
- 주소라는 개념은 변수로 추상화되어 있기 때문에 a가 어디에 적재되는지 신경쓸 필요없이 이런 변수가 존재한다라는 것만 알고있으면 됩니다.

```text
a = 1
```

<br>

## 2. 프로세스는 메모리안에서 어떤 모습을 하고 있을까?

#### 64비트 시스템에서의 메모리 레이아웃

- 메모리의 모든 프로세스는 아래 그림처럼 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 구성되어 있습니다.
- 가장 흥미로운 점은 모든 프로세스의 코드 영역이 0x400000에서 시작하며, 서로 다른 프로세스를 메모리에 적재할 때 malloc system call을 호출하면 동일한 시작 주소를 반환할 가능성이 매우 높습니다. 근데 서로 다른 프로세스가 동일한 메모리 주소를 가진다는게 말이 안됩니다. 어떻게 된 걸까요?

#### 🤔 어떻게 동일한 메모리 주소를 가질 수 있는걸까?

- 사실 이는 가짜 주소입니다. 즉 가상 메모리 주소 또는 가상 주소라고 불리며, 실제 메모리 데이터에 접근할 때는 물리 주소로 변환되어 접근하게 됩니다.

![스크린샷 2024-10-23 오후 10 39 14](https://github.com/user-attachments/assets/c468804e-ca6a-4b63-9019-701d04043009)

<br>

#### 가상 메모리와 물리 메모리

- 가상 메모리의 주소는 실제로 물리 메모리 이곳저곳에 흩어져 있습니다.
- 가상 메모리와 물리 메모리 사이의 사상(mapping) 관계를 유지해야 합니다.
- 가상 메모리 주소와 물리 메모리 주소의 사상 관계만 유지되면 프로세스 주소 공간의 데이터가 실제 물리 메모리에 어디에 위치하는지 신경쓸 필요가 없습니다.
- 사상 관계를 유지하는 것을 페이지 테이블이라고 하며, 각각의 프로세스에는 단 하나의 페이지 테이블만 있어야 합니다.
- 그렇기 때문에 두 프로세스가 동일한 메모리 주소에 기록하더라도 물리 메모리 주소는 다르기 때문에 문제가 발생하지 않게 되는 것입니다.

![스크린샷 2024-10-23 오후 10 47 22](https://github.com/user-attachments/assets/783ed142-94b5-4b26-8e26-0dc49eb63477)

<br>

## 3. 스택 영역

#### 함수

- 함수는 가장 기초적인 코드 재사용 방식 중의 하나입니다.
- 함수는 세부 구현 사항을 캡슐화시킬 수 있으며, 함수명, 매개변수, 반환값을 알고 있으면 자유롭게 사용할 수 있습니다.

#### 스택

- 아래와 같은 코드가 있다고 생각해봅시다. 그럼 어떠한 스레드에 의해 bar() 라는 메서드가 호출되면 내부적으로 methodA() -> methodB() 메서드가 호출되게 됩니다.

```java
public class Main {

    public void bar() {

        methodA();
        methodB();
    }
    
    public void methodA() { }

    public void methodB() { }
}
```

<br>

#### 💡 그림으로 더 자세히

- 위 예제 코드는 아래와 같은 구성이 됩니다. 그리고 호출 스택(call stack)은 아래 방향으로 스택이 쌓이게 됩니다. 그 이유는 스택 영역은 높은 주소에서 낮은 주소로 커지기 때문입니다.

![스크린샷 2024-10-25 오후 8 29 52](https://github.com/user-attachments/assets/0d6aa9ab-f040-4171-94a8-bdcea646fb8a)

<br>

#### 함수의 점프와 반환

- 아래 CPU가 methodA() 를 실행하면서 0x400565 명령어를 수행한 후 call 0x400540 명령어를 실행시킬려고 하는데, 0x400540 명령어는 methodB()의 시작점입니다. 따라서 CPU는 methodB()로 향하게되며, 아래 그림에서 methodA() 메서드에서 methodB() 메서드로 넘어간것과 동일합니다.
- 근데 중간에 빨간색이 하나 보이는데 대체 뭘까요? 바로 methodB()의 반환 주소가 담겨있습니다. methodB()는 마지막 명령어는 ret까지 실행이 되는데, 이 명령어는 CPU에 methodA()의 스택 프레임에 저장된 반환 주소로 점프하도록 전달하는 역할을 합니다. 따라서 methodB()가 종료되면 methodA()를 이어서 작업할 수 있게 되는것입니다.

![스크린샷 2024-10-25 오후 8 46 55](https://github.com/user-attachments/assets/f82a621a-1233-4d85-aba6-17821c28b1dd)

<br>

#### 매개변수 전달과 반환값은 어떻게 구현될까?

- x86-64에서는 대부분의 경우 매개변수 전달과 반환값은 레지스터를 이용하게 됩니다.
- 함수 A가 함수 B를 호출한다면 함수 A는 매개변수를 상응하는 레지스터에 저장하며, CPU가 함수 B를 실행할 때 레지스터에서 매개변수의 값을 읽을 수 있습니다. 반환값 역시 함수 B가 반환값을 레지스터에 저장하면 CPU가 함수 A를 실행할 때 레지스터에서 값을 읽어올 수 있습니다.
- 하지만 레지스터 수는 제한되어 있기 때문에 레지스터 수보다 많은 매개변수를 넘긴다면 스택 영역을 사용하게 됩니다. 즉 매개변수 수가 레지스터 수보다 많다면 스택 영역에 저장한 뒤 새로 호출된 함수가 이전 함수의 스택 프레임이서 매개변수를 가져오게 됩니다. 

![스크린샷 2024-10-25 오후 8 59 21](https://github.com/user-attachments/assets/445e4219-11a6-4750-9662-b11923f16a57)

<br>

#### 지역 변수는 어디에 있을까?

- 지역 변수는 함수 내부에서만 사용되고, 외부에서는 참조할 수 없습니다. 이런 지역 변수도 매개변수와 마찬가지로 레지스터에 저장될 수 있으며, 지역 변수가 레지스터 수보다 많다면 이 변수들도 스택 프레임에 저장됩니다.

![스크린샷 2024-10-25 오후 9 01 46](https://github.com/user-attachments/assets/5b099526-c340-47fd-8ef0-75e6fc9da840)

<br>

## 4. 힙 영역














