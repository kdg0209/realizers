# 저수준 계층 메모리라는 사물함부터 시작해보자

<br>

## 1. 변수의 의미

#### 예시

- 아래 예시를 보면 값 1을 메모리 주소 6에 저장하는 것인지, 메모리 주소 1에 값 6을 저장하는 것인지 명확하지 않습니다.

```text
store 1 6
# 값 1을 메모리 주소 6에 저장하라는 의미입니다.
```

#### 변수의 탄생

- 아래 예시는 변수 a에 1이라는 값이 할당되어 있습니다.
- 변수 a에 특정 값이 할당되어있는 단순한 예시이지만 사실 중요한게 숨겨져 있습니다. 바로 변수 a가 나타내는 숫자 1이 특정 메모리 주소에 저장되어 있다는 것입니다. 변수를 사용함으로써 우리는 이 값이 메모리에 적재되었겠구나 생각하며 구체적으로 어느 위치에 적재되는지 알 필요가 없게 되는 것입니다.
- 주소라는 개념은 변수로 추상화되어 있기 때문에 a가 어디에 적재되는지 신경쓸 필요없이 이런 변수가 존재한다라는 것만 알고있으면 됩니다.

```text
a = 1
```

<br>

## 2. 프로세스는 메모리안에서 어떤 모습을 하고 있을까?

#### 64비트 시스템에서의 메모리 레이아웃

- 메모리의 모든 프로세스는 아래 그림처럼 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 구성되어 있습니다.
- 가장 흥미로운 점은 모든 프로세스의 코드 영역이 0x400000에서 시작하며, 서로 다른 프로세스를 메모리에 적재할 때 malloc system call을 호출하면 동일한 시작 주소를 반환할 가능성이 매우 높습니다. 근데 서로 다른 프로세스가 동일한 메모리 주소를 가진다는게 말이 안됩니다. 어떻게 된 걸까요?

#### 🤔 어떻게 동일한 메모리 주소를 가질 수 있는걸까?

- 사실 이는 가짜 주소입니다. 즉 가상 메모리 주소 또는 가상 주소라고 불리며, 실제 메모리 데이터에 접근할 때는 물리 주소로 변환되어 접근하게 됩니다.

![스크린샷 2024-10-23 오후 10 39 14](https://github.com/user-attachments/assets/c468804e-ca6a-4b63-9019-701d04043009)

<br>

#### 가상 메모리와 물리 메모리

- 가상 메모리의 주소는 실제로 물리 메모리 이곳저곳에 흩어져 있습니다.
- 가상 메모리와 물리 메모리 사이의 사상(mapping) 관계를 유지해야 합니다.
- 가상 메모리 주소와 물리 메모리 주소의 사상 관계만 유지되면 프로세스 주소 공간의 데이터가 실제 물리 메모리에 어디에 위치하는지 신경쓸 필요가 없습니다.
- 사상 관계를 유지하는 것을 페이지 테이블이라고 하며, 각각의 프로세스에는 단 하나의 페이지 테이블만 있어야 합니다.
- 그렇기 때문에 두 프로세스가 동일한 메모리 주소에 기록하더라도 물리 메모리 주소는 다르기 때문에 문제가 발생하지 않게 되는 것입니다.

![스크린샷 2024-10-23 오후 10 47 22](https://github.com/user-attachments/assets/783ed142-94b5-4b26-8e26-0dc49eb63477)

<br>

## 3. 스택 영역

#### 함수

- 함수는 가장 기초적인 코드 재사용 방식 중의 하나입니다.
- 함수는 세부 구현 사항을 캡슐화시킬 수 있으며, 함수명, 매개변수, 반환값을 알고 있으면 자유롭게 사용할 수 있습니다.

#### 스택

- 아래와 같은 코드가 있다고 생각해봅시다. 그럼 어떠한 스레드에 의해 bar() 라는 메서드가 호출되면 내부적으로 methodA() -> methodB() 메서드가 호출되게 됩니다.

```java
public class Main {

    public void bar() {

        methodA();
        methodB();
    }
    
    public void methodA() { }

    public void methodB() { }
}
```

<br>

#### 💡 그림으로 더 자세히

- 위 예제 코드는 아래와 같은 구성이 됩니다. 그리고 호출 스택(call stack)은 아래 방향으로 스택이 쌓이게 됩니다. 그 이유는 스택 영역은 높은 주소에서 낮은 주소로 커지기 때문입니다.

![스크린샷 2024-10-25 오후 8 29 52](https://github.com/user-attachments/assets/0d6aa9ab-f040-4171-94a8-bdcea646fb8a)

<br>

#### 함수의 점프와 반환

- 아래 CPU가 methodA() 를 실행하면서 0x400565 명령어를 수행한 후 call 0x400540 명령어를 실행시킬려고 하는데, 0x400540 명령어는 methodB()의 시작점입니다. 따라서 CPU는 methodB()로 향하게되며, 아래 그림에서 methodA() 메서드에서 methodB() 메서드로 넘어간것과 동일합니다.
- 근데 중간에 빨간색이 하나 보이는데 대체 뭘까요? 바로 methodB()의 반환 주소가 담겨있습니다. methodB()는 마지막 명령어는 ret까지 실행이 되는데, 이 명령어는 CPU에 methodA()의 스택 프레임에 저장된 반환 주소로 점프하도록 전달하는 역할을 합니다. 따라서 methodB()가 종료되면 methodA()를 이어서 작업할 수 있게 되는것입니다.

![스크린샷 2024-10-25 오후 8 46 55](https://github.com/user-attachments/assets/f82a621a-1233-4d85-aba6-17821c28b1dd)

<br>

#### 매개변수 전달과 반환값은 어떻게 구현될까?

- x86-64에서는 대부분의 경우 매개변수 전달과 반환값은 레지스터를 이용하게 됩니다.
- 함수 A가 함수 B를 호출한다면 함수 A는 매개변수를 상응하는 레지스터에 저장하며, CPU가 함수 B를 실행할 때 레지스터에서 매개변수의 값을 읽을 수 있습니다. 반환값 역시 함수 B가 반환값을 레지스터에 저장하면 CPU가 함수 A를 실행할 때 레지스터에서 값을 읽어올 수 있습니다.
- 하지만 레지스터 수는 제한되어 있기 때문에 레지스터 수보다 많은 매개변수를 넘긴다면 스택 영역을 사용하게 됩니다. 즉 매개변수 수가 레지스터 수보다 많다면 스택 영역에 저장한 뒤 새로 호출된 함수가 이전 함수의 스택 프레임이서 매개변수를 가져오게 됩니다. 

![스크린샷 2024-10-25 오후 8 59 21](https://github.com/user-attachments/assets/445e4219-11a6-4750-9662-b11923f16a57)

<br>

#### 지역 변수는 어디에 있을까?

- 지역 변수는 함수 내부에서만 사용되고, 외부에서는 참조할 수 없습니다. 이런 지역 변수도 매개변수와 마찬가지로 레지스터에 저장될 수 있으며, 지역 변수가 레지스터 수보다 많다면 이 변수들도 스택 프레임에 저장됩니다.

![스크린샷 2024-10-25 오후 9 01 46](https://github.com/user-attachments/assets/5b099526-c340-47fd-8ef0-75e6fc9da840)

<br>

## 4. 힙 영역

#### 힙 영역이 필요한 이유

- 특정 데이터를 여러 함수에서 사용해야 한다면 어떻게 해야할까요? 전역 변수를 사용할 수도 있지만 전역 변수는 모든 영역에서 참조가 가능하고, 때로는 데이터를 특정한 곳에서만 참조 가능하게 만들고 싶을 수도 있습니다. 따라서 프로그래머는 직접 관리가 가능한 메모리 영역에 저장해야하는데, 그래서 프로그래머가 완전히 제어할 수 있는 매우 큰 메모리 영역이 필요하며, 이를 힙 영역이라 합니다.

#### 메모리 할당 전략

최조 적합 방식

- 매번 처음부터 탐색하다가 가장 처음 발견된 적합한 메모리 공간을 할당하는 방식입니다. 이러한 방식은 내부 단편화가 발생할 수 있는 문제점이 있습니다.

최적 적합 방식

- 최적 적합 방식은 먼저 사용 가능한 메모리 조각을 모두 찾은 후 그중 가장 적합한 메모리 공간을 할당하는 방식입니다. 이 방식은 탐색 시간이 다른 방식에 비해 많이 소요될 수 있습니다.

<img width="1032" alt="스크린샷 2024-10-26 오후 1 39 24" src="https://github.com/user-attachments/assets/99e947ca-4654-427e-9a3e-7fc71b895733">

<br><br>

## 5. 메모리를 할당할 때 저수준 계층에서 일어나는 일

#### 사용자 상태

- 프로그래머가 작성한 코드를 CPU가 실행할 때 사용자 상태가 됩니다.
- 사용자 상태에서는 특정 주소 공간에 접근할 수 없습니다.

#### 커널 상태

- CPU가 어떠한 명령어를 수행할 때 커널 상태가 됩니다. 커널 상태에서는 CPU가 모든 명령어를 실행할 수 있고, 모든 메모리 공간에 접근할 수 있으며, 제한없이 하드웨어에 접근할 수 있습니다.

#### System Call

- 응용 프로그램이 파일에 대해 읽거나 쓰기, 네트워크 데이터 송수신을 할 때 운영체제의 도움을 받아야 합니다. 도움을 요청하는 것을 System call이라 합니다.
- System call이 수행될 때 CPU는 사용자 모드에서 커널 모드로 전환되어 운영체제의 코드를 실행하는 방법으로 사용자 요청을 수행하게 됩니다.

<img width="1032" alt="스크린샷 2024-10-26 오후 2 09 37" src="https://github.com/user-attachments/assets/190a8465-4889-48a9-8bea-596f22a34536">

<br><br>

## 6. 고성능 서버의 메모리 풀은 어떻게 구현될까?

#### 메모리 풀

- 메모리 풀은 세마포어와 비슷한 원리입니다. 미리 사용 가능한 객채들을 만들어 놓고, 요청이 들어오면 하나싹 할당한 뒤, 작업이 끝나면 다시 풀에 자원을 반납하는 것입니다.

<br>

## 9. SSD는 왜 메모리로 사용할 수 없을까?

#### 메모리에서 읽기/쓰기와 디스크에서 읽기/쓰기 차이

- 매모리의 주소 지정 단위는 바이트 단위입니다. 즉 각 바이트마다 주소가 지정되어 있으며, CPU는 이 주소를 이용하여 실제 주소에 접근할 수 있습니다.
- SSD는 조각 단위로 주소가 지정됩니다. 또한 CPU가 파일의 특정 바이트에 직접 접근할 수 있는 방법이 없습니다.

#### 가상 메모리의 제한

- 32비트 시스템에서 최대 주소 지정 범위는 4GB에 불과하므로 1TB 크기를 가진 SSD를 메모리로 사용하더라도 여전히 프로세스는 4GB 이상의 메모리를 사용할 수 없습니다. 물론 64비트 시스템에서는 이런 문제가 나타나지 않습니다. (64비트 시스템의 최대 주소 지정 범위는 16TB입니다.)

#### SSD 사용 수명 문제

- CPU는 프로그램을 실핼할 때 대량의 메모리 읽기와 쓰기 작업을 수행하므로 SSD를 메모리로 사용하면 사용 수명 때문에 시스템 병목 현상이 발생할 수 있지만 메모리에서는 이런 문제가 발생하지 않습니다.


