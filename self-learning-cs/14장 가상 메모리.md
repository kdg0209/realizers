# 가상 메모리

## 연속 메모리 할당
<hr>

- 연속 메모리 할당이란 메모리에 프로세스들이 연속적인 공간을 할당 받는 방식입니다.

### 스와핑

- 메모리에 적재된 프로세스들 중에서 현재 실행되지 않는 프로세스가 있을 수 있는데, 이러한 프로세스를 보조기억장치의 일부 영역으로 쫓아내고, 이렇게 해서 생긴 빈 공간에 다른 프로세스를 적재하는 방법입니다.
- 프로세스들이 쫓겨나 보조기억장치의 일부 영역을 스왑 영역이라 합니다.

<img width="972" alt="스크린샷 2024-01-21 오후 3 48 39" src="https://github.com/kdg0209/realizers/assets/80187200/f4b05519-a5ec-4f2e-8504-a3dcd7d05334">

### 메모리 할당

#### 최초 적합

- 최초 적합은 운영체제가 메모리 내 빈공간을 탐색하다가 적재할 수 있는 공간을 발견하면 즉시 프로세스를 할당하는 방식입니다.

#### 최적 적합

- 최적 적합은 운영체제가 메모리 내 빈공간을 탐색하다가 빈 공간중 프로세스가 필요로 하는 공간 중 가장 작은 공간을 할당하는 방식입니다.

#### 최악 적합

- 최악 적합은 운영체제가 메모리 내 빈공간을 탐색하다가 가장 큰 공간에 프로세스를 배치하는 방식입니다.

### 외부 단편화

- 외부 단편화란 프로세스들이 실행되고 종료되길 반복하면서 메모리 사이에 생기는 빈 공간입니다.
- 이러한 빈 공간은 그 공간보다 큰 프로세스를 적재하기 어려운 상항을 만들고, 결국 메모리 낭비로 이어집니다.
- 외부 단편화의 문제는 압축이라는 방법을 사용하여 해결할 수 있습니다. 압축은 메모리 내의 모든 프로세스를 한쪽으로 몰고 다른 한쪽으로는 가용 공간을 모으는 방식입니다.
- 압축은 재배치 가능 코드가 있어야 할 수 있습니다. 주소 바인딩을 로드 시점과 실행 시점을 사용해야지만 압축을 사용할 수 있습니다.

<img width="878" alt="스크린샷 2024-01-21 오후 3 49 09" src="https://github.com/kdg0209/realizers/assets/80187200/dbb47f5e-f0d8-471d-b877-78eedd13144a">

<br>

## 페이징을 통한 가상 메모리 관리
<hr>

### 페이징이란

- 페이징은 프로세스의 논리 주소 공간을 페이지라는 일정 단위로 자르고, 메모리의 물리 주소 공간을 프레임이라는 페이지와 동일한 크기로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법입니다.
- 프로세스를 이루는 페이지 중 실행에 필요한 페이지만 메모리에 적재하고, 실행에 필요하지 않는 페이지는 보조기억장치에 남겨 놓습니다.

#### 페이지 테이블

- 프로세스가 메모리내에 불 연속적으로 배치되어 있다면 CPU는 명령어를 순차적으로 실행할 수 없습니다. 이러한 문제점을 해결하기 위해 페이지 테이블을 사용할 수 있습니다.
- CPU로 하여금 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있도록 합니다.
- 프로세스마다 페이지 테이블이 있습니다.
- 물리 주소상에서는 프로세스들이 분산되어 저장되어 있더라도 CPU 입장에서는 페이지 테이블을 통해 논리 주소는 연속적으로 보일 수 있습니다.

<img width="1000" alt="스크린샷 2024-01-21 오후 3 49 38" src="https://github.com/kdg0209/realizers/assets/80187200/ed233e46-41f0-4901-be08-d5e03e853384">

#### 페이지 테이블의 동작 원리

1. 물리 메모리는 프레임이라 불리는 블럭으로 나뉩니다.
2. CPU의 논리 주소는 페이지 번호(p)와 오프셋(d)로 구분됩니다.
3. 페이지 번호는 프로세스의 페이지 테이블에 접근할 때 사용됩니다.
4. 페이지 테이블은 물리 메모리의 각 프레임의 시작 주소를 가지고 있으며, 오프셋은 프레임의 시작 번지로부터 얼만큼 떨어져 있는지 알기 위한 정보입니다.

💡 페이지 테이블의 단점 

- 메모리 접근 시간이 두 배로 늘어납니다. 메모리에 있는 페이지 테이블에 접근하기 위한 한 번과 페이지 테이블을 통해 알게된 프레임에 접근하기 위한 한 번, 이렇게 총 두 번의 메모리 접근이 필요하게 되어 느립니다.

<img width="1021" alt="스크린샷 2024-01-21 오후 3 50 06" src="https://github.com/kdg0209/realizers/assets/80187200/cd95a8aa-1c92-4bbe-b58d-43c0fb6768f1">

### TLB 

- 페이지 테이블을 사용하여 패이징을 구현하면 메모리에 2번 접근하게 되므로 지연일 발생할 수 있는데 이를 TLB라는 특수한 하드웨어 캐시로 해결할 수 있습니다.
- TLB는 캐시 메모리로 참조 지역성의 원리를 통해 페이지 테이블에서 빈번히 참조되는 일부 엔트리를 캐싱하고 있습니다.
- CPU는 페이지 테이블보다 우선적으로 TLB를 참조하여 원하는 페이지 번호가 TLB에 있으면 바로 프레임 번호를 알 수 있지만 그렇지 않은 경우 메인 메모리에 있는 페이지 테이블을 이용해 얻을 수 있습니다.

#### TLB의 동작 원리

<img width="1026" alt="스크린샷 2024-01-21 오후 3 50 31" src="https://github.com/kdg0209/realizers/assets/80187200/4000d5b5-5dda-4991-9ba6-a0fe7fb45623">

### 내부 단편화

- 내부 단편화란 프로세스가 할당된 공간보다 더 큰 공간이 할당되어 발생합니다. 
- 공간을 너무 작게하면 하나의 페이지 크기를 너무 작게 설정하면 그 만큼 페이지 테이블의 크기가 커지므로 공간이 낭비됩니다.

<img width="1413" alt="스크린샷 2024-01-21 오후 3 51 04" src="https://github.com/kdg0209/realizers/assets/80187200/7c1f5274-7127-4ac5-9d71-25da47816019">

### 페이지 테이블 엔트리

- 페이지 테이블에는 페이지 번호와 프레임 번호를 제외하고도 중요한 정보들이 있습니다.

#### 유효 비트

- 현재 해당 페이지에 접근 가능한지 여부를 알려줍니다.
- 유효 비트는 현재 페이지가 메모리에 적재되어 있으면 1, 보조기억장치에 있으면 0입니다.
- 유효비트가 0이라면 페이지 폴트가 발생하여 해당 페이지를 메모리에 적재하게 됩니다.

#### 보호 비트

- 보호 비트를 통해 해당 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 혹은 읽기만 가능한 페이지인지 나타냅니다.

#### 참조 비트

- CPU가 이 페이지에 접근한적이 있는지 여부를 나타냅니다.
- 적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트가 1이고, 한번도 읽거나 쓴적이 없으면 0입니다.

#### 수정 비트

- 해당 페이지에 데이터를 쓴적이 있는지 없는지 수정 여부를 나타냅니다.

<br>

## 페이지 교체와 프레임 할당 
<hr>

### 요구 페이징

- 요구 페이징이란 처음부터 프로세스의 모든 페이지를 메모리에 적재하지 않고, 필요한 페이지만을 메모리에 적재하는 것입니다.

### 페이지 교체 알고리즘

#### FIFO 페이지 교체 알고리즘

- 어떤 페이지를 교체해야 하는 경우 가장 먼저 올라온 페이지부터 교체 하는 방식입니다.

<img width="779" alt="스크린샷 2024-01-21 오후 3 51 48" src="https://github.com/kdg0209/realizers/assets/80187200/8cace4b0-f7a9-48e3-8896-733f03bcca98">

#### LRU 페이지 교체 알고리즘

- 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘입니다.
- 페이지마다 마지막으로 사용한 시간을 토대로 최근에 가장 사용이 적었던 페이지를 교체하는 알고리즘이니다.
- 해당 알고리즘은 하드웨어의 지원을 필요로 합니다. 그 이유는 최근 사용된 시간 순서를 파악하기 위해서입니다.

#### LFU 페이지 교체 알고리즘

- LFU 페이지 교체 알고리즘은 참조 횟수가 가장 적은 페이지를 교체하는 방식입니다. 가장 적은 참조 횟수를 가진 페이지를 교체하는 이유는 활발하게 사용되는 페이지는 참조 횟수가 클 것이라고 생각하기 때문입니다.
- 만약 프로세스 초기 단계에 한 페이지를 집중적으로 사용하다가 시간이 흘러 점차 사용안하게 될 수 있는데 이때는 참조 횟수를 일정 시간마다 줄이게 됩니다.

#### MFU 페이지 교체 알고리즘

- MFU는 LFU와 반대로 참조 횟수가 가장 많은 페이지를 교체하는 방식입니다.

### 스래싱이란

- 스래싱이란 프로세스에 충분한 프레임이 없는 경우 페이지 폴트가 발생하게 됩니다.
- 동시에 실행되는 프로세스 수가 어느정도 증가하면 CPU 이용률이 높아지지만, 필요 이상으로 늘리면 각 프로세스들이 사용할 수 있는 프레임 수가 적어지기 때문에 페이지 폴트가 빈번히 발생하게 되고, 이에따라 CPU 이용률은 낮아지게 됩니다.
- 스래싱이 발생하는 근본적은 원인은 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문입니다.

<br>
<br>

### 🤔 생각해볼 수 있는 질문들

1. 연속 메모리 할당이란 무엇인가?
2. 연속 메모리 할당의 문제점
    - 외부 단편화가 발생합니다.
    - 물리 메모리보다 큰 프로세스를 실행시킬 수 없습니다.
3. 스와핑이란 무엇인가?
4.  스와핑이 이루어져 미사용 프로세스는 어디에 저장되는가?
5. 메모리 할당의 3가지 방식을 설명하시오
6. 외부 단편화란 무엇인고, 이를 어떻게 해결할 수 있는가?
    - 압축 및 페이징을 통해 해결할 수 있습니다.
7. 페이징이란 무엇인가?
8. 페이지 테이블이란 무엇인가?
9. 페이지 테이블의 동작 원리가 어떻게 되는가?
10. 페이지 테이블의 단점이 무엇이고, 어떻게 보완할 수 있는가?
11. TLB의 동작 원리가 어떻게 되는가?
12. 내부 단편화란 무엇인가?
13. 페이지 테이블 엔트리는 어떻게 구성되어 있는가?
14. copy-on-write가 무엇인가
15. vfork가 무엇인가
16. 요구 페이징이란 무엇인가
17. 순수 요구 페이징이란 무엇인가
18. 페이지 폴트란 무엇인가
19. FIFO 페이지 교체 알고리즘이 무엇인가
20. LRU 페이지 교체 알고리즘이 무엇인가
21. LFU 페이지 교체 알고리즘이 무엇인가
22. MFU 페이지 교체 알고리즘이 무엇인가
23. 스래싱이 무엇인가


