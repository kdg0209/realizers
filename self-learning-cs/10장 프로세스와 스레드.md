# 프로세스와 스레드

## 프로세스 개요
<hr>

- 포그라운드 프로세스란 사용자가 볼 수 있는 곳에서 실행되는 프로세스입니다.
- 백그라운드 프로세스란 사용자가 보지 못하는 뒤에서 실행되는 프로세스입니다.
- 사용자와 상호작용하지 않고 그저 묵묵히 스스로의 일만 수행하는 백그라운드 프로세스도 있는데 이는 유닉스 운영체제에서는 데몬이라 부르고, 윈도우 운영체제에서는 서비스라 부릅니다.

### 프로세스 제어 블록(PCB)

- 프로세스 제어 블록이란 프로세스와 관련된 정보를 저장하는 자료 구조입니다.
- PCB는 메모리 내에 커널 영역에 생성됩니다.
- PCB는 프로세스 생성시에 만들어지고, 프로세스가 종료되면 폐기됩니다.

<br>

### 프로세스 제어 블록에 저장되는 정보들

#### 1. 프로세스 ID

- PID는 특정 프로세스를 식별하기 위한 고유 번호입니다.

#### 2. 레지스터 값

- 프로세스는 자신의 실행 차례가 돌아오면 이전까지 실행했던 정보들을 복원해야 합니다. 
- 이러한 정보에는 프로세스가 사용한 레지스터와 프로그램 카운터가 있습니다.

#### 3. 프로세스 상태

- 프로세스에 대한 상태 정보가 담겨 있습니다.

#### 4. CPU 스케줄링 정보

- 프로세스에 대한 우선순위 스케줄링 정보가 담겨 있습니다.

#### 5. 메모리 관리 정보

- PCB에는 프로세스가 메모리의 어느 주소에 저장되어 있는지에 대한 정보가 담겨 있습니다.
- PCB에는 베이스 레지스터, 한계 레지스터와 같은 정보들과 함께 페이지 테이블에 대한 정보도 담겨 있습니다.

#### 6. 사용한 파일과 입출력장치 목록

- 프로세스가 실행 도중 특정 입출력장치 및 파일을 사용했던 정보가 담겨 있습니다.

<br>

### 문맥 교환(context-switch)

- context-switch란 기존 프로세스의 문맥을 PCB에 백업하고, 새롭게 실행시킬 프로세스의 문맥을 PCB로부터 복구하여 실행하는 것입니다.

<br>

### 프로세스의 메모리 영역 

- 하나의 프로세스는 사용자 영역에 크게 코드영역, 데이터영역, 스택영역, 힙영역으로 구성되어 있습니다.

#### 1. 코드 영역

- 코드 영역이란 텍스트 영역이라고도 불립니다.
- CPU가 실행할 수 있는 명령어들이 저장되어 있습니다.
- 해당 영역은 명령어만 저장되어 있고, 데이터는 저장되어 있지 않습니다. 
- 해당 영역은 읽기 전용(read-only) 입니다.

#### 2. 데이터 영역

- 데이터 영역은 프로그램 실행 전반에 사용되는 전역 변수가 저장되어 있습니다.
- 코드 영역과 데이터 영역은 크기가 변하지 않습니다. 따라서 정적 할당 영역이라 부릅니다.

#### 3. 스택 영역

- 함수 호출시 함수의 매개변수, 지역변수, 함수가 종료하고 되돌아갈 주소 등이 저장되어 있습니다.
- 데이터를 일시적으로 저장하는 공간입니다. 예를들어 함수의 지역변수를 일시적으로 사용하다가 함수가 종료되면 해당 지역변수는 메모리 내에서 없어집니다.

#### 4. 힙 영역

- 힙 영역은 프로그래머가 할당 하는 저장 공간입니다.
- 힙 영역에 사용한 메모리를 반환하지 않으면 메모리 공간 내에 계속 남아 메모리 낭비를 발생시킵니다. 이를 메모리 누수라 합니다.
- 스택 영역과 힙 영역은 실행과정에서 크기가 동적으로 변합니다. 따라서 동적 할당 영역이라 부릅니다.
- 힙 영역은 메모리의 낮은 주소에서 높은 주소로 할당되고, 스택 영역은 높은 주소에서 낮은 주소로 할당됩니다. 그래야만 힙 영역과 스택 영역에 데이터가 쌓여도 새롭게 할당되는 주소는 겹칠일이 없어집니다.

<br>

## 프로세스 상태와 계층 구조
<hr>

### 프로세스 상태

#### 1. 생성 상태

- 프로세스를 생성 중인 상태를 생성 상태라 합니다.
- 프로세스에 대한 메모리 할당과 PCB를 만드는 상태입니다.

#### 2. 준비 상태

- 실행을 하기 위해 준비하고 있는 상태입니다. CPU를 할당받으면 바로 실행될 수 있는 상태입니다.
- CPU는 준비 상태에 머물러 있는 프로세스 중 하나를 실행시키는 것을 디스패치라 합니다.

#### 3. 실행 상태

- CPU를 할당받아 실행 중인 상태이빈다.

#### 4. 대기 상태

- 입출력장치에 의해 blocking된 상태입니다. 입출력 작업이 완료되면 해당 프로세스는 다시 준비 상태로 변환됩니다.

#### 5. 종료 상태

- 프로세스가 종료된 상태입니다. 프로세스가 종료되면 운영체제는 PCB를 폐기합니다.

<br>

### 프로세스 계층 구조

- 프로세스를 생성한 프로세스를 부모 프로세스, 부모 프로세스에 의해 생성된 프로세스를 자식 프로세스라 합니다.

<br>

### 프로세스 생성 기법

- 부모 프로세스는 fork 명령어를 통해 자신의 복사본을 자식 프로세스로 생성합니다.
- 자식 프로세스는 exec 명령어를 통해 자신의 메모리 공간을 다른 프로그램으로 교체합니다.
- 복사된 자식 프로세스라 할지라도 PID 값이나 메모리의 주소는 다릅니다.

#### exec 명령어

- exec 명령어는 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 system call입니다.
- exec 명령어를 호출하면 코드 영역과 데이터 영역의 내용은 실행할 프로그램으로 내용이 바뀌고 스택 영역과 힙 영역은 초기화됩니다.

<br>

## 스레드
<hr>

- 스레드는 프로세스를 구성하는 실행 흐름의 단위입니다.
- 하나의 프로세스는 여러개의 스레드를 가질 수 있습니다.
- 스래드는 프로세스 내에서 각기 다른 스레드 ID, 프로그램 카운터를 비롯한 레지스터 값, 스택으로 구성되어 있습니다.(TCB)
- 프로새스의 스레드들은 실행에 필요한 최소한의 정보만을 유지한 채 프로세스 자원을 공유하며 실행됩니다. 따라서 자원을 효과적으로 사용할 수 있습니다.

<img width="960" alt="스크린샷 2024-01-01 오후 2 16 07" src="https://github.com/kdg0209/realizers/assets/80187200/9b24f4d4-4421-4fa1-9349-00b6e2442afb">

### 멀티 프로세스와 멀티 스레드

- 여러 프로세스를 동시에 실행하는 것을 멀티 스레드라 합니다.
- 여러 스레드로 프로세스를 실행시키는 것을 멀티 스레드라 합니다.
- 프로세스끼리는 기본적으로 자원을 공유하지 않지만, 스레드끼리는 같은 프로세스 내의 자원을 공유합니다.
- 프로세스를 fork하여 같은 작업을 하는 동일한 프로세스 두 개를 실행시키면 코드영역, 데이터 영역, 스택 영역, 힙 영역을 비롯한 모든 자원이 복제되어 메모리에 적재됩니다. 이는 메모리 낭비입니다.
- 스레드는 각기 다른 스레드 ID, 프로그램 카운터를 포함한 레지스터 값, 스택을 가질 뿐 프로세스의 자원을 공유할 수 있습니다.

<img width="1001" alt="스크린샷 2024-01-01 오후 2 16 27" src="https://github.com/kdg0209/realizers/assets/80187200/beae9d8f-8643-4995-a704-bf7191219abf">


<br>
<br>

### 🤔 생각해볼 수 있는 질문들

1. 프로세스 제어 블록이란 무엇인가?
   - 프로세스 제어 블록이란 프로세스에 대한 정보를 저장하는 데이터 구조입니다.
3. 프로세스 제어 블록은 어디에 저장되는가?
   - PCB는 메모리내 커널 영역에 저장됩니다.
5. 프로세스 제어 블록에는 어떤 정보들이 저장되는가?
   - PID
   - 프로그램 카운터를 비롯한 다양한 레지스터 값
   - 프로세스 상태
   - 프로세스 메모리 관리 정보
   - 접근한 입출력장치 및 파일에 대한 정보
7. context-switch란 무엇인가?
   - 기존 프로세스를 백업하고 다른 프로세스를 실행시키는 과정
9. context-switch의 장점과 단점이 무엇인가?
    - 장점: CPU 독점을 방지하고 한정된 자원을 효과적으로 사용할 수 있다.
    - 단점: context-switch가 자주 발생하면 오버해드가 발생하여 성능이 떨어질 수 있다.
11. 프로세스의 사용자 영역의 메모리는 어떻게 구성되어 있는가?
    - 코드 영역(텍스트 영역), 데이터 영역, 스택 영역, 힙 영역
13. 프로세스의 5가지 상태에 대해 설명하시오.
14. 최초의 프로세스가 띄어지면 필요한 여러 부가적인 프로세스를 실행시켜야 하는데 어떻게 실행시킬 수 있는가?
   - 순수 요구 페이징을 사용할 수 있습니다.
   - 페이지 폴트
11. 좀비 프로세스란 무엇인가?
   - 부모 프로세스에 의해 생성된 자식 프로세스가 있는 상황에서 자식 프로세스가 먼저 죽는 경우에 발생하는데, 자식 프로세스가 exit system call을 호출하면서 종료될 때 부모 프로세스가 자식 프로세스의 상태를 알고 싶은 경우가 있기 때문에
      커널은 자식 프로세스가 종료되더라도 최소한의 정보(PID, 프로세스 종료 상태)등을 가지고 있게 됩니다. 이때 부모 프로세스가 wait system call을 호출하면 좀비 프로세스는 제거됩니다.
12. 고아 프로세스란 무엇인가?
   - 고아 프로세스란 부모 프로세스에 의해 생성된 자식 프로세스가 있는 상황에서 부모 프로세스가 먼저 제거된 경우 입니다. 이때 init 프로세스는 wait system call을 호출하여 새로운 부모 프로세스를 할당해줍니다.
13. 프로세스 간 통신이 무엇인가?
