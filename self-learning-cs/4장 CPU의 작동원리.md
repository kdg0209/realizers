# CPU의 작동 원리

## 04-1: ALU와 제어장치
<hr>

### ALU 

<img width="1030" alt="스크린샷 2023-12-10 오후 2 19 12" src="https://github.com/kdg0209/realizers/assets/80187200/1e6cf1a5-a5be-4eff-a0d0-88b488b7f8f4">


- 위 그림을 보면 03장에서 명령어가 어떻게 구성되어 있는지 다시 상기할 필요성이 있습니다.
제어장치가 명령어 레지스터로부터 명령어를 읽어 들이면 제어장치는 ALU에 제어신호를 보내고 ALU는 연산을 하게 됩니다.
- 이제 ALU가 연산을 수행할 때 레지스터로부터 피연산자를 가져오고, 제어장치로부터 받은 연산자로 계산을 하게 됩니다.
그리고 결과값을 다시 레지스터에 저장하고, 결과값에 대한 부가적인 정보를 플래그 레지스터에 저장하게 됩니다.
- ALU가 수행한 결과는 숫자, 문자일 수도 있고 메모리의 주소가 될 수도 있습니다. 그리고 이 결과값은 바로 메모리에 적재시키는게 아니라 일시적으로 레지스터에 저장하게 됩니다.

#### 플래그 

- ALU가 결과값을 레지스터에 저장할때 결과값에 대한 부가적인 정보도 플래그 레지스터에 저장한다고 하였는데 플래그는 다음과 같은 종류가 있습니다.
  - 부호 플래그
  - 제로 플래그
  - 캐리 플래그
  - 오버플로우 플래그
  - 인터럽트 플래그
  - 슈퍼바이저 플래그

<br>

### 제어장치

<img width="1019" alt="스크린샷 2023-12-10 오후 2 19 53" src="https://github.com/kdg0209/realizers/assets/80187200/63c8a6dc-72b7-4ab7-891e-10d457534bd7">

- 제어장치란 제어신호를 내보내고, 명령어를 해석하고, 실행하는 장치입니다.
- 제어장치는 클럭 신호를 받아들입니다.
  - 클럭이란 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위입니다.
- 제어장치는 명렁어 레지스터로부터 해석해야할 명령어를 받아들입니다.
  - 명령어 레지스터로부터 명렁어를 받아들여 해석한 후 제어신호를 발생시켜 다른 작업 장치에게 수행해야할 내용을 전달합니다.
- 제어장치는 플래그 레지스터가 가지고 있는 플래그 값을 받아들입니다.
  - ALU가 연산한 결과값에 대한 부가적인 정보를 플래그 레지스터로부터 받아들입니다.
- 제어장치는 시스템 버스 중 하나인 제어 버스로 전달된 제어 신호를 받아들입니다.
  - 제어신호는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있는데, 제어장치는 제어버스를 통해 외부로부터 전달된 제어 신호를 받아들입니다.
  


<br>
<br>

### 🤔 생각해볼 수 있는 질문들

1. ALU는 수행한 결과를 왜 레지스터에 저장하는걸까?
   - CPU 내부에 있는 레지스터에 저장하는 것이 더 효율적이기 때문입니다. CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 속도가 훨씬 빠릅니다.
2. 커널 모드와 사용자 모드가 무엇인가?
   - 사용자 모드란 사용자가 접근할 수 있는 공간을 제한적으로 두고, 프로그램의 자원에 함부로 접근하지 못하게 설정한 모드입니다.
   - 커널 모드란 모든 자원(권한, CPU, 메모리, 입출력 장치 등) 접근 및 명령할 수 있는 모드입니다.
   - 프로세스가 실행되는 동안 사용자 모드와 커널 모드가 반복되어 수행되는데, 사용자 모드에서 fopen 함수 등의 프로그램의 자원을 사용할때 system call을 이용해 커널 모드에 요청합니다.
   system call을 받은 커널 모드는 해당 요청에 대한 작업을 완료한 후 system call의 반환값으로 결과값을 되돌려주게 됩니다.

<img width="1342" alt="스크린샷 2023-12-10 오후 2 20 29" src="https://github.com/kdg0209/realizers/assets/80187200/9ba8a5ca-c82d-4bb0-b265-b3a7ee5d4ed8">
