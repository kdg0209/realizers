# CPU의 작동 원리

## 04-1: ALU와 제어장치
<hr>

### ALU 

<img width="1030" alt="스크린샷 2023-12-10 오후 2 19 12" src="https://github.com/kdg0209/realizers/assets/80187200/1e6cf1a5-a5be-4eff-a0d0-88b488b7f8f4">


- 위 그림을 보면 03장에서 명령어가 어떻게 구성되어 있는지 다시 상기할 필요성이 있습니다.
제어장치가 명령어 레지스터로부터 명령어를 읽어 들이면 제어장치는 ALU에 제어신호를 보내고 ALU는 연산을 하게 됩니다.
- 이제 ALU가 연산을 수행할 때 레지스터로부터 피연산자를 가져오고, 제어장치로부터 받은 연산자로 계산을 하게 됩니다.
그리고 결과값을 다시 레지스터에 저장하고, 결과값에 대한 부가적인 정보를 플래그 레지스터에 저장하게 됩니다.
- ALU가 수행한 결과는 숫자, 문자일 수도 있고 메모리의 주소가 될 수도 있습니다. 그리고 이 결과값은 바로 메모리에 적재시키는게 아니라 일시적으로 레지스터에 저장하게 됩니다.

#### 플래그 

- ALU가 결과값을 레지스터에 저장할때 결과값에 대한 부가적인 정보도 플래그 레지스터에 저장한다고 하였는데 플래그는 다음과 같은 종류가 있습니다.
  - 부호 플래그
  - 제로 플래그
  - 캐리 플래그
  - 오버플로우 플래그
  - 인터럽트 플래그
  - 슈퍼바이저 플래그

<br>

### 제어장치

<img width="1019" alt="스크린샷 2023-12-10 오후 2 19 53" src="https://github.com/kdg0209/realizers/assets/80187200/63c8a6dc-72b7-4ab7-891e-10d457534bd7">

- 제어장치란 제어신호를 내보내고, 명령어를 해석하고, 실행하는 장치입니다.
- 제어장치는 클럭 신호를 받아들입니다.
  - 클럭이란 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위입니다.
- 제어장치는 명렁어 레지스터로부터 해석해야할 명령어를 받아들입니다.
  - 명령어 레지스터로부터 명렁어를 받아들여 해석한 후 제어신호를 발생시켜 다른 작업 장치에게 수행해야할 내용을 전달합니다.
- 제어장치는 플래그 레지스터가 가지고 있는 플래그 값을 받아들입니다.
  - ALU가 연산한 결과값에 대한 부가적인 정보를 플래그 레지스터로부터 받아들입니다.
- 제어장치는 시스템 버스 중 하나인 제어 버스로 전달된 제어 신호를 받아들입니다.
  - 제어신호는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있는데, 제어장치는 제어버스를 통해 외부로부터 전달된 제어 신호를 받아들입니다.

<br>

## 04-2: 레지스터
<hr>

- 프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장됩니다.

### 프로그램 카운터

- 프로그램 카운터(PC)는 실행해야할 명령어의 주소가 담겨있습니다.
- 현재 실행중인 명령어의 주소와 다음에 실행되어야할 명령어의 주소를 저장하고 있습니다.
- 프로그램 카운터를 명령어 포인터라고도 부립니다.
- context-switch가 발생하여 해당 프로세스가 중단되고 다시 실행될 때 프로그램 카운터에 저장해두었던 값을 확인하고 계속 실행될 수 있게됩니다.

### 명령어 레지스터

- 명령어 레지스터는 메모리에서 읽어들인 명령어를 저장하는 레지스터입니다.
- 제어장치는 명령어 레지스터로부터 받아들인 명령어를 이해하고, 해석하고 실행하게 됩니다.

### 메모리 주소 레지스터

- 메모리 주소 레지스터는 메모리의 주소를 저장하는 레지스터입니다.
- CPU가 읽어드리고자 하는 주소값을 주소 버스로 보낼때 메모리 주소 레지스터를 거치게 됩니다.

### 메모리 버퍼 레지스터(메모리 데이터 레지스터)

- 메모리 버퍼 레지스터는 메모리와 주고받을 값을 저장하는 레지스터입니다.
- 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값을 메모리 버퍼 레지스터에 저장하게 됩니다.

#### 위 레지스터의 과정

1. 프로그램 카운터에 실행해야할 명령어의 주소가 담겨있다.
2. 프로그램 카운터가 가지고 있는 주소는 명령어 레지스터에게 넘기게 되고, 명령어 레지스터는 메모리로부터 해당 주소의 명령어를 읽어들입니다.
3. 명령어 레지스터가 읽어들인 주소의 데이터는 데이터 버퍼 레지스터에 저장되게 됩니다.
4. 데이터 버퍼 레지스터에 있던 데이터는 명령어 레지스터에 전달되고 이 과정이 반복되게 됩니다.

### 범용 레지스터

- 범용 레지스터는 말 그대로 다양하고 일반적인 상황에서 자유롭개 사용할 수 있는 레지스터입니다.
- 범용 레지스터는 주소(메모리 주소 레지스터)와 데이터(데이터 버퍼 레지스터)를 모두 저장할 수 있습니다.

### 플래그 레지스터

- 플래그 레지스터는 ALU의 연산 결과에 대한 부가적인 정보나 CPU 상태에 대한 부가적인 정보를 저장하게 됩니다.

### 스택 주소 지정 방식

- 스택 주소 지정 방식은 스택과 스택 포인터를 이용한 주소 지정 방식입니다.
- 스택 포인터란 스택의 최상단을 가리키는 레지스터입니다. 즉 스택 포인터란 스택의 최상단 값의 위치를 저장하는 레지스터입니다.

<img width="999" alt="스크린샷 2023-12-10 오후 3 56 45" src="https://github.com/kdg0209/realizers/assets/80187200/6f7d61b9-bbe3-478a-95b5-a5968ed7fb91">

### 변위 주소 지정 방식

- 변위 주소 지정 방식이란 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식입니다.
- 이 방식은 상대 주소 지정 방식과 베이스 레지스터 주소 지정 방식이 있습니다.

<img width="1003" alt="스크린샷 2023-12-10 오후 3 57 11" src="https://github.com/kdg0209/realizers/assets/80187200/c80863fb-deb9-4e70-a01a-44ef0e67ebe4">

#### 상대 주소 지정 방식

- 상대 주소 지정 방식은 오퍼랜드와 프로그램 카운터의 값을 더하여 메모리의 유효 주소를 얻는 방법입니다.
- 오퍼랜드가 음수라면 프로그램 카운터로부터 이전이며, 오퍼랜드가 양수라면 프로그램 카운터로부터 이후로 접근합니다.


<img width="1011" alt="스크린샷 2023-12-10 오후 3 57 31" src="https://github.com/kdg0209/realizers/assets/80187200/d2b4429a-8d74-406c-b7a3-01b1cd173a8b">

#### 베이스 레지스터 주소 지정 방식

- 베이스 레지스터 주소 지정 방식은 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식입니다.
- 베이스 레지스터는 '기준 주소', 오퍼랜드는 '기준 주소로부터 떨어진 거리' 로서의 역할을 합니다.
- 즉 베이스 레지스터 주소 지정 방식은 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지 연산하여 유효 주소를 얻어내는 방식입니다.

<img width="1017" alt="스크린샷 2023-12-10 오후 3 57 55" src="https://github.com/kdg0209/realizers/assets/80187200/526b11a2-7fb0-4dc1-8868-6f7297f8224d">

<br>

## 04-3: 명령어 사이클과 인터럽트
<hr>

### 명령어 사이클

- 애플리케이션은 수 많은 명령어가 반복되어 실행되는데 이 반복되는 주기를 명렁어 사이클이라 합니다.
- 명렁어 사이클은 인출 사이클과 실행 사이클로 구성되어 있습니다.
  - 인출 사이클은 실행하고자 하는 명령어를 메모리로부터 가져오는 행위입니다.
  - 실행 사이클은 가져온 명령어를 실행하는 행위입니다.
  - 간접 사이클은 간접 주소 지정 방식을 사용했을 경우 인출 사이클에서 메모리를 두번 접근하게 됩니다.

### 인터럽트

- 인터럽트란 CPU가 행하고 있던 작업을 방해하는 신호입니다.

#### 동기 인터럽트

- CPU가 명령어를 수행하다가 예상치 못한 상황에 마주쳤을 때 발생합니다.(예외)

#### 비동기 인터럽트

- 비동기 인터럽트는 주로 입출력장치에 의해 발생하는 인터럽트입니다.

#### 인터럽트 진행 순서

1. 입출력장치는 CPU에게 인터럽트 신호를 보냅니다.
2. CPU는 실행 사이클이 끝나고 인출 사이클전에 플래그 레지스터 내에 있는 인터럽트 플래그를 항상 확인합니다.
3. CPU가 인터럽트 플래그를 통해 해당 인터럽트를 받아들일 수 있는 상황이라면 현재까지 작업한 내용을 저장합니다.(context-switch)
4. CPU는 인터럽트 백터를 참조하여 인터럽트 서비스 루틴을 실행합니다.
- 참고: CPU는 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 등 현재 프로세스의 정보를 메모리 중 스택영역에 저장하게 됩니다.

<br>
<br>

### 🤔 생각해볼 수 있는 질문들

1. ALU는 수행한 결과를 왜 레지스터에 저장하는걸까?
   - CPU 내부에 있는 레지스터에 저장하는 것이 더 효율적이기 때문입니다. CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 속도가 훨씬 빠릅니다.
2. 커널 모드와 사용자 모드가 무엇인가?
   - 사용자 모드란 사용자가 접근할 수 있는 공간을 제한적으로 두고, 프로그램의 자원에 함부로 접근하지 못하게 설정한 모드입니다.
   - 커널 모드란 모든 자원(권한, CPU, 메모리, 입출력 장치 등) 접근 및 명령할 수 있는 모드입니다.
   - 프로세스가 실행되는 동안 사용자 모드와 커널 모드가 반복되어 수행되는데, 사용자 모드에서 fopen 함수 등의 프로그램의 자원을 사용할때 system call을 이용해 커널 모드에 요청합니다.
   system call을 받은 커널 모드는 해당 요청에 대한 작업을 완료한 후 system call의 반환값으로 결과값을 되돌려주게 됩니다.

<img width="1342" alt="스크린샷 2023-12-10 오후 2 20 29" src="https://github.com/kdg0209/realizers/assets/80187200/9ba8a5ca-c82d-4bb0-b265-b3a7ee5d4ed8">

3. context-switch와 프로그램 카운터 동작에 대해 설명하시오.
4. 프로그램 카운터와 명령어 레지스터, 메모리 주소 레지스터, 메모리 버퍼 레지스터가 작동되는 흐름 과정을 설명해주세요.
5. 스택 주소 지정 방식이 무엇인가요?
6. 변위 주소 지정 방식에는 상대 주소 지정 방식과 베이스 레지스터 주소 지정 방식이 있는데 각각 설명해주세요.
7. 동기와 비동기의 차이점이 무엇인가요?
8. 인터럽트 서비스 루틴이 실행되면 현재 작업 중이던 정보는 어디에 저장되는가?
   - 메모리 중 스택 영역에 저장됩니다.