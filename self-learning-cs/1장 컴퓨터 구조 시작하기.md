# 컴퓨터 구조 시작하기

<br>

## 01-1: 컴퓨터 구조를 알아야 하는 이유
<hr>

- 우리는 프로그래밍 언어만 알면 실행가능한 애플리케이션을 만들 수 있습니다. 하지만 우리가 만든 애플리케이션이 어떻게 동작이 되고, 구성되는지 스스로 알 필요성이 있습니다.
- 우리기 만든 애플리케이션이 어떤 환경에서 어떻게 동작되는지 스스로 잘 알고 있어야합니다. 그래야 운영 환경에서 어떤 인스턴스를 사용할지, 어떤 용량을 사용할지 알 수 있습니다.

<br>

## 01-2: 컴퓨터 구조의 큰 그림
<hr>

### 컴퓨터가 이해하는 정보
- 컴퓨터가 이해할 수 있는 정보는 0과 1로만 구성되어 있습니다.
- 0과 1로 표현되는 정보에는 크게 두 종류가 있는데 바로 데이터와 명령어입니다.
- 컴퓨터가 이해하는 정보에는 데이터와 명령어가 있는데, 이 둘 중 컴퓨터를 실질적으로 작동시키는데 더 중요한 정보는 명령어 입니다.
  데이터는 명령어 없이 아무것도 못하는 정보 덩어리일뿐이지만 명령어는 데이터를 가공할 수 있습니다.

<br>

### 컴퓨터의 4가지 핵심 부품
- 컴퓨터의 4가지 핵심 부품은 CPU(중앙처리장치), 메모리(주기억장치), 보조기억장치, 입출력장치로 구성되어 있습니다.

![스크린샷 2023-11-29 오후 10 54 32](https://github.com/kdg0209/realizers/assets/80187200/f8e815cc-6cdd-4495-9c6b-52c852ba0b62)

<br>

### 1. 메모리(주기억창지)
- 메모리는 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품입니다.
- 컴퓨터가 빠르게 실행되기 위해서는 메모리속 명령어가 중구난방으로 되어있으면 안됩니다. 만약 중구난방으로 되어있다면 메모리속에 있는 수많은 명령어 중 내가 필요로하는 명령어를 찾기까지 많은 시간을 소요할 수도 있습니다.
  이를 위해서 저장된 값에 빠르게 접근하기 위해 주소라는 개념이 사용됩니다.

![스크린샷 2023-11-29 오후 10 55 55](https://github.com/kdg0209/realizers/assets/80187200/e32504ac-7365-4883-8328-38056b780785)

- 각각의 프로세스는 독립된 메모리 공간을 가질 수 있도록 보장해야하는데, 이러한 독립적인 메모리 공간은 프로세스별로 보호하고, 병행실행을 위해 프로세스가 메모리에 적재되는것이 필수입니다.
- 위에서 각 프로세스는 독립된 메모리 공간을 가질수 있고, 한 프로세스는 다른 프로세스의 메모리 공간을 접근해서는 안됩니다.
    - 이를 위해 메모리 공간의 보호는 CPU 하드웨어가 사용자 모드에서 만들어진 모든 주소와 레지스터를 비교함으로써 이루어지는데, 사용자 모드에서 수행되는 프로그램이 운영체제의 메모리 공간이나 다른 사용자
      프로그램의 메모리 공간에 접근하면 운영체제는 오류로 간주하고 트랩을 발생시킵니다.

#### 기준 레지스터
- 가장 작은 합법적인 메모리 주소의 값을 저장

#### 상한 레지스터
- 주어진 영역의 크기 저장

![스크린샷 2023-11-29 오후 10 55 15](https://github.com/kdg0209/realizers/assets/80187200/155791c9-efe7-4aae-b04a-9df90bc4b233)

<br>

#### 🤔 위에서 메모리는 특정 명령어에 빠르게 접근하기 위해 주소라는 개념을 사용한다고 했는데, 주소는 어떤 방식으로 할당될까?

1. 컴파일 시점 바인딩
    - 프로세스의 물리적 주소가 컴파일 시점에 정해집니다.
    - 프로세스가 메모리의 어느 위치에 들어갈지 미리 알고 있다면 컴파일러는 고정 주소를 생성할 수 있습니다.
    - 만약 주소가 변경된다면 재컴파일해야합니다.
2. 로드 시점 바인딩
    - 컴파일 시점에 알지 못한다면 재배치 가능 코드를 생성해야 합니다. 이러한 재배치 가능 코드는 메모리의 어느 위치에나 수행될 수 있는 기계 언어 코드인데 Loader가 프로세스를 메모리에 적재하는 시점에 주소를 결정하게 됩니다.
    - Loader가 프로세스를 메모리에 적재하는 시점에 주소를 결정하게 되므로 물리 주소와 논리 주소는 다르게 됩니다.
3. 실행 시점 바인딩
    - 프로세스가 실행될 때 메모리 주소를 변경하는 방법입니다.
    - 실행시점에 물리적 주소가 결졍되며, 실행 도중에도 물리적 주소를 변경할 수 있습니다.
    - 이 방법은 CPU가 주소를 참조할 때마다 address mapping table을 이용하여 바인딩을 점검합니다. 이러한 방식은 MMU라는 하드웨어 장치를 사용하여 논리 주소를 물리 주소로 변환해줍니다.

<br>

### 2. CPU(중앙처리장치)
- CPU는 컴퓨터의 두뇌입니다. CPU는 메모리에 저장된 명령어를 읽어 해석하고, 실행하는 부품입니다.
- CPU는 ALU(산술논리연산장치), 레지스터, 제어장치로 구성되어 있습니다.

<br>

### 3. 보조기억장치
- 메모리는 실행되는 프로그램의 명령어와 데이터를 저장한다고 했는데, 메모리는 가격이 비싸고, 휘발성입니다.
- 그렇기 때문에 데이터를 영구적으로 보관하기 위해서는 SSD, USB, DVD, CD같은 보조저장장치가 있어야 합니다.

<br>

### 4. 입출력장치
- 입출력장치는 마우스, 키보드, 모니터등을 말합니다.

<br>

### 💡 메인보드와 시스템 버스
- 위에서 설명한 핵심 부품은 메인보드라는 판에 연결됩니다. 메인보드는 마더보드라고도 부릅니다.
- 메인보드에 연결된 부품들은 서로 정보를 주고 받을 수 있는데, 이를 메인보드 내부에 버스라는 통로가 있기 때문입니다.
- 다양한 종류의 버스가 있는데 가장 중요한 버스는 시스템 버스입니다.
    - 시스템 버스는 주소 버스, 데이터 버스, 제어 버스로 구성되어 있습니다.
        - 주소 버스: 읽고자 하는 메모리 주소를 내보냅니다.
        - 데이터 버스: 데이터를 운반합니다.
        - 제어 버스: 제어 신호를 운반합니다.

<br> 

### 🤔 생각해볼 수 있는 질문들

1. 컴퓨터는 어떤 정보만을 이해할 수 있는가?
   - 0과 1만을 이해할 수 있다.
2. 메모리에서 주소라는 개념이 등장하는데 왜 주소라는 개념이 필요한가?
   - 주소라는 개념이 필요한 이유는 메모리에 명령어와 데이터가 중구난방으로 저장되어 있다면 CPU가 메모리에 접근할 때마다 추가적인 오버헤드가 발생합니다.
   이를 방지하기 위해서 데이터와 명령어를 정돈하여 접근할때 빠르고 효율적으로 접근하기 위해서 필요합니다.
3. 메모리에서 주소는 어떤 방법으로 생성할 수 있는가?
   - 컴파일 시점, 로드 시점, 실행 시점 방법이 있습니다.
4. 메모리에 여러 프로세스가 적재되어 있을텐데 CPU는 메모리에 접근할때 다른 프로세스의 메모리에 접근하지 않기 위해 어떻게 어떠한 방법을 사용할 수 있는가?
    - CPU가 사용자 모드에서 만들어진 모든 주소와 레지스터를 비교함으로써 다른 사용자 프로그램의 메모리 공간에 접근하지 못하도록 하고있습니다.
    - 기준 레지스터와 상한 레지스터를 사용하여 값 비교를 함으로써 방지할 수도 있습니다.
5. CPU는 대표적으로 어떤 부품으로 구성되어 있는가?
   - ALU, 제어장치, 레지스터로 구성되어 있습니다.
6. 보조저장장치와 입출력장치의 차이점이 무엇인가?
   - 데이터를 저장할 수 있냐 없냐의 차이입니다.
7. 메인보드 위에 CPU, 메모리, 보조저장장치, 입출력장치 등이 있는데 이들은 어떻게 서로 통신을 할 수 있는가?
   - 메인보드 위에 시스템 버스라는 것이 있고 버스라는 통로를 통해 서로 정보를 주고 받을 수 있습니다.
   - 시스템 버스는 크게 주소 버스. 데이터 버스. 제어 버스로 구분할 수 있습니다.
