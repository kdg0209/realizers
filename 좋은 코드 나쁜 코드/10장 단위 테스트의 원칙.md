# 단위 테스트의 원칙

<br>

## 1. 단위 테스트의 기초

#### 테스트 케이스

- 테스트의 시나리오를 의미합니다. 테스트 케이스에는 보통 3가지의 섹션으로 나뉘어져 있습니다.
- 대게 AAA 용어를 많이 사용하지만 필자는 given(주어진), when(때), then(그리고 나면) 이 용어를 더 많이 사용하는거 같다.

준비(arrange)

- 테스트 대상이 되는 클래스의 인스턴스를 생성하기 위한 사전 준비에 해당합니다. 주로 필요한 값을 세팅합니다.

실행(act)

- 테스트 대상이 되는 클래스의 특정 함수를 호출합니다.

단언(assert)

- 테스트 대상의 함수 호출의 결과값이 기대값과 동일한지 여부를 확인합니다.

<br>

## 2. 좋은 단위 테스트는 어떻게 작성할 수 있는가?

- 단위 테스트에서 문제가 발생하면 유지 관리가 굉장히 어렵고, 버그가 테스트 코드에서 발견하지 못하고 운영 환경에서 발견될 수도 있습니다. 즉 회귀 버그가 발생할 수 있습니다.

#### 훼손의 정확한 감지

- 단위 테스트의 가장 명확하고 주된 목표는 코드가 훼손되지 않았는지 확인하는 것입니다. 즉, 코드가 의도한대로 동작하며 버그가 없다는 것을 확인하는 것입니다.
- 테스트 대상 코드가 실제로 훼손된 경우에만 테스트가 실패해야합니다. 무엇보다 양치기 소년같은 테스트가 만들어져서는 안되고 `비결정적`인 테스트도 만들어져서는 안됩니다.

#### 세부 구현 사항에 독립적

- 코드에 대해 테스트 코드를 작성할 때 코드의 세부 구현 사항을 검증하는게 아니라 동작을 검증해야 합니다.
- 즉, A라는 입력값을 넣었으면 B라는 결과값에 대해 올바르게 도출되었는지를 검증해야 하는 것입니다. 여기서 A가 어떠한 로직에 의해서 데이터가 가공되고, 그 이후 어떠한 로직이 실행되고~ 이런식으로 테스트 코드를 작성하면 테스트 코드와 너무 겅하게 결합이 되므로 나중에 코드에 작은 변화가 생기면 바로 테스트 코드가 깨지게 됩니다.

👍 좋은 접근 방식

- 동작에 대해서만 테스트할 뿐 세부 구현 사항은 검증하지 않습니다. public 메서드 시그니처에 대해서만 테스트 코드를 작성합니다. private에 대해서는 검증하지 않아야 합니다. 만약 private에 검증해야 한다는 생각이 들면 상위 클래스로 도출하거나 잘 못 접근하고 있는게 아닌가 생각을 해봐야 합니다.
- 그리고 기능 변경과 리팩토링은 함께하면 좋지 않습니다. 이렇게 작업해야 각각의 목적을 달성할 수 있고 잠재적인 문제의 원인을 분리하기가 쉽습니다.

#### 잘 설명되는 실패

- 테스트가 코드에서 문제가 발생하면 어디서 문제가 발생하였고, 사유가 무엇인지 구체적으로 나타내는게 좋습니다.
- 이렇게 하기 위해서는 하나의 테스트 케이스는 한가지 사항만 검사하고 각 테스트 케이스에 서술적인 이름을 사용하는게 좋습니다. 만약 하나의 테스트 케이스에 여러가지를 검사하고자 한다면 문제가 발생했을 때 무슨 이유인지 파악하기 어려워집니다.

#### 이해 가능한 테스트 코드

- 일부 개발자들이 코드에 대한 일종의 설명서로 사용하거나 특정 코드를 어떻게 사용해야 하는지, 혹은 어떤 기능을 제공하는지 단위 테스트를 통해 알아보게 할 수 있습니다.

<br>

## 3. 테스트 더불

- 의존성을 실제로 사용하는 것에 대한 대안은 테스트 더블을 사용하는 것입니다. 테스트 더블은 의존하고 있는 객체를 시뮬레이션할 수 있도록 도와줍니다.

### 3-1. 테스트 더블을 사용해야 하는 이유

#### 테스트 단순화

- 어떤 의존성은 설정하는데 많은 노력이 필요할 수 있습니다. 예를들어 하나의 객체를 만들기 위해서는 수 많은 매개변수가 필요하거나, 하위 의존성이 있어야 객체를 만들 수 있는 경우가 많습니다. 이러한 경우 `테스트 더블`을 사용하면 테스트에만 집중할 수 있게됩니다.
- 다만 테스트 더블을 설정하는 것이 실제 의존성을 사용하는 것보다 더 복잡하고 어려운 경우도 있습니다.

#### 테스트로부터 외부 세계 보호

- 일부 의존성들은 실제 부수 효과를 발생시킵니다. 예를들어 테스트 코드를 실행시키면 실제 데이터베이스에 데이터를 저장하거나, 다른 외부 서버를 호출하는 경우가 종종 있는데 이러한 경우에는 테스트 코드와 외부 세계를 격리시켜야 합니다.

#### 외부로부터 테스트 보호

- 테스트는 항상 `결정적`이어야 합니다. 만약 외부로부터 매번 달라지는 값을 주입받으면 테스트 코드를 실행할 때마다 실패될 수 있습니다. 외부로부터의 `비결정적` 요소를 주입받으면 안됩니다.

<br>

### 3-2. 스텁

- Stub은 함수가 호출되면 미리 정해 놓은 값을 반환함으로써 함수를 시뮬레이션 합니다.
- 스텁은 테스트 대상 코드가 의존하는 코드로부터 어떠한 값을 받아야 하는 경우에 사용하기 유용합니다.
- 반환 받을 값을 미리 세팅해놓을 수 있기 때문에 테스트 역시 `결정적`이고 더 신뢰할 수 있습니다.
- 스텁을 만들어야 하는 경우에도 Mock 객체를 만들어줘야 합니다. Junit5를 사용하면 @MockBean 어노테이션으로 Mock 객체를 만들고 이후 사용하게 됩니다.

<br>

### 3-2. 목 

- Mock은 클래스나 인터페이스를 시뮬레이션하는데 멤버 함수에 대한 호출을 기록하는 것 외에는 어떠한 일도 수행하지 않습니다.

#### 💡목과 스텁은 문제가 될 수 있다

- 테스트 코드를 작성할 때 개발자는 목이 어떻게 동작할지 결정해야 하는데, 실제 의존성이 어떻게 동작하는지 이해하지 못한다면 목을 설정할 때 실수할 수 있습니다.
- 목과 스텁은 개발자가 설정한 임의의 값을 기준으로 테스트 코드를 실행시키는 것이기 때문에 실제 환경과 다소 차이가 발생하여 커버를 칠 수 없는 경우도 종종 있습니다.

<br>

### 3-3. 페이크

- 페이크는 클래스의 대체 구현체로 테스트하여 안전하게 사용할 수 있습니다. 다만 실제 의존성에 대한 코드 계약이 변경되면 페이크도 동일하게 변경해줘야 합니다.
- 코드의 작업량과 유지보수가 더 많이 발생하게 됩니다.

<br>

### 3-4. 런던 학파와 고전파

- 런던 학파는 목을 사용한 테스트는 상호작용을 테스트하는 반면, 고전파는 코드의 결과 상태와 의존성을 테스트 하는 경향이 있습니다.
- 런던 학파는 목을 사용하여 코드가 `어떻게` 하는가를 확인하고 고전파는 최종 결과가 `무엇인지` 확인하는 경향이 있습니다.

#### 런던 학파의 입장

- 목을 사용하여 행위를 검증하기 때문에 다른 테스트에 영향을 미치지 않습니다.
- 실제 의존성을 사용하기 위해서는 많은 세팅을 해야하는데, 목이나 스텁 가상의 종속성을 설정할 수 있으므로 간단해집니다.

#### 고전파의 입장

- 목은 코드가 특정 함수를 호출했는가를 확인할 뿐 그 호출이 유효한가에 대해서는 검증하지 않습니다.
- 고전파는 테스트 대상 코드의 결과값을 검증하는데 더 중점을 두기 때문에 세부 구현 사항이 변경되어도 테스트 코드에는 영향을 덜 미칩니다.



