# 추상화 계층

- 상위 수준의 문제를 해결하기 위헤서는 상위 수준의 문제를 여러 하위 수준의 문제로 쪼갠뒤에 하위 수준의 문제들을 조합하여 상위 수준의 문제를 해결해나가야 합니다.

<br>

## 1. 왜 추상화 계층을 만드는가?

- 코드 작성은 복잡한 문제를 더 작은 하위 문제로 세분화하는 작업입니다.
- 소프트웨어 엔지니어로서 문제가 엄청나게 복잡할지라도 하위 문제들을 식별하고 올바르게 추상화 계층을 만듦으로써 복잡한 문제를 다룰 수 있어야 합니다.

#### 예시

- 아래 코드는 특정 서버와 연결을 맺고, 메시지를 전달하고 연결을 닫는 과정을 나타낸것입니다.
- 상위 문제는 특정 서버에 메시지를 보낸다는 것이지만 하위 문제로는 특정 서버와 TCP/IP 연결을 맺고, 문자열을 직렬화하여 전송하고, 네트워크 패킷등 여러가지 복잡한 하위 문제들이 있을것입니다.

```java
HttpConnection connection = HttpConnection.connect("url");
connection.send("message");
connection.close();
```

<br>

#### 추상화 계층과 가독성

- 개발자가 코드베이스에 있는 모든 것을 이해하는 것은 불가능합니다. 따라서 높은 추상화 계층을 통해 이해하기 쉽고 사용하기 쉽게 구성해야 합니다.

#### 추상화 계층과 모듈화

- 추상화 계층이 하위 문제에 대한 경계를 깔끔히 나누고 세부 구현 사항이 외부로 노출되지 않도록 보장할 떄, 다른 계층이나 코드의 일부에 영향을 미치지 않고 해당 계층내에서만 영향이 번지게 됩니다.

#### 추상화 계층과 재사용성 및 일반화성

- 하위 문제에 대한 해결책이 추상화 계층으로 나뉘어진다면 해당 하위 문제에 대한 해결책을 재사용하기 쉬워집니다. 즉 하위 문제로 나뉘어진 계층을 재사용할 수 있기 때문입니다.

#### 추상화 계충과 테스트 용이성

- 추상화 계층으로 인해 하위 문제로 나뉘어졌다면 각 하위 문제들에 대해 테스트할 수 있고 그 부분만 확인하면 되기 때문입니다.

<br>

## 2. 코드의 계층

- 코드의 계층을 생성하는 방법들은 함수, 클래스, 인터페이스를 사용하는 방법이 있으며 각각에 대해 살펴봅니다.

#### 2-1. 함수

- 하나의 함수에 너무 많은 비지니스 로직이 포함된다면 각각의 비지니스 로직을 메서드 추출 기법을 통해 메서드로 분리하고 함수에서 분리한 메서드를 호출하는 방법이 가독성을 더 향상시킬 수 있습니다.
- 추출한 함수의 접근제한자를 private로 선언하였지만 테스트가 필요하다면 수준을 한 단계 높여 클래스로 만들어서 테스트를 할 수도 있습니다.
- 험수를 작게 만들고 수행하는 작업을 명확하게 한다면 코드의 가독성과 재사용성을 높일 수 있습니다.

<br>

#### 2-2. 클래스

- 단일 클래스내에 얼마나 많은 다른 개념이 들어가 있는지, 그리고 어떤 로직이 재사용이나 재구성에 적합한지에 대해 개발자가 신중하게 생각하지 않는다면 해당 클래스는 갓 클래스가 될 수 있습니다.
- 하나의 클래스는 응집력 있도록 구성하는게 좋은데 응집력이란 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지를 보여주는 척도입니다. 응집력에는 순차적 응집력과 기능적 응집력이 있습니다.

💡 순차적 응집력

- 순차적 응집력은 한 요소의 출력이 다른 요소의 입력으로 필요할 때 발생하는 것입니다.

💡 기능적 응집력

- 기능적 응집력은 몇 가지 요소들이 모여서 하나의 일을 성취하는데 기여할 때 발생합니다. 이때 하나의 일을 정의히는게 매우 주관적일 수 있습니다.

📌 갓 클래스 방지

- 갓 클래스가 되지 않도록 방지하기 위해서는 클래스를 잘게 나눈 후 합성(Composition)을 통해 조립하듯 목적을 달성해야 합니다. 합성을 사용한다면 코드가 적절히 모듈화가 되어 있고, 각 부분을 테스트할 수 있으며, 코드를 재사용할 수 있습니다.

<br>

#### 2-3. 인터페이스

- 계층 사이를 뚜렷히 구분하고 세부 구현 사항이 계층 외부에서 유출되지 않도록 하기 위해서는 인터페이스를 활용할 수 있습니다. 또한 하나의 추상화 계층에 대해 두 가지 이상의 다른 방식으로 구현을 하거나 향후 다르게 구현할 것으로 예상되는 경우 인터페이스를 정의하는게 좋습니다.

💡 모든 것을 위한 인터페이스

- 추상화 계층에 대해 한 가지 구현만 있고, 향후 다른 구현을 추가할 계획이 없더라도 여전히 인터페이스를 사용해야하는가에 대해 의문이 있을 수 있는데, 몇몇 소프트웨어 공학 철학에서는 이 상황에서도 여전히 인터페이스를 사용할 것을 권고하고 있습니다.
- 개인적으로도 다른 구현을 추가할 계획이 없더라도 인터페이스를 사용하는게 좋다고 생각합니다. 그 이유는 인터페이스를 사용함으로써 경계를 나줄 수 있고 역할과 책임에 대해 더 고민할 거리가 생기기 때문입니다. 물론 인터페이스가 필요없다고 생각하는 부분에 대해서는 굳이 인터페이스를 정의하는게 좋지는 않습니다. 이는 불필요한 복잡성을 증가시키는 꼴이됩니다.

<br>

#### 2-4. 추상화 계층은 항상 좋은가?

- 추상화 계층이 있으면 장점이 확실히 있지만 추상화 계층에는 그 만큼의 비용이 따릅니다.

📌 단점

- 반복적으로 사용되는 코드로 인해 코드의 양이 증가하게 됩니다.
- 로직을 이해하기 위해 파일이나 클래스를 따라갈 때 더 많은 노력이 필요합니다.
- 인터페이스를 사용하게 되면 컴파일 시점과 런타임 시점 구현체가 달라지기 때문에 디버깅하거나 로직을 이해하기 더 힘들 수 있습니다.

<br>

#### 💡 정리

- 코드베이스에 의미 있는 추상화 계층이 없으면 전혀 관리할 수 없는 코드가 됩니다. 만약 추상화 계층이 있더라도 각 계층이 너무 크다면 쪼개져야할 여러 추상화가 한 계층으로 병합되어 결국 모듈화되지 않고, 재사용할 수 없으며, 가독성이 낮은 코드가 됩니다.
반면에 추상화 계층을 너무 쪼갯더라면 단일 계층으로 만들어도 될 것을 둘로 분해한 것이고, 이것은 복잡성을 초래할 수 있습니다.
하지만 일반적으로 너무 많은 일을 하는 계층은 너무 적은 일을 하는 계층보다 더 문제가 될 수 있습니다. 따라서 어떤 것이 나을지 확실하지 않다면 너무 큰 계층을 활용하는 것보다는 계층을 쪼개는 것이 더 나을 수 있습니다.

