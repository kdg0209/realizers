# 계약 설계

- 계약은 클래스가 사전 조건으로 무엇을 요구해야 하는지, 클래스는 사후 조건으로 무엇을 제공 해야하는지, 불변식은 클래스에 대해 항상 무엇을 유지하도록 해야하는지를 명확하게 설립합니다.

<br>

## 1. 사전 조건과 사후 조건

#### 상황

- TaxCalculator 클래스의 calculateTax() 메서드는 매개변수의 값이 양수일 때만 세금을 계산할 수 있으며, 반환값은 항상 양수입니다.

#### 예제 코드

- 아래와 같은 클래스가 있다고 가정했을 때 사전 조건과 사후 조건을 if문을 통해 검증하고 있습니다.

```java
public class TaxCalculator {
    
    public double calculateTax(double value) {
        
        // 사전 조건
        if (value < 0) {
            throw new IllegalArgumentException("value is not null");
        }
        
        // 비지니스 로직 수행
        double result = 0;
        
        // 사후 조건
        if (result < 0) {
            throw new IllegalStateException("결과는 0이하일 수 없습니다.");
        }
        
        return result;
    }
}
```

<br>

#### 1-1. 단언 키워드

- if문을 대신해 assert 명령어를 사용할 수 있으며, assert 명령어는 JVM 매개변수를 통해 비활성화할 수 있기 때문에 항상 실행되지 않습니다. 만약 운영환경이라면 해당 명령어를 비활성화할 수 있습니다.
- assert 명령어는 항상 일반적인 오류인 AssertionError를 던집니다.

#### 1-2. 강한 조건과 약한 조건

- 사전, 사후 조건을 정의할 때 중요한 점은 조건의 강도를 어느 정도로 해야하는 가입니다.

🧐 약한 조건인 경우

- 약한 조건을 사용하면 클라이언트는 해당 메서드를 쉽게 호출할 수 있습니다. 하지만 쉽게 해버리면 헤당 메서드로 인해 버그가 발생할 수 있는 지점이 넓어질 수 있다고 생각합니다.

```java
public class TaxCalculator {

    public double calculateTax(double value) {

        // 약한 사전 조건
        if (value < 0) {
            return 0;
        }

        // 비지니스 로직 수행
        double result = 0;

        // 약한 사후 조건
        if (result < 0) {
            return 0;
        }

        return result;
    }
}
```

<br>

## 2. 불변식

- 불변식이란 클래스가 항상 무엇인가를 유지하도록 해야하는 것입니다.
- 불변식은 사전, 사후 모두의 경우에서 유지되어야 합니다.

<br>

## 3. 계약 변경과 리스코프 치환 원칙

- 가장 이상적인 경우는 클래스나 메서드의 계약을 정의한 후 이를 변경하지 않는 것이지만, 실무에서는 계속하여 변경됩니다. 따라서 우리는 변경으로 인한 영향을 파악할 수 있어야합니다.
- 변경으로 인한 영향을 가장 파악하기 쉬운 방법은 변경이 일어난 클래스를 확인하는게 아니라, 변경된 클래스를 사용하는 다른 모든 클래스를 살펴보는 것입니다.

#### 🧐 기존에서 사전 조건이 강화된다면?

- 만약 TaxCalculator 클래스의 calculateTax 메서드의 사전 조건이 강화된다면 어떻게 될까요? 예를들어 value는 100이상만 가능하다라고 사전 조건이 강화된다면 해당 메서드를 호출하고 있는 클라이언트의 부담은 더 증가되니 확인해야할 곳이 더 많아지게 됩니다.

#### 🧐 기존에서 사전 조건이 약화된다면?

- 만약 TaxCalculator 클래스의 calculateTax 메서드의 사전 조건이 약화된다면 어떻게 될까요? 예를들어 value는 -100까지 받을 수 있다고 가정한다면 클라이언트의 부담감을 줄어들겠죠?

#### 3-1 상속과 계약

- 상속 관계에서 계약이 있으면 어떻게 될까? 우선 상속 관계에서는 리스코프 치환 원칙이 준수되어야 합니다. 그렇게되기 위해서는 시스템에 기대하는 동작을 깨트리지 않고 자식 클래스를 부모 클래스로 치환할 수 있어야합니다.
- 즉, 자식 클래스의 사전 조건은 부모 클래스의 사전 조건과 같거나 더 약해야하며, 사후 조건은 부모 쿨래스와 같거나 더 강해야합니다.

<br>

## 4. 계약에 의한 설계가 테스트와 어떤 관련이 있는가?

1. 사전, 사후 조건으로 인해 버그를 일찍 발견할 수 있습니다.
2. 사전, 사후, 불변식은 개발자에게 테스트 대상을 제공합니다.
3. 명시적인 계약은 클라이언트의 삶을 편안하게 해줍니다. 클라이언트가 사전 조건이 유지되도록 메서드를 사용하고, 사후 조건으로 인해 조건의 안정성이 더 증가되며, 약속한 계약을 더 안전히 수행할 수 있습니다.

<br>

## 5. 협업에서의 계약에 의한 설계

#### 5-1. 입력 유효성 검사인가? 계약인가? 아니면 둘 다인가?

- 개발하다보면 사용자 입력에 대해 유효성 검사를 하곤합니다. 근데 입력 유효성 검사를 하면 어차피 값이 유효한지를 알고 있기 때문에 사전, 사후 조건을 할 필요가 있을까? 라는 의문이 들긴합니다. 이러한 내용에 대해 살펴보겠습니다.

#### 🧐 유효성 검사와 계약의 차이가 무엇인가?

- 유효성 검사란 우선 사용자로부터 들어올 수 있는 불량 데이터나 유효하지 않은 데이터가 시스템에 침투되는 것을 방지하는 것입니다.
- 계약이란 클래스 간의 의사소통이 문제없이 일어날 수 있도록 하는 것입니다.
- 즉! 유효성 검사와 계약의 목적은 서로 다르기 때문에 결국 둘 다 이루어져야합니다.

<br>

### 정리

- 유효성 검사와 계약을 둘 다 수행해야하나? 라는 의문이 있었는데, 책을 통해 이 둘은 서로 다른 목적이 있으므로 결국 둘 다 이루어져야한다는 것을 알게되었다.
- 상속 관계에서 사전, 사후 조건에 대한 설계를 할 때 리스코프 치환 원칙을 어떻게하면 준수할 수 있을까 헷깔렸는데 정리가 된거 같다.



