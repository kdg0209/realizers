# 테스트 더블과 모의 객체

- 우리는 단위 테스트를 작성할 때 특정 클래스의 속성이 잘 변경되었는지, 테스트 대상 메서드를 호출한 후 클래스의 속성이 기대하는 값으로 변경되었는지 확인하였습니다.
- 하지만 어떤 클래스가 작업을 수행할 때 다른 클래스에 의존하고 있는 경우에 어떻게 해야할까요? 의존하고 있는 클래스가 일반적인 도메인 클래스라면 문제가되지 않지만 외부 연동이 필요한 클래스라면 문제가 발생합니다. 따라서 이번 장에서는 이러한 문제를 어떻게 해결할 것인가에 대해 살펴봅니다.

#### 예시 상황

- MemberCreateService가 있다고 가정합시다. MemberCreateService는 사용자로부터 입력 값을 받아 Member 도메인 객체를 생성하고 생성된 Member 도메인 객체를 데이터베이스에 저장해야합니다. 이때 MemberCreateService 클래스가 직접적으로 데이터베이스에 의존하고 있다면 
MemberCreateService 클래스를 테스트하기 위해서는 데이터베이스를 설정하는 작업들이 필요로하게 됩니다. 분명 이 작업은 도움이 될 수도 있지만 간단한 테스트에 비해 비용이 너무 많이 듭니다.
- 또한 MemberCreateService 클래스의 책임은 Member 객체가 올바르게 데이터베이스에 저장되었는가? 이지 쿼리가 제대로 수행되었는지의 책임은 데이터베이스를 구성하고 있는 클래스의 책임입니다. MemberCreateService는 직접적으로 의존하고 있는 데이터베이스 객체를 간접적으로 의존하게끔 변경하고 테스트 대역을 사용하여 문제를 해결할 수 있습니다.

#### 👍 테스트 대역 사용시 무엇이 좋아지나?

- 시뮬레이션이 빨라집니다. 빨리 테스트를 할 수 있고, 피드백을 받을 수 있고, 쉽게 작업할 수 있습니다.
- 테스트 대역 객체에게 무엇을 해야할지 쉽게 알려줄 수 있습니다. 즉 개발자에게 제어권이 생깁니다.

<br>

## 1. 더미, 페이크, 스텁, Mock, 스파이

#### 더미

- 더미는 아무런 동작을 하지 않는 객체입니다.
- 더미의 역할은 오롯이 코드가 정상적으로 돌아가게끔 하기 위한 역할입니다.

#### 페이크

- 페이크는 자체적인 논리를 가지고 있습니다.
- Stub을 사용하면 클래스가 증가되는데 페이크를 사용함으로써 클래스가 증가되는 것을 방지할 수 있습니다.
- 예를들어 데이터베이스 대신 배열 목록을 사용하는 페이크를 만들 수 있습니다.

#### 스텁

- 스텁은 하드 코딩으로 미리 준비한 값을 반환하는 것입니다.

#### Mock

- 메서드가 호출되었는지 여부를 검증하는 역할을 수행합니다.

#### 스파이

- 실제 객체 대신 사용되며 실제 객체였다면 어떤 메서드가 호출되고, 이벤트가 발생했는지 등을 감시하고 기록합니다.

<br>

## 2. Mock 프레임워크에 대한 소개

### 2-1. 의존성 모의 객체 사용하기

- 아래 예제 코드는 회원을 데이터베이스에 저장하는 것입니다. 이때 회원의 아이디가 중복된다면 예외가 발생합니다. 회원이 정상적으로 데이터베이스에 등록이 되었다면 이메일과 알림톡으로 회원가입 축하에 대한 안내문구가 전송됩니다.
- 아래 예제 코드를 테스트하기 위해서 데이터베이스 연동과 메일에 대한 연동, 알림톡에 대한 연동이 필요로 합니다. 회원가입을 하기 위한 테스트 코드를 작성하는데 사전 준비를 너무 많이해야하며 비용이 너무 큽니다. 또한 테스트시 실제로 사용자에게 메일이나 알림톡이 발송된다면 문제가 발생할 여지가 있습니다.
 
```java
@Service
@Transactional
@RequiredArgsConstructor
public class MemberCreateService {

    private final MemberDao memberDao;
    private final MailerService mailerService;
    private final AlimTalkService alimTalkService;

    public MemberCreateResponse create(MemberCreateCommand command) {
        var duplicatedMemberId = memberDao.isDuplicatedMemberId(command.memberId());

        if (duplicatedMemberId) {
            throw new IllegalArgumentException("이미 등록된 아이디입니다.");
        }

        var member = Member.builder()
                .memberId(command.memberId())
                .password(command.password())
                .name(command.name())
                .email(command.email())
                .phone(command.phone())
                .build();

        memberDao.save(member);
        mailerService.send(member.getEmail());
        alimTalkService.send(member.getPhone());

        return new MemberCreateResponse(member.getId());
    }
}
```

<br>

#### Mock 사용 방법

- 아래 예제 코드는 mockito 라이브러리를 사용해서 테스트 코드를 작성하였습니다.

```java
class MemberCreateServiceTest {

    @Test
    void 중복된_사용자_아이디가_없는_경우_정상적으로_사용자를_등록할_수_있다() {

        // mock
        MemberDao memberDao = mock(MemberDao.class);
        MailerService mailerService = mock(MailerService.class);
        AlimTalkService alimTalkService = mock(AlimTalkService.class);
        MemberCreateService memberCreateService = new MemberCreateService(memberDao, mailerService, alimTalkService);

        // given
        MemberCreateRequest request = new MemberCreateRequest("test01", "123456", "홍길동", "test@naver.com", "010-1234-5678");

        when(memberDao.isDuplicatedMemberId(anyString())).thenReturn(false);

        // when
        memberCreateService.create(request.toCommand());

        // then
        verify(memberDao, times(1)).save(any());
        verify(mailerService, times(1)).send(anyString());
        verify(alimTalkService, times(1)).send(anyString());
    }
}
```























