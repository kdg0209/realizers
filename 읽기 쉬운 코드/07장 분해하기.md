# 분해하기

<br>

## 1. 코드의 부패

- 코드의 부패는 사소한 것으로 인해 시작되고, 코드 전반의 품질에 관심을 기울이지 않을 때 코드는 부패하기 시작합니다. 깨진 창문 이론도 코드 부패가 시작되는 시작점이라 할 수 있을 거 같습니다.

### 임계값

- 임계값을 사용해서 코드가 부패하지 않도록 방지할 수 있습니다. 코드의 순환 복잡도를 7이라는 임계치로 설정을 하고 7을 넘으면 문제가 있다고 판단을 하는 것입니다.
- 임계값을 설정하는게 오히려 개발 생상성에 방해가 될 요인이 될 수도 있습니다. 하지만 이러한 임계값을 준수하지 않는다면 코드는 점차 부패하기 시작하고, 깨진 창문 이론처럼 될 가능성이 높아집니다. 따라서 임계값을 설정할 때 굳이 7이 아니라 9, 10 이렇게 느슨하게 가져가도 될거 같습니다.
우리의 목표는 코드의 부패를 방지하고 지속가능한 소프트웨어를 개발하는 것이니까요.

<br>

### 순환복잡도

- 코드 품질 측정 방법 중 하나의 방법입니다.
- 순환복잡도를 측정하는 방법은 우선 최소 순환 복잡도는 1입니다. 1에서 시작해서 몇 개의 if문이나 for문을 거치는지 세어보면 됩니다.

<br>

## 2. 머리에 잘 들어오는 코드

### 응집

- 코드를 볼 때 뇌는 에뮬레이터를 작동시키고, 코드를 실행시켰을 때 어떻게 동작할지 해석해 나갑니다. 이때 추적해야하는 코드가 많을수록 더 이상 코드를 이해하기 어려워지게 됩니다.
- 아래와 같은 간단한 코드가 있을 때 유효성 검증 로직과 알림 발송 부분을 create 메서드 내부에서 수행할 수도 있지만 해당 로직을 메서드 추출 기법을 통해 추출을 하였습니다.

#### 🧐 메서드 추출 기법을 왜 사용했는가?

- 추상화 레벨을 맞춥니다.
- 유효성 검증을 하는 방법이나 사용자에게 알림 또는 이메일을 발송하는 로직은 속도가 다르게 변합니다. 따라서 켄트 벡님의 말씀처럼 추상화를 하여 작업을 할 수 있습니다.

```text
- 켄트 벡 -
같은 속도로 변하는 것들은 함께 있어야 하며, 다른 속도로 변하는 것들은 서로 떨어져 있어야 합니다.
```

```java
public record PostCreateRequest(String email, String title, String contents) {

}

public class PostCreateService {

	public void create(PostCreateRequest request) {
		validate(request);

		// DB 저장
		...

		// 알림 발송
		sendToClient();
	}

	private void validate(PostCreateRequest request) {
		if (이메일 유효성 검증) {
			...
		}
		if (타이틀 유효성 검증) {
			...
		}
		if (본문 내용 유효성 검증)
	}
	
	private void sendToClient() {
		
		// 알림이나 이메일로 발송
	}
}
```

<br>

### 프랙탈 구조

- 여기서 말하는 프랙탈 구조는 제가 느끼기에 세부 구현 사항은 캡슐화를 통해 숨기고, 인터페이스를 통해 추상화를 높인 인터페이스 기반 프로그래밍이 아닌가? 라는 생각이 듭니다.
- 프랙탈 구조를 사용함으로써 추상화 레벨에서 생각을 하면 순환복잡도를 낮출 수 있다는 의미라고 생각이 듭니다.

<img width="1032" alt="스크린샷 2024-06-27 오전 11 56 40" src="https://github.com/kdg0209/realizers/assets/80187200/55de0c39-a704-47b6-9695-fc41e6d79525">

<br><br>

## 3. 결론

- 코드베이스가 처음부터 레거시 코드로 태어나는 것은 아닙니다. 시간이 지남에 따라 퇴화하고, 우리는 순환복잡도와 같은 방법을 사용하여 코드가 썩지 않도록 적극적으로 막아야 합니다. 

<br><br>

#### 좋은 글

```text
- 151p [켄트 벡]
같은 속도로 변화하는 것들은 함께 있어야 하며, 다른 속도로 변화하는 것들은 서로 떨어져 있어야 합니다.

- 151p
클래스의 인스턴스 필드들이 어떻게 사용되고 있는지 고려해보세요.
모든 메서드가 클래스의 모든 필드를 사용하는 경우를 최대 응집력이라 하고, 클래스에 있는 각각의 필드들이 각각의 메서드에서 개별적으로 사용하는 경우를 최소 응집력이라 합니다.

- 153p [로버트 마틴]
추상화는 무관한 것을 제거하고, 본질적인 것을 강조하는 것입니다.
```
