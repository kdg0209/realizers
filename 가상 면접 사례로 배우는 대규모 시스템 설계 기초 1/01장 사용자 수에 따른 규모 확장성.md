# 사용자 수에 따른 규모 확장성

<br>

## 단일 서버 

- 단일 서버는 하나의 인스턴스에 데이터베이스, 애플리케이션을 실행시킬 서버(백엔드), 사용자에게 보여질 내용(프론트), 캐시 등이 하나의 인스턴스로 구성되어 있습니다.

<br>

## 데이터 베이스

- 사용자가 증가함에 따라 서버와 데이터베이스를 분리할 필요가 생깁니다. 그리고 만들고자하는 애플리케이션에 적합한 데이터베이스를 선택해야합니다.

#### 어떤 데이터베이스를 사용할 것인가?

- 일반적인 상황에서는 보통 RDBMS를 선택할 것이고, 특정 요구사항을 만족해야할 때 No-SQL를 사용할 수 있는데 그 조건을 살펴보겠습니다.
  - 아주 낮은 latency가 요구되는 경우
  - 데이터가 비정형인 경우
  - 데이터를 직렬화 및 역직렬화할 수 있기만 하면 되는 경우
  - 아주 많은 양의 데이터를 저장할 필요가 없는 경우 (시대가 달라진만큼 아주 많은 양의 데이터를 저장하기도 합니다.)
  - 다만 주의점으로 No-SQL은 조인 연산을 지원하지 않으므로 중복 데이터가 많이 발생할 수 있습니다.(역정규화)

<br>

## 수직적 규모 확장 Vs 수평적 규모 확장

#### 수직적 규모 확장

- 수직적 규모 확장이란 scale up이라고도 불리며, 보통 더 좋은 CPU, 더 좋은 RAM을 추가하는 행위입니다.
- 수직적 규모 확장은 하나의 서버에 CPU나 메모리를 무한대로 증설할 수 없습니다. 또한 수평적 규모 확장보다 비용이 커집니다.

#### 수평적 규모 확장

- 수평적 규모 확장이란 scale out이라고도 불리며, 기존 서버를 N개 이상 두어 수평적으로 확장하는 행위입니다.
- 수평적 규모 확장은 장애에 대한 자동복구(failover)나 다중화 방안을 제시하지 않습니다. 따라서 이에 대비해야 합니다.
- 수평적 규모 확장시 실제 애플리케이션이 로딩되어 사용자의 요청을 받기까지 다소 시간이 소요될 수 있습니다.

#### 로드밸런서 

- 로드밸런서의 역할은 사용자들의 요청을 각 서버에게 고르게 분산시키는 역할을 수행합니다.
- 로드밸런서를 사용하면 사용자는 Public IP로 접근을 하고, 로드밸런서가 해당 요청을 실제 비지니스 로직을 수행할 서버에게 요청을 보내개 됩니다. 이렇게 로드밸런서는 프록시의 역할도 수행하며, 보안적으로도 사용될 수 있습니다.

<img width="1032" alt="스크린샷 2024-06-09 오후 12 48 42" src="https://github.com/kdg0209/realizers/assets/80187200/504ec507-7fa5-44ef-b224-2b4cee861d96">

<br>

#### 데이터베이스 다중화

- 데이터베이스 다중화란 master-slave 관계를 형성하여 데이터의 원본은 master에 사본은 slave에 저장하는 방식입니다.
- 쓰기 연산은 master에만 지원을 하고, slave는 master로부터 사본을 받아 읽기 연산만 지원을 합니다.

#### 💡 데이터베이스 다중화 어떤점이 좋을까?

- 쓰기 연산은 Master 서버에서만 수행하고 읽기 연산은 Slave 서버에서만 수행함으로써 요청을 분산시켜 성능을 높일 수 있습니다.
- 데이터가 한 곳에만 있는게 아니라 데이터를 지역적으로 떨어진 여러곳에 다중화시켜 놓을 수 있기때문에 데이터베이스가 파괴되더라도 데이터를 복구시킬 수 있습니다.
- 하나의 데이터베이스에 장애가 생겨 다른 서버의 데이터를 가져와 사용할수 있기때문에 가용성이 높아집니다.

#### 🤔 데이터베이스 다중화 어떤점을 고려해야할까?

- Master 서버에서 Slave 서버로 데이터를 복제시켜야하는데 Aws Aurora Mysql 같은 경우 조금의 지연이 있습니다. 따라서 지연이 없어야하는 경우 Master 서버에 쓰기 연산과 읽기 연산을 동시에 수행해야할 경우도 있습니다.
- Master 서버에 문제가 발생하면 Slave 서버 중 하나가 Master 서버로 승격이 되는데, 데이터 불일치가 발생할 수 있습니다. 따라서 Master 서버도 다중화를 하여 안정성을 높여야하는 복잡성이 있습니다.

<img width="1035" alt="스크린샷 2024-06-09 오후 1 00 00" src="https://github.com/kdg0209/realizers/assets/80187200/479bbf92-9f77-433e-9bc2-b34386f0a36c">

<br><br>

## 캐시

- 캐시란 비싼 연산의 결과나 자주 조회되는 데이터를 메모리에 두고, 요청이 왔을때 보다 빨리 처리될 수 있도록 하는 저장소입니다.

#### 🤔 캐시 사용시 주의점

- 데이터 갱신은 자주 발생하지 않지만 자주 참조된다면 캐시를 적용해도 좋습니다.
- 데이터가 영구적으로 보관할 필요가 없는 경우 적절합니다.
- 캐시의 만료 정책을 항상 설정해야합니다. 만료 기한이 너무 짧으면 DB를 자주 접근하게 되므로 성능이 떨어질 수 있고, 만료 기한이 길면 데이터 싱크 문제가 발생할 수 있습니다.
- 캐시 서버가 단일이라면 단일 장애 지점이 될 수 있으므로 전체 시스템이 멈출 수 있습니다.
- 메모리가 가득 차버리면 어떤 데이터를 방출할 것인가에 대한 정책을 정의해야합니다.

#### 캐시 계층

<img width="1044" alt="스크린샷 2024-06-09 오후 1 23 28" src="https://github.com/kdg0209/realizers/assets/80187200/fefdf587-7c97-4f54-a6ac-d0659816a888">

<br><br>

## 콘텐츠 전송 네트워크(CDN)

- CDN은 정적 콘텐츠를 전송하는데 쓰이는, 지리적으로 분산된 서버의 네트워크로서 이미지, 비디오, CSS, JavaScript 파일을 캐싱할 수 있습니다.

#### 🤔 CDN 사용시 주의점

- 비용: CDN으로 들어가고 나가는 데이터 전송 양에 따라 요금이 발생하므로 자주 사용되지 않는 데이터는 캐싱하는 것이 이득이 아니므로 제외시킵니다.
- 만료시간 설정: 만료시간이 짧으면 원본 서버에 자주 접근해야하므로 latency가 증가하고, 너무 길면 불일치성이 증가합니다.
- CDN 장애에 대한 대처: CDN 장애 발생시 장애 대응

<br>

## 무상태 웹 계층



















