# 사용자 수에 따른 규모 확장성

<br>

## 단일 서버 

- 단일 서버는 하나의 인스턴스에 데이터베이스, 애플리케이션을 실행시킬 서버(백엔드), 사용자에게 보여질 내용(프론트), 캐시 등이 하나의 인스턴스로 구성되어 있습니다.

<br>

## 데이터 베이스

- 사용자가 증가함에 따라 서버와 데이터베이스를 분리할 필요가 생깁니다. 그리고 만들고자하는 애플리케이션에 적합한 데이터베이스를 선택해야합니다.

#### 어떤 데이터베이스를 사용할 것인가?

- 일반적인 상황에서는 보통 RDBMS를 선택할 것이고, 특정 요구사항을 만족해야할 때 No-SQL를 사용할 수 있는데 그 조건을 살펴보겠습니다.
  - 아주 낮은 latency가 요구되는 경우
  - 데이터가 비정형인 경우
  - 데이터를 직렬화 및 역직렬화할 수 있기만 하면 되는 경우
  - 아주 많은 양의 데이터를 저장할 필요가 없는 경우 (시대가 달라진만큼 아주 많은 양의 데이터를 저장하기도 합니다.)
  - 다만 주의점으로 No-SQL은 조인 연산을 지원하지 않으므로 중복 데이터가 많이 발생할 수 있습니다.(역정규화)

<br>

## 수직적 규모 확장 Vs 수평적 규모 확장

#### 수직적 규모 확장

- 수직적 규모 확장이란 scale up이라고도 불리며, 보통 더 좋은 CPU, 더 좋은 RAM을 추가하는 행위입니다.
- 수직적 규모 확장은 하나의 서버에 CPU나 메모리를 무한대로 증설할 수 없습니다. 또한 수평적 규모 확장보다 비용이 커집니다.

#### 수평적 규모 확장

- 수평적 규모 확장이란 scale out이라고도 불리며, 기존 서버를 N개 이상 두어 수평적으로 확장하는 행위입니다.
- 수평적 규모 확장은 장애에 대한 자동복구(failover)나 다중화 방안을 제시하지 않습니다. 따라서 이에 대비해야 합니다.
- 수평적 규모 확장시 실제 애플리케이션이 로딩되어 사용자의 요청을 받기까지 다소 시간이 소요될 수 있습니다.

#### 로드밸런서 

- 로드밸런서의 역할은 사용자들의 요청을 각 서버에게 고르게 분산시키는 역할을 수행합니다.
- 로드밸런서를 사용하면 사용자는 Public IP로 접근을 하고, 로드밸런서가 해당 요청을 실제 비지니스 로직을 수행할 서버에게 요청을 보내개 됩니다. 이렇게 로드밸런서는 프록시의 역할도 수행하며, 보안적으로도 사용될 수 있습니다.

<img width="1032" alt="스크린샷 2024-06-09 오후 12 48 42" src="https://github.com/kdg0209/realizers/assets/80187200/504ec507-7fa5-44ef-b224-2b4cee861d96">

<br>

#### 데이터베이스 다중화

- 데이터베이스 다중화란 master-slave 관계를 형성하여 데이터의 원본은 master에 사본은 slave에 저장하는 방식입니다.
- 쓰기 연산은 master에만 지원을 하고, slave는 master로부터 사본을 받아 읽기 연산만 지원을 합니다.

#### 💡 데이터베이스 다중화 어떤점이 좋을까?

- 쓰기 연산은 Master 서버에서만 수행하고 읽기 연산은 Slave 서버에서만 수행함으로써 요청을 분산시켜 성능을 높일 수 있습니다.
- 데이터가 한 곳에만 있는게 아니라 데이터를 지역적으로 떨어진 여러곳에 다중화시켜 놓을 수 있기때문에 데이터베이스가 파괴되더라도 데이터를 복구시킬 수 있습니다.
- 하나의 데이터베이스에 장애가 생겨 다른 서버의 데이터를 가져와 사용할수 있기때문에 가용성이 높아집니다.

#### 🤔 데이터베이스 다중화 어떤점을 고려해야할까?

- Master 서버에서 Slave 서버로 데이터를 복제시켜야하는데 Aws Aurora Mysql 같은 경우 조금의 지연이 있습니다. 따라서 지연이 없어야하는 경우 Master 서버에 쓰기 연산과 읽기 연산을 동시에 수행해야할 경우도 있습니다.
- Master 서버에 문제가 발생하면 Slave 서버 중 하나가 Master 서버로 승격이 되는데, 데이터 불일치가 발생할 수 있습니다. 따라서 Master 서버도 다중화를 하여 안정성을 높여야하는 복잡성이 있습니다.

<img width="1035" alt="스크린샷 2024-06-09 오후 1 00 00" src="https://github.com/kdg0209/realizers/assets/80187200/479bbf92-9f77-433e-9bc2-b34386f0a36c">

<br><br>

## 캐시

- 캐시란 비싼 연산의 결과나 자주 조회되는 데이터를 메모리에 두고, 요청이 왔을때 보다 빨리 처리될 수 있도록 하는 저장소입니다.

#### 🤔 캐시 사용시 주의점

- 데이터 갱신은 자주 발생하지 않지만 자주 참조된다면 캐시를 적용해도 좋습니다.
- 데이터가 영구적으로 보관할 필요가 없는 경우 적절합니다.
- 캐시의 만료 정책을 항상 설정해야합니다. 만료 기한이 너무 짧으면 DB를 자주 접근하게 되므로 성능이 떨어질 수 있고, 만료 기한이 길면 데이터 싱크 문제가 발생할 수 있습니다.
- 캐시 서버가 단일이라면 단일 장애 지점이 될 수 있으므로 전체 시스템이 멈출 수 있습니다.
- 메모리가 가득 차버리면 어떤 데이터를 방출할 것인가에 대한 정책을 정의해야합니다.

#### 캐시 계층

<img width="1044" alt="스크린샷 2024-06-09 오후 1 23 28" src="https://github.com/kdg0209/realizers/assets/80187200/fefdf587-7c97-4f54-a6ac-d0659816a888">

<br><br>

## 콘텐츠 전송 네트워크(CDN)

- CDN은 정적 콘텐츠를 전송하는데 쓰이는, 지리적으로 분산된 서버의 네트워크로서 이미지, 비디오, CSS, JavaScript 파일을 캐싱할 수 있습니다.

#### 🤔 CDN 사용시 주의점

- 비용: CDN으로 들어가고 나가는 데이터 전송 양에 따라 요금이 발생하므로 자주 사용되지 않는 데이터는 캐싱하는 것이 이득이 아니므로 제외시킵니다.
- 만료시간 설정: 만료시간이 짧으면 원본 서버에 자주 접근해야하므로 latency가 증가하고, 너무 길면 불일치성이 증가합니다.
- CDN 장애에 대한 대처: CDN 장애 발생시 장애 대응

<br>

## 무상태 웹 계층

#### 상태 정보 의존적인 아키텍처

- 아래 그림은 클라이언트 A의 요청은 반드시 서버1로 전달되어야하며, 클라이언트 B의 요청은 반드시 서버2로 전달되어야 합니다. 대부분의 로드밸런서는 이를 해결하기 위해 sticky sesstion 이라는 기능을 지원하여 문제를 해결할 수 있지만 서버가 새롭게 증설된다던가, 제거되어야할 때 복잡해지는 문제가 발생합니다.

<img width="1032" alt="스크린샷 2024-06-09 오후 1 48 36" src="https://github.com/kdg0209/realizers/assets/80187200/cb7a6a5c-c8ef-48bf-9fc6-384cde6e3145">

<br>

#### 무상태 아키텍처

- 아래 그림처럼 모든 클라이언트의 정보는 세션 저장소라는 보관소에 저장을 하면 로드밸런서의 요청을 고정적인 서버로 보낼 필요가 없게되고, 새로운 서버를 추가하거나 제거할 때 복잡성을 낮출 수 있습니다.

<img width="1032" alt="스크린샷 2024-06-09 오후 1 49 11" src="https://github.com/kdg0209/realizers/assets/80187200/40c43d0d-8239-42e7-8338-f545d446666a">

<br><br>

## 데이터 센터

- 두 개 이상의 데이터 선태를 사용하여 장애가 없는 상황에서는 사용자는 가장 가까운 데이터 센터로 안내되고, 이 절차는 지리적 라우팅이라고 부릅니다.

## 메시지 큐

- 메시지 큐는 발행자가 메시지를 만들어 큐에 메시지를 보내 저장하면 소비자가 해당 메시지를 소비하는 아키텍처입니다.
- 메시지 큐를 사용하면 서버 간 느슨한 결합을 통해 확장이 가능하고, 비동기로 메시지를 수신할 수 있습니다. 다만 시스템이 복잡해지고, 하나의 트랜잭션으로 처리되어야하는 경우 처리하기 까다롭습니다.

## 로그, 메트릭 그리고 자동화

- 로그, 메트릭을 사용하여 애플리케이션이 문제가 발생하기 전 사전에 문제를 파악하여 장애를 대비할 수 있습니다.
- 로그
  - 에러 로그를 모니터링하는 것은 중요합니다.
  - 에러 로그는 서버 단위로 모니터링할 수도 있지만, 로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하게 검색하고 조회할 수 있습니다.
- 메트릭
  - 메트릭을 잘 수집하면 사업 현황에 관한 유용한 정보를 얻을 수 있습니다.
  - CPU, 메모리, 디스크 I/Od에 관한 메트릭 정보를 수집하여 문제를 사전에 파악할 수 있습니다.
 
## 데이터베이스의 규모 확장

#### 수직적 확장

- scale up이라고도 불리며, 기존 서버에 더 많은 자원을 할당하는 방법입니다.
- 하드웨어 증설은 무한정할 수 없으므로 한 대의 서버로는 감당하기 어려운 시점이 옵니다.
- 단일 장애 지점으로 인한 위험성이 증가합니다.
- 비용이 많이 듭니다.

#### 수평적 확장

- 데이터베이스의 수평적 확장은 샤딩이라고도 부르는데, 더 많은 서버를 추가함으로써 성능을 향샹시킬 수 있습니다.
- 샤딩은 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술을 말합니다. 모든 샤드는 같은 스키마를 사용하지만 샤드에 보관되는 데이터 사이에는 중복이 없습니다.

#### 🤔 샤딩 전략시 고려할 점

- 가장 중요한 것은 샤딩 키를 어떻게 정하느냐 입니다.
- 샤딩 키는 파티션 키라고도 부르는데, 데이터가 어떻게 분산될지 정하는 하나 이상의 칼럼으로 구성됩니다.

#### 데이터의 재 샤딩

- 재 샤딩은 다음과 같은 경우에 필요하는데, 데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려운 경우 또는 샤드 간 데이터 분포도가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 큰 경우에 재 샤딩을 진행해야 하는데 이때 샤드 키를 계산하는 함수를 변경하고 데이터를 재배치해야합니다. 이때 안정 해시 기법을 사용할 수 있습니다.

#### 유명인사 문제

- 핫스팟 키 문제라고도 부르는데, 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제입니다. 이 문제를 해결하기 위해서는 유명인사를 각각 샤드 하나씩 할당해야할 수도 있고, 심지어 더 잘게 쪼개야할 때도 있습니다.

#### 조인과 비정규화

- 하나의 데이터베이스를 여러 샤드 서버로 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기가 힘들어지는데, 이를 해결하기 위해서는 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 합니다.


