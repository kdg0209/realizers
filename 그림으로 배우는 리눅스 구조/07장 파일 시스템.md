# 파일 시스템

- 리눅스 파일 시스템은 각 파일을 `디렉토리`라고 하는 특수한 파일을 사용해 분류합니다. `디렉토리`가 다르다면 동일한 파일명을 사용할 수 있습니다. 또한, 디렉토리 내부에 또 다른 디렉토리를 만들어 트리 형태로 관리할 수 있습니다.

#### 🧐 파일 시스템이 필요한 이유

- 파일 시스템이 존재하지 않으면 데이터를 디스크에 저장할 때 어떤 위치에 저장할지 직접 정해야하며, 저장할 때 다른 데이터를 훼손하지 않도록 관리도 필요합니다. 또한 나중에 다시 읽어 오기 위해서는 어느 위치에 파일 크기가 얼마이고 어떤 데이터가 있는지 기억해야 햡니다. 
하지만 `파일 시스템`은 이러한 관리를 대신해줍니다.

<br>

## 1. 파일 접근 방법

- 파일 조작, 디렉토리 조작시에 `create`, `mkdir`, `rmdir` 등 다양한 함수를 사용하여 조작할 수 있는데, 파일 시스템이 `etx4` 혹은 `XFS`라도 상관없이 `create` 함수를 호출하면 파일을 생성할 수 있습니다. 이는 내부 구조를 모르더라도 공통화된 인터페이스를 사용하여 손쉽게 파일을 다룰 수 있다는 것을 의미합니다.

#### 🚗 과정

1. 프로세스가 `create`함수를 사용하여 커널에 `system call`을 요청합니다.
2. 가상 파일 시스템(`VFS`) 계층이 호출되어, 해당 경로의 파일 시스템을 식별하여 특정 파일 시스템을 호출합니다.
3. 호출된 파일 시스템은 디바이스 드라이버를 호축합니다.
4. 디바이스 드라이버가 장치를 조작합니다.

<img width="1032" alt="스크린샷 2025-05-06 오후 3 36 37" src="https://github.com/user-attachments/assets/2985f39d-7f2b-4fda-92a7-dc457d3c6011" />

<br><br>

## 2. 쿼터(용량 제한)

- 다양한 용도로 시스템을 사용하다 보면 다른 기능 실행에 필요한 용량이 부족해지는 경우가 있습니다. 이러한 문제를 방지하기 위해 용도별로 사용 가능한 시스템 용량을 제한하는 기능이 필요한데, 이러한 기능을 `쿼터`라고 부릅니다.

<img width="1032" alt="스크린샷 2025-05-06 오후 3 58 51" src="https://github.com/user-attachments/assets/43047d08-ab8c-41a8-9d02-79181a10c2ad" />

<br>

### 2-1. 쿼터의 종류

#### 사용자 쿼터

- 파일 소유자인 사용자마다 용량을 제한합니다. 예를들어 일반 사용자 때문에 /home/ 디렉토리가 가득차는 상태를 방지하는 목적입니다.
- ext4와 XFS는 사용자 쿼터 기능을 사용할 수 있습니다.

#### 디렉토리 쿼터

- 특정 디렉토리마다 용량을 제한하니다.
- ext4와 XFS 파일 시스템에서 사용 가능합니다.

#### 서브 볼륨 쿼터

- 파일 시스템 내부의 서브 볼륨 단위마다 용량을 제한합니다.
- Btrfs에서 사용 가능합니다.

<br>

## 3. 파일 시스템 정합성 유지

- 시스템을 운영하다보면 파일 시스템 내용에 오류가 발생하여 정상적으로 파일이 저장되지 않는 경우가 발생하는데 어떻게 이러한 오류를 방지할 수 있는지 알아봅니다.

### 3-1. 저널링을 통한 오류 방지

#### 💡 저널링이란?

- `저널링`이란 파일 시스템 정합성을 보장하기 위해 변경 내용을 실제로 적용하기 전에 `저널`이라는 특별한 로그 영역에 먼저 기록하고, 나중에 실제 메타데이터나 데이터에 적용하는 방식입니다.

#### 🚗 과정

1. 터미널에서 echo hello > testfile라는 명령어를 입력
2. etx4 파일 시스템은 변경될 `메타데이터(inode 할당, 디렉토리 엔트리 등)`를 파악합니다.
3. 변경될 메타데이터를 `저널`에 먼저 기록합니다.
4. 파일 내용(hello)은 일반 디스크에 저장합니다.
5. 파일 내용이 실제로 디스크에 기록이 된다면 `저널`의 메타데이터를 실제로 반영합니다.
6. 저널 영역은 이후에 정리됩니다.(commit 완료)

#### inode란?

- `inode`는 `index node`의 약자로 파일 자체에 대한 모든 메타데이터를 담고 있습니다.
  - 파일 크기, 파일 생성/수정/접근 시간, 파일 유형, 권한/소유자, 데이터 위치 등의 메타데이터를 담고 있습니다.
- `inode`는 파일 이름을 포함하지 않습니다!!
 
#### 디렉토리 엔트리

- 디렉토리는 내부적으로 여러개의 디렉토리 엔트리를 가지고 있으며, 각 엔트리는 `파일 이름`과 `inode 번호`를 연결하는 역할을 합니다.
- 즉, 파일 이름을 통해 해당 `inode`를 찾는게 가능합니다.

예시 

- 파일 이름이 testfile이고 inode번호가 2889401라면 innode 2889401안에 파일의 메타데이터와 실제 내용 위치가 있습니다.

```txt
> stat testfile
File: testfile
Size: 6         	Blocks: 8          IO Block: 4096   regular file
Device: bfh/191d	Inode: 2889401     Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2025-05-06 05:48:29.523242000 +0000
Modify: 2025-05-06 05:48:25.471076012 +0000
Change: 2025-05-06 05:48:25.471076012 +0000
 Birth: 2025-05-06 05:48:25.471076012 +0000
```

<br>

### 3-2. copy on write를 통한 오류 방지

- 👉🏻 [COW 이해하기](https://github.com/kdg0209/realizers/blob/main/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EB%A6%AC%EB%88%85%EC%8A%A4%20%EA%B5%AC%EC%A1%B0/05%EC%9E%A5%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B4%80%EB%A6%AC.md) `copy on write` 에 대한 설명은 링크를 참고해주세요.
- `COW`는 처음에는 메모리를 공유하다가 데이터 쓰기 시점에 페이지 폴트가 발생하여 페이지 폴트 핸들러에 의해 물리 메모리를 할당받고 페이지 테이블의 쓰기 권한이 수정되는 로직을 담고 있습니다.

#### Btrfs의 COW

1. 파일 수정 요청이 발생함
2. 기존 블록은 건들이지 않고, 새로운 블록에 복사본 작성 (COW 진행)
3. 수정 완료 후 `inode`가 가리키는 포인터만 새 포인터로 바꿈(atomic)
4. 전원이 꺼져도 예전 블록은 살아있고, 수정은 반영이 되지 않음(rollback 안전)













