# 메모리 계층

<br>

## 1. 캐시 메모리

#### 💡 캐시 메모리란?

- 캐시 메모리는 메모리에 있는 데이터를 더 빨리 가져오기 위한 중간 저장장치입니다.
- 메모리에서 CPU로 데이터를 읽어 들일 때, 캐시 메모리의 `캐시 라인`이라고 부르는 단위로 데이터를 읽어서 그 데이터를 CPU로 옮깁니다. `캐시 라인`은 CPU마다 정해져 있습니다.

📌 캐시라인이란?

- 캐시라인은 CPU가 메모리에서 데이터를 읽거나 쓸때 사용하는 64비트 단위의 전송/저장 최소 블록입니다. (x86)
- 메모리에서 데이터를 읽을 때 1바이트만 필요해도 최소 64바이트 단위로 가져옵니다.

<br>

### 1-1. 캐시 메모리의 값이 변경되면?

#### 🚗 과정

1. R0이 메모리 주소 300의 데이터를 요청합니다.
2. 메모리에서 데이터를 가져온 후 캐시 메모리에 저장한 뒤에 R0에게 데이터를 반환합니다.
3. 이때 R1이 메모리 주소 300의 데이터를 요청합니다.
4. R1이 요청한 데이터는 캐시 메모리에 있기 때문에 캐시 메모리의 데이터를 반환합니다.
5. R0이 값을 변경하고 변경된 내용을 메모리에 반영하려고 하는데, 우선 메모리에 쓰기 전 캐시 메모리에 먼저 저장합니다.
6. 캐시라인에는 메모리에서 읽어 들인 데이터가 변경되었다는 것을 표시합니다.(`더티 표시`)
7. 더티 표시가 붙은 캐시라인의 데이터를 메모리에 반영하면 캐시라인에 붙은 더티 표시는 사라집니다.

<img width="1032" alt="스크린샷 2025-05-10 오후 2 16 19" src="https://github.com/user-attachments/assets/bde8b169-702b-4df2-9ddc-d8a9a7fba80e" />

<br><br>

### 1-2. 메모리에 데이터 쓰기

#### write-through

- `write through`는 바로 쓰는 방법입니다.
- 데이터를 캐시 메모리에 쓰는 동시에 메모리에도 바로 기록하기 때문에 데이터 정합성을 유지할 수 있습니다.
- 데이터가 변경될 때마다 메모리에 접근해야하니 오버헤드가 발생하게 됩니다.

#### write-back

- `write back`은 나중에 정해진 때가 되면 메모리에 기록하는 방법입니다.
- 데이터가 변경될때마다 메모리에 접근하는 일이 없기 때문에 오버헤드는 발생하진 않지만 모종의 이유로 문제가 생기면 데이터가 유실될 수 있습니다.

<br>

### 1-3. 캐시 메모리가 가득찬다면?

- 캐시 메모리가 가득 찼는데 캐시에 존재하지 않는 데이터를 읽어 들인다면 기존 캐시라인 중에서 하나를 버리고 빈 캐시라인에 데이터를 넣습니다.(`LRU`, `LFU`)
- 만약 버리는 캐시라인이 `더티` 상태라면 메모리에 데이터를 저장하는 `클린`을 하고 버리게 됩니다.
- 다만 새로운 데이터 접근시마다 계속해서 캐시라인이 교체되는 현상(`스래싱`)이 발생하면 성능이 떨어지게 됩니다.

<br>

### 1-4. 참조 지역성이란?

- CPU가 메모리에서 데이터를 읽을 때 `시간적 지역성`과 `공간적 지역성`을 이용하여 근처에 있는 데이터도 함께 캐시 메모리에 저장하는 특성입니다.

#### 시간적 지역성

- CPU는 어떤 시점에 접근한 메모리는 가까운 미레에 또 다시 접근할 가능성이 높습니다.

#### 공간적 지역성

- CPU는 어떤 시점에 메모리에 접근하면 가까운 미래에 그 근처에 있는 데이터에 접근할 가능성이 높습니다.

<br>

## 2. Simultaneous Multi Threading(SMT)

- `SMT`는 하나의 CPU코어가 여러 스레드를 동시에 실행할 수 있게 해주는 기술입니다.
- 즉, 물리적으로는 하나의 코어이지만 논리적으로는 둘 이상의 스레드가 병렬로 동작하게끔 하는 것입니다.

#### 예시

- 예를들어 CPU에는 정수 연산을 하는 유닛과 부동 소수점 연산을 하는 유닛이 존재하는데, 정수 연산을 하는 동안에 부동 소수점 연산 유닛은 놀고 있는 상태가 되는데, 이때 `SMT`를 사용하면 병렬적으로 작업을 할 수 있습니다.

<br>

## 3. 페이지 캐시

#### 💡 페이지 캐시란?

- 페이지 캐시느 캐시 메모리와 비슷합니다. 캐시 메모리는 메모리의 데이터를 캐시 메모리에 캐싱하여 빠르게 접근하는 것이고 `페이지 캐시`는 파일의 데이터를 메모리에 캐싱하여 I/O를 줄여 빠르게 접근하고 페이지 캐시는 페이지 단위로 데이터를 다룹니다.

#### 🚗 과정

1. 프로세스가 read() 함수를 통해 특정 파일을 읽으려고 합니다.
2. 커널은 페이지 캐시에 해당 파일 데이터가 있는지 확인합니다.
3. 없다면 디스크에서 읽어와 페이지 캐시에 저장합니다.
4. 커널은 페이지 캐시에서 필요한 데이터만 꺼내서 프로세스가 요청한 **버퍼에 복사**하여 전달합니다.

<br>

## 4. 버퍼 캐시

#### 💡 버퍼 캐시란?

- 버퍼 캐시는 페이지 캐시와 비슷하지만 버퍼 캐시는 디스크의 데이터 중에서 파일 데이터 이외의 것을 캐싱하는 방법이며, 아래 목적으로 사용됩니다.
  - 파일 시스템을 사용하지 않고 디바이스 파일로 저장장치에 직접 접근하는 경우
  - 파일의 권한, 크기 등의 메타데이터에 접근하는 경우
- 디스크를 마운트하지 않고 `open("/dev/sdb", O_RDWR)`와 같은 방식을 사용하여 블록 장치 자체에 직접 read/write하면 커널이 페이지 캐시가 아닌 버퍼 캐시를 사용하여 블록 단위 I/O를 처리합니다.

<br>

## 5. 스왑

- 보통 사용 가능한 물리 메모리가 없으면 OOM이 발생하는데, `스왑` 기능을 사용하면 메모리가 고갈되어도 곧바로 OOM이 발생하는 것을 방지할 수 있습니다.

#### 💡 스왑이란?

- 시스템의 물리 메모리가 고갈된 상태일 때 더 많은 메모리를 확보해야 한다면 사용 중인 물리 메모리 일부를 저장장치로 옮기고 메모리에 빈 공간을 만드는 것입니다. 이때 데이터를 옮긴 영역을 `스완 영역`이라고 부릅니다.

#### 스왑 인

- 페이지 폴트가 발생하여 필요한 페이지를 `스왑 영역`에서 물리 메모리로 읽어 오는 작업입니다.

#### 스왑 아웃

- 물리 메모리가 부족해지면 사용 빈도가 낮은 메모리(페이지)를 `스왑 영역`으로 옮기는 작업을 스왑 아웃 또는 페이지 아웃이라 합니다.

#### 📌 메이저 폴트

- 페이지 폴트 중에서 스왑 인(`페이지 인`)으로 인해 저장장치에 접근이 발생하는 것을 `메이저 폴트`라고 하고, 그외는 마이너 폴트라 합니다.
- `메이저 폴트`는 마이너 폴트에 비해 영향도가 크기 때문에 자주 발생하면 성능이 느려집니다.


