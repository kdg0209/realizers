# 카프카 프로듀서
<hr>

## Producer의 구조

- Kafka producer Client는 크게 3가지로 구성되어 있습니다.
- 첫번째는 <b>KafkaProducer</b>입니다. KafkaProducer는 send 메서드를 통해 레코드를 전송하게 됩니다.
- 두번째는 <b>RecordAccumulator</b>입니다. KafkaProducer가 send 메서드를 통해 전달한 레코드는 바로 브로커에게 전달되는게 아니라 RecordAccumulator에 배치형식으로 저장되고, Sender 클래스에 의해 전송됩니다.
- 세번째는 <b>Sender Thread</b>입니다. Sender Thread는 RecordAccumulator에 저장된 레코드를 브로커로 전송하는 역할을 담당합니다. 그리고 브로커의 응답을 받아 콜백을 KafkaProducer에게 전달해줍니다.

<img width="1028" alt="스크린샷 2024-02-09 오후 3 52 33" src="https://github.com/kdg0209/realizers/assets/80187200/83de7a60-d036-417a-85ba-0053af2e8a57">

#### KafkaProducer.send

- KafkaProducer의 send 메서드는 레코드 전송뿐만 아니라 전송의 결과를 콜백형식으로 응답을 받을 수 있습니다.

#### Serialization

- 사용자가 전달한 레코드의 key와 value는 지정된 Serializer에 의해 ByteArray로 변환됩니다.

#### Partitioning

- Kafka의 토픽은 여러개의 파티션으로 구성되어 있는데, 사용자의 레코드는 Partitioner에 의해 어떤 파티션으로 갈지 정해집니다.
- 레코드 생성시 파티션을 지정할 수 있는데, 만약 파티션을 지정하게 된다면 Partitioner를 사용하지 않고 지정된 파티션이 사용됩니다.
  - 레코드의 key가 있는 경우 key값의 hash를 통해 Partition이 할당됩니다.
  - 레코드의 key가 없는 경우 2.4 버전 이전에는 라운드 로빈 전략을 통해 Partition이 할당되었지만, 2.4 버전 이후부터는 스티키 파티셔닝 전략을 통해 Partition이 할당됩니다.
 
#### Compression

- 사용자가 전송하는 레코드는 압축을 통해 네트워크 전송 비용을 낮출 수 있고, 저장 비용도 낮출 수 있습니다.
- 레코드는 RecordAccumulator에 저장될 때 압출되어 저장됩니다.

#### RecordAccumulator의 append 메서드

- 사용자가 전송하는 레코드는 압축되어 RecordAccumulator에 저장되는데, 이때 ConcurrentMap<TopicPartition, Deque<ProducerBatch>> batches라는 멤버 변수에 저장됩니다.

```java
public final class RecordAccumulator {
  
    private final ConcurrentMap<TopicPartition, Deque<ProducerBatch>> batches;
    ...
}
```

#### Sender Thread

- Sender Thread는 RecordAccumulator에 저장되어 있는 레코드를 꺼내서 브로커로 전송하고 응답을 받는 역할을 수행합니다.
- Sender Thread는 RecordAccumulator의 drain() 메서드를 통해 각 브로커별로 전송할 RecordBatch List를 얻을 수 있습니다.

<br>

지금까지 위에서 프로듀서가 메시지를 전송하기까지의 큰 그림을 확인했는데 하나씩 더 자세히 살펴보겠습니다.

<br>

## 파티션 분배 전략

- 레코드의 key값이 없을 경우에만 파티션 분배 전략을 적용할 수 있습니다.
- 파티션의 분베 전략은 라운드 로빈, 스티키 파티셔닝 전략이 있습니다. 우선 라운드 로빈 전략부터 살펴보겠습니다.

#### 라운드 로빈 전략

- 라운드 로빈은 레코드를 파티션에 균일하게 분배하려는 전략입니다.
- 레코드가 batch size만큼 빨리 채우지 못한다면 전송이 늦어질 수도 있고, batch size를 다 채우지 못하고 전송하면 처리량 또한 낮아질 수 있습니다.

<img width="1037" alt="스크린샷 2024-02-09 오후 5 02 47" src="https://github.com/kdg0209/realizers/assets/80187200/9867736b-ed71-4f19-aa73-c2aaa283f104">

#### 스티키 파티셔닝 전략

- 스티키 파티셔닝 전략은 라운드 로빈이 가지고 있는 문제점을 해결하기 위해 2.4 버전에 등장하였으며, 2.4버전 이후 기본 설정값입니다.
- 스티키 파티셔닝이란 하나의 파티션에 레코드를 먼저 체워서 브로커로 빠르게 배치 전송하는 전략입니다.

<img width="1035" alt="스크린샷 2024-02-09 오후 5 01 34" src="https://github.com/kdg0209/realizers/assets/80187200/116e9663-7c50-42c7-9faa-3192c51fa053">

<br>

## 프로듀서의 배치 전송

- 프로듀서는 브로커에 메시지를 전송할때 ACK를 받게됩니다. 만약 프로듀서가 레코드 전송 한건 당 ACK를 받으면 처리량이 낮아질뿐만 아니라 레이턴시가 증가하게 됩니다.
- 레코드는 RecordAccumulator 클래스 내에서 배치 형식으로 저장되는데, 이러한 구조로 인해 처리량을 증가시키고, 레이턴시를 낮출 수 있습니다.

#### batch.size

- batch.size는 단일 배치 사이즈를 의미하는데, 기본값은 16384Byte로 설정되어 있습니다.
- 기본적으로 batch.size 만큼 차야 메시지가 전송되게 됩니다. 하지만 해당 기본값보다 큰 레코드가 저장된다면 바로 전송됩니다.

#### linger.ms

- Sender Thread가 RecordAccumulator에서 배치 단위로 레코드를 가져오는데, 해당 ms 만큼 Sender Thread가 기다리는 시간이라 생각하면 이해하기 쉽습니다.
- 기본값이 0인데, 이때는 Sender thread가 바로바로 가져오게 됩니다.

<br>

## Producer Delivery Semantics (Feat: Ack)

- Producer의 Ack 옵션과 Broker의 min.insync.replica 옵션을 사용해서 여러가지 delivery semantics 처리가 가능합니다.


#### Ack: 0

- ack가 0인 경우 At most once에 해당하는 방식이 적용됩니다.
  - at most once란?
    - 프로듀서가 브로커에게 레코드를 1회 전송을 시도합니다. 전송에 대한 응답을 받지 않습니다.
    - 메시지는 중복되지 않지만, 메시지가 유실될 가능성이 있습니다.
- Producer는 Leader Partition을 가진 Broker에게 레코드를 보내고, 정상적으로 레코드를 받았는지에 대한 ACK를 확인하지 않고 다음 레코드를 전송합니다.


```
1. 예제 토픽 생성
아래 토픽은 파티션 1, 복제 3, 레코드 최소 복제 2 설정을 토대로 토픽을 생성하였습니다.
kafka-topics --bootstrap-server localhost:9092 --create --topic topic-A --partitions 1 --replication-factor 3  --config min.insync.replicas=2
```

과정

- replication-factor 3과 min.insync.replicas=2 옵션을 통해 3대의 브로커에서 리더 브로커 포함하여 최소 2개의 브로커에 메시지가 복제되어야하는데 ack를 0으로 설정한다면 복제가 제대로 이루어졌는지 Producer는 확인하지 않습니다.

<img width="1030" alt="스크린샷 2024-02-09 오후 5 39 16" src="https://github.com/kdg0209/realizers/assets/80187200/05d1e438-e13d-4384-9718-3132a0c62410">



#### Ack: 1

#### Ack: all(-1)
  












