#  구조 디자인 패턴

## 프록시 패턴

- 프록시 패턴은 인터페이스 기반과 상속 기반으로 설계를 할 수 있습니다. 예제는 인터페이스 기반으로 작성할 것입니다.
- 프록시 패턴에는 기본형, 가상, 보호, 로깅, 원격, 캐싱 프록시가 있습니다. 여기서는 기본형, 가상, 로깅, 캐싱에 대해서만 살퍄볼 예정입니다.

### 프록시 패턴의 구조

- 프록시 패턴의 구조를 살펴보면 Proxy 클래스와 RealSubject 클래스는 Subject 클래스를 구현하고 있으며, Proxy 클래스는 내부적으로 Subject 클래스에게 어떠한 행동을 위임시킵니다.

<img width="1032" alt="스크린샷 2024-04-25 오후 10 02 38" src="https://github.com/kdg0209/realizers/assets/80187200/2611c589-55df-4ce7-a9d0-83968104ec06">

<br>

### 기본 프록시

- 기본 프록시는 행위는 RealSubject에게 위임을 하고 프록시에서는 추가적인 로직을 수행하는 역할을 합니다.
- 프록시 패턴에서 프록시 클래스는 원본 클래스와 관련 없는 기능을 추가할 수 있습니다.
- 개인적으로 기본 프록시는 자주 사용될지는 모르겠습니다.

```java
public interface ProductSubject {

    void addProduct(Product product);

    Optional<Product> buyProduct(Long id);
}

public class ProductRealSubject implements ProductSubject {

    private final List<Product> products = new ArrayList<>();

    @Override
    public void addProduct(Product product) {
        this.products.add(product);
    }

    @Override
    public Optional<Product> buyProduct(Long id) {
        if (id == null) {
            return Optional.empty();
        }

        return this.products.stream()
                .filter(product -> product.isEqualsId(id))
                .findFirst();
    }
}

public class ProductProxy implements ProductSubject {

    private final ProductSubject subject;

    public ProductProxy(ProductSubject subject) {
        this.subject = subject;
    }

    @Override
    public void addProduct(Product product) {

        // 위임
        this.subject.addProduct(product);
    }

    @Override
    public Optional<Product> buyProduct(Long id) {

        // 위임
        return this.subject.buyProduct(id);
    }
}

public class Main {

    public static void main(String[] args) {
        Product productA = new Product(1L, "아이폰", 1000000L);
        Product productB = new Product(2L, "맥북", 2000000L);

        ProductProxy proxy = new ProductProxy(new ProductRealSubject());

        proxy.addProduct(productA);
        proxy.addProduct(productB);

        Optional<Product> buyA = proxy.buyProduct(1L);
        System.out.println(buyA.isPresent());       // true

        Optional<Product> buyB = proxy.buyProduct(3L);
        System.out.println(buyB.isPresent());       // false
    }
}
```

<br>

### 가상 프록시

- 가상 프록시는 지연 초기화 방식을 지원합니다.
- 이 방식은 실제 객체 생성 비용은 비싸지만 사용되는 빈도가 낮은 경우에 사용됩니다.

```java
public interface ProductSubject {

    void addProduct(Product product);

    Optional<Product> buyProduct(Long id);
}

public class ProductRealSubject implements ProductSubject {

    private final List<Product> products = new ArrayList<>();

    @Override
    public void addProduct(Product product) {
        this.products.add(product);
    }

    @Override
    public Optional<Product> buyProduct(Long id) {
        if (id == null) {
            return Optional.empty();
        }

        return this.products.stream()
                .filter(product -> product.isEqualsId(id))
                .findFirst();
    }
}

public class ProductProxy implements ProductSubject {

    private ProductSubject subject;

    @Override
    public void addProduct(Product product) {

        // lazy
        if (this.subject == null) {
            this.subject = new ProductRealSubject();
        }

        // 위임
        this.subject.addProduct(product);
    }

    @Override
    public Optional<Product> buyProduct(Long id) {

        // lazy
        if (this.subject == null) {
            this.subject = new ProductRealSubject();
        }

        // 위임
        return this.subject.buyProduct(id);
    }
}

public class Main {

    public static void main(String[] args) {
        Product productA = new Product(1L, "아이폰", 1000000L);
        Product productB = new Product(2L, "맥북", 2000000L);

        ProductProxy proxy = new ProductProxy();

        proxy.addProduct(productA);
        proxy.addProduct(productB);

        Optional<Product> buyA = proxy.buyProduct(1L);
        System.out.println(buyA.isPresent());       // true

        Optional<Product> buyB = proxy.buyProduct(3L);
        System.out.println(buyB.isPresent());       // false
    }
}
```

<br>

### 로깅 프록시

- 로깅 프록시도 기본형 프록시와 비슷합니다.

```java
public interface ProductSubject {

    void addProduct(Product product);

    Optional<Product> buyProduct(Long id);
}

public class ProductRealSubject implements ProductSubject {

    private final List<Product> products = new ArrayList<>();

    @Override
    public void addProduct(Product product) {
        this.products.add(product);
    }

    @Override
    public Optional<Product> buyProduct(Long id) {
        if (id == null) {
            return Optional.empty();
        }

        return this.products.stream()
                .filter(product -> product.isEqualsId(id))
                .findFirst();
    }
}

public class ProductProxy implements ProductSubject {

    private final ProductSubject subject;

    public ProductProxy(ProductSubject subject) {
        this.subject = subject;
    }

    @Override
    public void addProduct(Product product) {
        long startTime = System.currentTimeMillis();

        // 위임
        this.subject.addProduct(product);

        long endTime = System.currentTimeMillis();

        System.out.println("completed time: " + (endTime - startTime));
    }

    @Override
    public Optional<Product> buyProduct(Long id) {
        long startTime = System.currentTimeMillis();

        // 위임
        Optional<Product> result = this.subject.buyProduct(id);

        long endTime = System.currentTimeMillis();

        System.out.println("completed time: " + (endTime - startTime));

        return result;
    }
}

public class Main {

    public static void main(String[] args) {
        Product productA = new Product(1L, "아이폰", 1000000L);
        Product productB = new Product(2L, "맥북", 2000000L);

        ProductProxy proxy = new ProductProxy(new ProductRealSubject());

        proxy.addProduct(productA);
        proxy.addProduct(productB);

        Optional<Product> buyA = proxy.buyProduct(1L);
        System.out.println(buyA.isPresent());       // true

        Optional<Product> buyB = proxy.buyProduct(3L);
        System.out.println(buyB.isPresent());       // false
    }
}
```

<br>

### 캐싱 프록시

- 캐싱 프록시는 아래와 같은 구조인데, 이는 Redis를 사용하여 캐싱을 적용하는것과 비슷한 원리인 것 같습니다.

![스크린샷 2024-04-25 오후 10 50 04](https://github.com/kdg0209/realizers/assets/80187200/3e505420-c6fe-4af2-8e8b-3226102456e1)

<br>

## 데코레이터 패턴

- 데코레이터 패턴은 객체를 결합하여 기능을 동적으로 확장할 수 있도록 해주는 패턴입니다.
- 데코레이터 패턴에서 데코레이터 클래스는 원본 클래스와 관련이 깊은 기능을 추가합니다.
- Java에서 I/O 라이브러리(InputStream, OutputStream)은 데코레이터 패턴을 사용하였습니다.

### 데코레이터 패턴을 적용하지 않은 상황

- 아래 예제 코드에서 기본적인 총은 조준, 견착, 사격을 할 수 있지만 스나이퍼의 경우 4배율을 사용해서 조준을 합니다. 그리고 라이플, 유탄등과 같은 다른 총들이 필요로하게 된다면 상속의 경우 깊은 상속 관계로 인해 결합도가 높아지게 됩니다.

```java
public class Gun {

    public void aiming() {
        System.out.println("조준합니다.");
    }

    public void shoulder() {
        System.out.println("견착합니다.");
    }

    public void shooting() {
        System.out.println("사격합니다.");
    }
}

public class Sniper extends Gun {

    @Override
    public void aiming() {
        System.out.println("4배율로 조준합니다.");
    }

    @Override
    public void shoulder() {
        super.shoulder();
    }

    @Override
    public void shooting() {
        super.shooting();
    }
}
```

<br>

### 🧐 데코레이터 패턴 적용

- 데코레이터 패턴은 new 장식자(new 원본()) 형식으로 장식자를 다양하게 꾸밀 수 있습니다.
- 장식자 클래스의 잘못된 순서로 인해 개발자가 의도하지 않은대로 동작될 수 있으니 장식자 순서에 대해 주의가 필요합니다.

```java
public interface Gun {

    void aiming();

    void shoulder();

    void shooting();
}

// 기본 총
public class BaseGun implements Gun {

    @Override
    public void aiming() {
        System.out.println("조준합니다.");
    }

    @Override
    public void shoulder() {
        System.out.println("견착합니다.");
    }

    @Override
    public void shooting() {
        System.out.println("사격합니다.");
    }
}

// 장식자 추상 클래스
public class GrenadeLauncher extends GunDecorator {

    public GrenadeLauncher(Gun gun) {
        super(gun);
    }

    @Override
    public void shooting() {
        System.out.println("유탄을 발사합니다.");
    }
}

public class Sniper extends GunDecorator  {

    public Sniper(Gun gun) {
        super(gun);
    }

    @Override
    public void aiming() {
        System.out.println("4배율로 조준합니다.");
    }
}

public class GrenadeLauncher extends GunDecorator {

    public GrenadeLauncher(Gun gun) {
        super(gun);
    }

    @Override
    public void shooting() {
        System.out.println("유탄을 발사합니다.");
    }
}

public class AllInOneGun extends GunDecorator {

    public AllInOneGun(Gun gun) {
        super(gun);
    }
}

public class Main {

    public static void main(String[] args) {

        // 기본 총
        Gun baseGun = new BaseGun();
        baseGun.shoulder();     // 견착합니다.
        baseGun.aiming();       // 조준합니다.
        baseGun.shooting();     // 사격합니다.

        // 저격총
        Gun sniper = new Sniper(new BaseGun());
        sniper.shoulder();      // 견착합니다.
        sniper.aiming();        // 4배율로 조준합니다.
        sniper.shooting();      // 사격합니다.

        // 유탄발사기
        Gun grenadeLauncher = new GrenadeLauncher(new BaseGun());
        grenadeLauncher.shoulder(); // 견착합니다.
        grenadeLauncher.aiming();   // 조준합니다.
        grenadeLauncher.shooting(); // 유탄을 발사합니다.

        // 올인원 총
        Gun allInOneGun = new AllInOneGun(new Sniper(new GrenadeLauncher(new BaseGun())));
        allInOneGun.shoulder(); // 견착합니다.
        allInOneGun.aiming();   // 4배율로 조준합니다.
        allInOneGun.shooting(); // 유탄을 발사합니다.
    }
}
```

<br>

## 어댑터 패턴









