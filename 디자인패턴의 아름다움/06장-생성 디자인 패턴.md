# 생성 디자인 패턴

- 생성 디자인 패턴은 객체 생성 문제를 해결하고, 복잡한 생성 프로세스를 캡슐화하며 객체 생성코드를 분리함으로써 유지보수성을 향상시킵니다.

## 싱글턴 패턴

- 객체를 하나만 생성하여 자원을 효과적으로 사용할 수 있는 디자인 패턴입니다.
- 구현 조건
  1. 생성자는 new 예약어를 통한 인스턴스 생성을 피하기 위해 private 접근 제한자를 가져야합니다.
  2. 인스턴스 생성시 Thread Safe해야 합니다.
  3. 클라이언트가 값을 변경할 수 있는 필드가 있으면 안됩니다.
  4. 지연 로딩이 가능해야합니다.
 
### 이른 초기화

- 가장 쉽게? 구현할 수 있는 싱글턴 패턴입니다.
- static 키워드를 사용함으로써 클래스 로더에 의해 클래스가 로딩될 때 메모리상에 하나의 객체만 생성됩니다. 또한 클래스가 최초 로딩될 때 객체가 생성되므로 Thread-Safe합니다.
- 다만 클래스 로더에 의해 클래스가 로딩되는 시점에 바로 생성되므로 지연 로딩이 불가능하고, 해당 객체를 사용하지 않더라도 메모리상에 점유하고 있기 때문에 자원이 비효율적으로 사용될 수 있습니다.

```java
public class User {

    private static final User instance = new User();

    private User() { }

    public User getInstance() {
        return instance;
    }
}
```

<br>

### 늦은 초기화

- 늦은 초기화 방식은 자바에서 제공하는 모니터 락을 사용하는 방식인데, 클래스 로더에 의해 클래스가 로딩되는 시점에 객체가 생성되는게 아니라 getInstance 메서드를 호출하는 시점에서 객체가 생성됩니다.
- 해당 인스턴스에 접근하고자 하는 클라이언트가 많을수록 synchronized 키워드에 의해 성능 저하가 발생할 수 있습니다.

```java
public class User {

    private static User instance;

    private User() { }

    public static synchronized User getInstance() {
        if (instance == null) {
            instance = new User();
        }
        return instance;
    }
}
```

<br>

### 이중 잠금(Double Checked Locking)

- 모니터 락을 메서드 레벨에 선언하게 되면 메서드 호출시마다 오버헤드가 발생하기 때문에 성능을 향상시키고자 Double Checked Locking 기법이 나오게 되었습니다.
- 해당 방식에서는 블럭 방식의 모니터 락을 사용하여 성능을 향상시켰습니다.
- Double Checked Locking 기법을 사용하면 가시성 문제로 인해 인스턴스가 2개 생성될 수 있습니다. 원리는 아래와 같습니다.
  - 스레드 A가 인스턴스를 생성하고 모니터 락을 해제합니다.
  - 스레드 B가 모니터 락에 진입하는 시점에 스레드 A가 생성한 인스턴스가 main memory에 있는게 아닌 캐시 메모리에만 있는 경우 또는 반대의 상황에서 스레드 B는 해당 인스턴스가 존재하지 않는다고 판단하여 추가적으로 인스턴스를 생성하게 됩니다.

```java
public class User {

    private static User instance;

    private User() { }

    public static User getInstance() {
        if (instance == null) {
            synchronized (User.class) { // 클래스 레벨의 잠금 처리 instance 변수로 하게되면 NPE 발생함
                if (instance == null) {
                    instance = new User();
                }
            }
        }

        return instance;
    }
}
```

<br>

### 홀더에 의한 초기화(Initialzation on demand holder)

- static inner class의 특성을 사용하여 static class이지만 바로 메모리(static 영역)에 할당되지 않고 클라이언트가 getInstance 메서드를 호출해야 메모리에 할당되게 됩니다.
- JVM의 Class Loader의 매커니즘과 class의 load 시점을 이용하여 inner class를 생성시킴으로 스레드간 동기화 문제를 해결합니다.
- Java에서 사용하는 싱글톤은 이 방법을 가장 많이 사용한다고 합니다.

```java
public class User {

    private User() { }

    public static User getInstance() {
        return Holder.instance;
    }
    
    private static class Holder {
        
        private static final User instance = new User();
    }
}
```









