# 설계 원칙

<br>

## 단일 책임 원칙

- 단일 책임 원칙이란 클래스와 모듈은 하나의 책임 또는 기능만을 수행해야 하는 설계 원칙입니다.
- 단일 책임 원칙은 클래스가 하나의 책임이나 기능을 담당하는 것입니다. 즉 갓 클래스를 구현하는게 아닌 하나의 클래스에 작은 단위와 단일 기능을 가진 클래스를 설계해야 합니다.

### 클래스에 단일 책임이 있는지 판단하는 방법

#### 예시 

- 아래 코드를 보면 UserInfo 클래스에 사용자의 정보와 주소 정보가 속성으로 있습니다. 이때 주소 속성을 Address 클래스로 분할할 수도 있고, 지금처럼 하나의 클래스로 관리할 수 있는데 과연 어떤게 더 단일 책임 원칙에 타당할까요?
  - <b> 단지 클래스만 보고 어떤게 더 타당한지 말할 수 없습니다. 현재 개발하고자 하는 시나리오에 따라 달라질 수 있습니다. 만약 이메일이나 연락처의 경우 민감 정보이기 때문에 마스킹처리가 필요하여 해당 로직이 복잡해진다면 이메일이나 연락처를 다른 클래스로 분리할 수도 있고, 추후 주소에 대한 로직이 복잡해진다면 주소에 대한 속성을 다른 클래스로 분리할 수도 있습니다. </b> 

```java
public class UserInfo {
    
    private final long userId;
    private final String userName;
    private final String email;
    private final String phone;
    private final String provinceOfAddress; // 도
    private final String cityOfAddress;     // 시
    private final String regionOfAddress;   // 구
    private final String detailedAddress;   // 상세 주소
}
```

#### 단일 책임 원칙을 결정하기 위한 원칙들

- 하나의 클래스에 속성이나 함수가 너무 많아 가독성과 유지 보수성에 영향을 미치는가?
- 클래스의 속성들이 다른 클래스에 과하게 의존하여 높은 결합도와 낮은 응집도를 가지는가?
- 하나의 클래스에 private 메서드가 너무 많은가?
- 클래스의 역할이 명확하지 않아 비지니스적으로 명칭을 지정하기 어려운가?

<br>

## 개방 폐쇄 원칙

- 개방 폐쇄 원칙은 확장할 때는 개방, 수정할 때는 폐쇄에 대해 설명하는 원칙입니다.
- 개방 폐쇄 원칙이 이해하기 어려운 이유는 코드를 변경할 때 그 결과를 확장으로 보아야 하는지, 수정으로 보아야하는지 명확하게 구분하기 어렵기 때문입니다.
- <b> 새로운 기능을 추가할 때 기존의 모듈, 클래스, 함수를 수정하기 보다는 기존 코드를 기반으로 모듈, 클래스, 함수등을 추가하는 방식으로 코드를 확장해야 한다는 뜻입니다. </b>

### 확장할 때는 개방, 수정할 때는 폐쇄

- 개방 폐쇄 원칙을 이해하기 위해서는 새로운 기능을 추가할 때는 기존의 모듈, 클래스, 함수를 수정하는것 보다는 기존 코드를 기반으로 모듈, 클래스, 함수를 추가하는 방식으로 코드를 확장하는 것입니다. 약간 모호할 수 있는데 간단한 예제를 살펴보겠습니다.

#### 예시 

- 티켓의 등급에 따라 할인 정책이 달라진다는 가정하에 고민을 하지 않고 개발을 한다면 아래와 같이 성급한 개발을 할 수 있습니다.
- 이때 할인 정책 기능이 추가되는 경우 if문이 증가하게 되고, 단위 테스트 또는 생각해야 하는 점이 늘어나기 때문에 유지보수 비용이 낮아지게 됩니다.

```java
public class Ticket {

    private final long id;
    private final TicketGrade ticketGrade;

    public void calculate() {
        long sum = 0L;

        if (ticketGrade == TicketGrade.VIP) {
            // 고정 3%와 퍼센트 할인 정책에 해당하는 비지니스 로직 작성
        }
        if (ticketGrade == TicketGrade.R) {
            // 퍼센트 할인 정책에 해당하는 비지니스 로직 작성
        }
        if (ticketGrade == TicketGrade.S) {
            // 고정 3% 할인 정책에 해당하는 비지니스 로직 작성
        }
    }
}

public enum TicketGrade {

    VIP, R, S, A, B, C
}
```

<br>

#### 🤔 어떻게 해결할 것인가?

- 티켓을 예매할 때 등급에 따라 할인 정책이 달라진다.에 초점을 맞출 필요가 있다고 생각합니다. 즉, 할인 정책이라는 추상화에 의존해야지 어떻게 할인 정책이 이루어지는지에 대한 내부 구현은 중요하지 않습니다.(물론 중요함)
- 예시 코드가 길어질거 같아서 생략하고, 중요한 점은 DIP와 같은 원칙을 통해서 추상화에 의존한다면 코드의 양은 증가되지만 이점을 챙길 수 있을거 같습니다.
- 여기서는 의존 관계 역전의 원칙에 대한 이해도가 있다면 조금 더 쉽게 이해가 될거 같습니다.

<br>

### 코드를 수정하는 것은 OCP 원칙을 위배하는 것인가?

- 새로운 코드를 추가하더라도 기존 코드에 속성을 추가한다던지, 메서드를 추가하는 일이 종종 생기곤 합니다. 근데 이 경우를 OCP를 위반한다고 생각해야할까요?
- 기존 코드에 속성과 메서드를 추가했다고 해서 수정되었다라고 할 수 있습니다. 하지만 이 추가사항이 기존의 속성을 변경하거나 메서드를 수정하지 않았기 때문에 속성이나 메서드 입장에서 보면 확장으로 간주될 수 있습니다.
- OCP의 목적을 상기시켜보면 코드의 수정이 기존에 작성되어 있던 코드와 단위 테스트를 깨뜨리지 않는 한 이는 OCP를 위반하지 않는다고 판단해도 무방합니다.
- 새로운 기능을 추가할 때 모듈, 클래스, 메서드의 코드를 전혀 수정하지 않는 것은 불가능합니다. 따라서 우리는 수정을 아예 안 하는 것이 아니라 수정을 가능한 한 내부 구현에 대한 수정이 아닌 상위 수준의 코드에서 진행해야합니다.

### 확장할 때는 개방, 수정할 때는 폐쇄를 달성하는 방법

- OCP는 코드의 확장성 문제라고 볼 수 있는데, 이는 코드가 확장하기 쉬운 구조를 가지고 있는지 판단하는 표준에 해당합니다.
- <b> 확장 가능한 코드를 작성하기 위해서는 내부 구현이 아닌 추상화에 의존해야 하고, 변하는 부분과 변하지 않는 부분을 잘 파악한 후 변하지 않는 부분을 추상화를 도입하고 변하는 부분은 내부 구현으로 캡슐화를 진행해야 합니다. </b>

### 프로젝트에 OCP를 유연하게 적용하는 방법

- 프로젝트에 OCP를 적용하기 위해서는 우선 도메인 지식이 갖춰져야합니다. 도메인 지식 없이 확장 가능한 코드를 만들고 싶은 유혹에 의해 코드의 가독성은 떨어뜨리고 복잡성만 증가될 수 있습니다.
- 그러므로 잘 알지 못한다면 우선 가독성에 신경을 쓰고 추후에 새로운 기능을 도입해야 한다면 그때 리팩토링을 진행하면서 OCP를 적용해도 늦지 않습니다.

<br>

## 리스코프 치환 원칙

- 파생 클래스가 상위 클래스를 대체할 수 있어야한다라는 원칙입니다. 리스코프 치환 원칙은 상속을 할 때 지켜야하는 원칙입니다.

#### 예시 

- 아래 Vehicle 이라는 추상 클래스가 있고 Car, Turck, Train 클래스들이 Vehicle를 상속받고 있습니다. 하지만 기차의 경우 좌회전, 우회전의 기능이 없으므로 해당 메서드를 호출한다면 클라이언트 입장에서는 예외가 발생하게 됩니다. 이 상황에서 리스코프 치환 원칙이 잘 지켜지고 있는가? 에 대해 생각해볼 필요가 있습니다.
 
```java
public abstract class Vehicle {

    abstract void goForward();

    abstract void turnRight();

    abstract void turnLeft();
}

public class Car extends Vehicle {

    @Override
    void goForward() {

    }

    @Override
    void turnRight() {

    }

    @Override
    void turnLeft() {

    }
}

public class Truck extends Vehicle {

    @Override
    void goForward() {

    }

    @Override
    void turnRight() {

    }

    @Override
    void turnLeft() {

    }
}

public class Train extends Vehicle {

    @Override
    void goForward() {

    }

    @Override
    void turnRight() {
        throw new UnsupportedOperationException();
    }

    @Override
    void turnLeft() {
        throw new UnsupportedOperationException();
    }
}
```

<br>

#### 🤔 어떻게 해결할 것인가?

- 리스코프 치환 원칙을 잘 지기키위해서는 추상 클래스를 조금 더 간단히 만들고, 조금 더 세분화를 하고, 상속을 만드는 것보다 인터페이스를 만들어서 간단하고, 세분화한다면 해당 문제를 해결할 수 있습니다.
- 아래와 같이 인터페이스를 통해 각 기능을 조금 더 세분화하고, 클래스는 필요한 인터페이스만 구현을 하면 됩니다.

```java
public interface TurnAble {

    void turnRight();

    void turnLeft();
}

public interface MoveAble {

    void goForward();
}

public class Car implements MoveAble, TurnAble {

    @Override
    public void goForward() {

    }

    @Override
    public void turnRight() {

    }

    @Override
    public void turnLeft() {

    }
}

public class Truck implements MoveAble, TurnAble {

    @Override
    public void goForward() {

    }

    @Override
    public void turnRight() {

    }

    @Override
    public void turnLeft() {

    }
}

public class Train implements MoveAble {

    @Override
    public void goForward() {

    }
}
```
<br>

### 리스코프 치환 원칙과 다형성의 차이점

- 상속 관계에서의 리스코프 치환 원칙은 하위 클래스는 상위 클래스를 대체할 수 있어야 한다고 하는데, 프로그래밍을 하다보면 하위 클래스의 비지니스 로직에서는 특정 상황에서 예외가 발생해야하거나, 다른 동작을 도출해야하는 경우가 종종 있습니다. 이는 상속을 통해 다형성의 이점을 누릴 수 있지만 리스코프 치환 원칙을 위배하게 됩니다.

### 리스코프 치환 원칙을 위반하는 안티 패턴?

#### 1. 하위 클래스의 메서드가 상위 클래스의 메서드의 기능을 위반하는 경우

- 상위 클래스에서 sortOrdersByAmount() 라는 메서드를 정의한 후 주문 금액에 따라 정렬하였지만 해당 클래스를 상속받은 하위 클래스에서 sortOrdersByAmount() 메서드의 내부 구현을 금액이 아닌 주문 일자에 따라 정렬을 하는 경우 이는 리스코프 치환 원칙을 위배하게 됩니다.
- 생각해보면 이것은 안티패턴이 아니라 생각합니다. 상위 클래스에서 메서드명을 정의할때 내부 구현이 드러나는 메서드명을 정의하는게 아니라 추상적으로 정의할 필요가 있다고 생각합니다. ex: sortOrders()

#### 2. 하위 클래스가 입출력, 예외에 대한 상위 클래스의 계약을 위반하는 경우

- 예를들어 상위 클래스에서 오류가 발생하면 NULL을 반환하지만 하위 클래스에서는 예외가 발생하거나, 상위 클래스에서는 모든 정수를 입력받을 수 있지만 하위 클래스에서는 양의 정수만 입력 받을 수 있거나, 상위 클래스에서 선언한 예외가 하위 클래스에서는 예외가 달라질 경우 이는 리스코프 치환 원칙을 위배하게 됩니다.

#### 3. 하위 클래스가 상위 클래스의 주석에 나열된 특별 지침을 위반하는 경우

- 예를들어 상위 클래스에서 예금 인출시 주석에 정의되어 있는 특정 금액을 초과해서는 안되지만 하위 클래스에서 이를 위반하는 경우입니다.

<br>

## 인터페이스 분리 원칙

- 인터페이스를 사용할 때 한번에 크게 정의하지 말고, 세분화하여 사용하라는 원칙입니다.
- 클라이언트 및 클래스는 필요하지 않는 메서드에 의존할 필요가 없습니다. 따라서 인터페이스를 정의하고 하나의 책임만을 가지도록 설계를 한 다음 클래스는 해당 인터페이스를 구현하면 됩니다.

## 의존성 역전 원칙

- 상위 모듈은 하위 모듈에 의존해서는 안되며, 하위 모듈 또한 상위 모듈에 의존해서는 안됩니다. 상위 모듈과 하위 모듈은 모두 추상화에 의존해야 합니다.
- 상위 모듈이란 호출자를 의미하고, 하위 모듈은 수신자를 의미합니다.

<br>

## 좋은 내용

- 설계 원칙을 적용하든 디자인 패턴을 적용하든 중요한 것은 코드의 가독성, 확장성, 재사용성, 유지보수성을 향상시켜야 하는 목표가 있어야 합니다.
- 기존 코드에 속성과 메서드를 추가했다고 해서 OCP를 위반했다고 생각하면 안됩니다. 추가한 내용이 기존의 속성을 변경하거나 메서드를 수정하지 않았드면 위반하지 않은 것입니다.
- OCP는 확장 가능한 코드를 작성하기 위한 원칙입니다. 이를 지키기 위해서는 내부 구현이 아닌 추상화에 의존해야 하고, 변하는 부분과 변하지 않는 부분을 잘 파악한 후 변하지 않는 부분을 추상화 레벨로 올리고, 변하는 부분은 내부 구현으로 캡슐화를 진행해야 합니다.


