# 설계 원칙

<br>

## 단일 책임 원칙

- 단일 책임 원칙이란 클래스와 모듈은 하나의 책임 또는 기능만을 수행해야 하는 설계 원칙입니다.
- 단일 책임 원칙은 클래스가 하나의 책임이나 기능을 담당하는 것입니다. 즉 갓 클래스를 구현하는게 아닌 하나의 클래스에 작은 단위와 단일 기능을 가진 클래스를 설계해야 합니다.

### 클래스에 단일 책임이 있는지 판단하는 방법

#### 예시 

- 아래 코드를 보면 UserInfo 클래스에 사용자의 정보와 주소 정보가 속성으로 있습니다. 이때 주소 속성을 Address 클래스로 분할할 수도 있고, 지금처럼 하나의 클래스로 관리할 수 있는데 과연 어떤게 더 단일 책임 원칙에 타당할까요?
  - <b> 단지 클래스만 보고 어떤게 더 타당한지 말할 수 없습니다. 현재 개발하고자 하는 시나리오에 따라 달라질 수 있습니다. 만약 이메일이나 연락처의 경우 민감 정보이기 때문에 마스킹처리가 필요하여 해당 로직이 복잡해진다면 이메일이나 연락처를 다른 클래스로 분리할 수도 있고, 추후 주소에 대한 로직이 복잡해진다면 주소에 대한 속성을 다른 클래스로 분리할 수도 있습니다. </b> 

```java
public class UserInfo {
    
    private final long userId;
    private final String userName;
    private final String email;
    private final String phone;
    private final String provinceOfAddress; // 도
    private final String cityOfAddress;     // 시
    private final String regionOfAddress;   // 구
    private final String detailedAddress;   // 상세 주소
}
```

#### 단일 책임 원칙을 결정하기 위한 원칙들

- 하나의 클래스에 속성이나 함수가 너무 많아 가독성과 유지 보수성에 영향을 미치는가?
- 클래스의 속성들이 다른 클래스에 과하게 의존하여 높은 결합도와 낮은 응집도를 가지는가?
- 하나의 클래스에 private 메서드가 너무 많은가?
- 클래스의 역할이 명확하지 않아 비지니스적으로 명칭을 지정하기 어려운가?

<br>

## 개방 폐쇄 원칙

- 개방 폐쇄 원칙은 확장할 때는 개방, 수정할 때는 폐쇄에 대해 설명하는 원칙입니다.
- 개방 폐쇄 원칙이 이해하기 어려운 이유는 코드를 변경할 때 그 결과를 확장으로 보아야 하는지, 수정으로 보아야하는지 명확하게 구분하기 어렵기 때문입니다.
- <b> 새로운 기능을 추가할 때 기존의 모듈, 클래스, 함수를 수정하기 보다는 기존 코드를 기반으로 모듈, 클래스, 함수등을 추가하는 방식으로 코드를 확장해야 한다는 뜻입니다. </b>

### 확장할 때는 개방, 수정할 때는 폐쇄

- 개방 폐쇄 원칙을 이해하기 위해서는 새로운 기능을 추가할 때는 기존의 모듈, 클래스, 함수를 수정하는것 보다는 기존 코드를 기반으로 모듈, 클래스, 함수를 추가하는 방식으로 코드를 확장하는 것입니다. 약간 모호할 수 있는데 간단한 예제를 살펴보겠습니다.

#### 예시 

- 티켓의 등급에 따라 할인 정책이 달라진다는 가정하에 고민을 하지 않고 개발을 한다면 아래와 같이 성급한 개발을 할 수 있습니다.
- 이때 할인 정책 기능이 추가되는 경우 if문이 증가하게 되고, 단위 테스트 또는 생각해야 하는 점이 늘어나기 때문에 유지보수 비용이 낮아지게 됩니다.

```java
public class Ticket {

    private final long id;
    private final TicketGrade ticketGrade;

    public void calculate() {
        long sum = 0L;

        if (ticketGrade == TicketGrade.VIP) {
            // 고정 3%와 퍼센트 할인 정책에 해당하는 비지니스 로직 작성
        }
        if (ticketGrade == TicketGrade.R) {
            // 퍼센트 할인 정책에 해당하는 비지니스 로직 작성
        }
        if (ticketGrade == TicketGrade.S) {
            // 고정 3% 할인 정책에 해당하는 비지니스 로직 작성
        }
    }
}

public enum TicketGrade {

    VIP, R, S, A, B, C
}
```

<br>

#### 🤔 어떻게 해결할 것인가?

- 티켓을 예매할 때 등급에 따라 할인 정책이 달라진다.에 초점을 맞출 필요가 있다고 생각합니다. 즉, 할인 정책이라는 추상화에 의존해야지 어떻게 할인 정책이 이루어지는지에 대한 내부 구현은 중요하지 않습니다.(물론 중요함)
- 예시 코드가 길어질거 같아서 생략하고, 중요한 점은 DIP와 같은 원칙을 통해서 추상화에 의존한다면 코드의 양은 증가되지만 이점을 챙길 수 있을거 같습니다.
- 여기서는 의존 관계 역전의 원칙에 대한 이해도가 있다면 조금 더 쉽게 이해가 될거 같습니다.

<br>

### 코드를 수정하는 것은 OCP 원칙을 위배하는 것인가?

- 새로운 코드를 추가하더라도 기존 코드에 속성을 추가한다던지, 메서드를 추가하는 일이 종종 생기곤 합니다. 근데 이 경우를 OCP를 위반한다고 생각해야할까요?
- 기존 코드에 속성과 메서드를 추가했다고 해서 수정되었다라고 할 수 있습니다. 하지만 이 추가사항이 기존의 속성을 변경하거나 메서드를 수정하지 않았기 때문에 속성이나 메서드 입장에서 보면 확장으로 간주될 수 있습니다.
- OCP의 목적을 상기시켜보면 코드의 수정이 기존에 작성되어 있던 코드와 단위 테스트를 깨뜨리지 않는 한 이는 OCP를 위반하지 않는다고 판단해도 무방합니다.
- 새로운 기능을 추가할 때 모듈, 클래스, 메서드의 코드를 전혀 수정하지 않는 것은 불가능합니다. 따라서 우리는 수정을 아예 안 하는 것이 아니라 수정을 가능한 한 내부 구현에 대한 수정이 아닌 상위 수준의 코드에서 진행해야합니다.

### 확장할 때는 개방, 수정할 때는 폐쇄를 달성하는 방법

- OCP는 코드의 확장성 문제라고 볼 수 있는데, 이는 코드가 확장하기 쉬운 구조를 가지고 있는지 판단하는 표준에 해당합니다.
- <b> 확장 가능한 코드를 작성하기 위해서는 내부 구현이 아닌 추상화에 의존해야 하고, 변하는 부분과 변하지 않는 부분을 잘 파악한 후 변하지 않는 부분을 추상화를 도입하고 변하는 부분은 내부 구현으로 캡슐화를 진행해야 합니다. </b>

### 프로젝트에 OCP를 유연하게 적용하는 방법

- 프로젝트에 OCP를 적용하기 위해서는 우선 도메인 지식이 갖춰져야합니다. 도메인 지식 없이 확장 가능한 코드를 만들고 싶은 유혹에 의해 코드의 가독성은 떨어뜨리고 복잡성만 증가될 수 있습니다.
- 그러므로 잘 알지 못한다면 우선 가독성에 신경을 쓰고 추후에 새로운 기능을 도입해야 한다면 그때 리팩토링을 진행하면서 OCP를 적용해도 늦지 않습니다.

<br>

## 좋은 내용

- 설계 원칙을 적용하든 디자인 패턴을 적용하든 중요한 것은 코드의 가독성, 확장성, 재사용성, 유지보수성을 향상시켜야 하는 목표가 있어야 합니다.
- 기존 코드에 속성과 메서드를 추가했다고 해서 OCP를 위반했다고 생각하면 안됩니다. 추가한 내용이 기존의 속성을 변경하거나 메서드를 수정하지 않았드면 위반하지 않은 것입니다.
- OCP는 확장 가능한 코드를 작성하기 위한 원칙입니다. 이를 지키기 위해서는 내부 구현이 아닌 추상화에 의존해야 하고, 변하는 부분과 변하지 않는 부분을 잘 파악한 후 변하지 않는 부분을 추상화 레벨로 올리고, 변하는 부분은 내부 구현으로 캡슐화를 진행해야 합니다.


