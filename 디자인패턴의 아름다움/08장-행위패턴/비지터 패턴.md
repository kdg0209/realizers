# 비지터 패턴

- 비지터 패턴은 데이터 구조와 해당 구조에서 수행되는 비지니스 로직을 분리하여 구현하는 패턴입니다.
- 방문자라고하는 visitor가 각 데이터 구조를 순회하면서 비지니스 로직을 처리하고 데이터 구조는 Visitor를 받아들입니다.(accept)

### 구조 

![스크린샷 2024-05-17 오후 10 25 16](https://github.com/kdg0209/realizers/assets/80187200/2f60c788-cb71-4561-8650-5c98589bb0b4)

<br>

### 비지터 패턴을 적용하지 않은 예제

- 아래 코드 예제는 결제하고자 하는 어떠한 상품에 대해 서비스에서 제공하고 있는 선결제 기능을 사용하는 것인데 포인트, 쿠폰, 현금을 통해 선결제를 할 수 있습니다.

```java
// 선결제
public abstract class PrePayment {

    protected abstract long price();
}

// 포인트 선결제
public class Point extends PrePayment {

    @Override
    protected long price() {
        // 포인트 관련 로직 처리 후 결과값 반환
        return 1000L;
    }
}

// 쿠폰 선결제
public class Coupon extends PrePayment {

    @Override
    protected long price() {
        // 쿠폰 관련 로직 처리 후 결과값 반환
        return 500L;
    }
}

// 현금 선결제
public class Cash extends PrePayment {

    @Override
    protected long price() {
        // 현금 관련 로직 처리 후 결과값 반환
        return 15000L;
    }
}

public class Main {

    private static final List<PrePayment> PRE_PAYMENTS = List.of(new Cash(), new Coupon(), new Point());

    public static void main(String[] args) {

        long totalPrePayment = PRE_PAYMENTS.stream()
                .mapToLong(PrePayment::price)
                .sum();

        System.out.println("총 선결제 금액: " + totalPrePayment); // 16500
    }
}
```

<br> 

### 비지터 패턴을 적용하지 않은 코드에 문제점이 있다고 합니다? (개인적으로 잘 모르겠음)

1. 새로운 기능을 추가하기 위해 모든 클래스의 코드를 수정해야하기 때문에 OCP 원칙을 위배합니다.
    - 새로운 기능을 추가하더라도 기존 클래스의 속성이나 기존 메서드를 수정하지 않는다면 OCP에 위배안되는거 아닌가?(03장이랑 말이 다른데?)
    - 코드의 수정이 기존에 작성되어 있던 코드와 단위 테스트를 깨뜨리지 않는 한 OCP를 위반하지 않는다고 판단해도 무방하며, 추가사항이 기존 속성이나 메서드를 변경하지 않았기 때문에 확장으로 간주할 수 있다고 했는데,,,
3. 기능이 추가됨에 따라 각 클래스의 코드도 증가하기 때문에 코드의 가독성과 유지보수성이 안좋아집니다.
    - 기능이 추가됨에 따라 다른 클래스에 위임을 하는게 아니라 해당 클래스에서 처리함으로써 응집도 있고 결합도가 낮아지는거 아닌가? 클래스의 코드가 어느정도 증가하는지에 따라 가독성과 유지보수가 낮아질 수 있지만 해당 클래스가 갓 클래스가 되지 않도록 설계 및 개발한다면 괜찮은게 아닌가?
4. 모든 상위 계층 비지니스 로직이 Point, Coupon, Cash 클래스에 결합되어 있기 때문에 클래스의 책임이 단일하지 않습니다.
    - 클래스의 책임이 단일하지 않다는게 무슨 의미일까? 개인적으로 각 클래스에서 예시로 들었던 선결제에 사용되는 금액만 잘 계산하여 반환해주는게 책임아닌가?

<br> 

### 아무튼 비지터 패턴을 적용한 예제

- 아래는 비지터 패턴을 적용한 예제 코드이며, 포인트, 쿠폰, 현금 클래스는 자신의 클래스에서 금액을 계산하는게 아니라 방문자 인터페이스의 구현체에게 위임을 하여 선결제 금액을 계산하게 됩니다.

```java
public interface Visitor {

    long price(Point point);
    long price(Coupon coupon);
    long price(Cash cash);
}

// 방문자 구현체
public class PrePayment implements Visitor {

    @Override
    public long price(Point point) {
        // 포인트 관련 로직 처리 후 결과값 반환
        return 1000L;
    }

    @Override
    public long price(Coupon coupon) {
        // 쿠폰 관련 로직 처리 후 결과값 반환
        return 500L;
    }

    @Override
    public long price(Cash cash) {
        // 현금 관련 로직 처리 후 결과값 반환
        return 15000L;
    }
}

// Element에 속하는 인터페이스
public interface Price {

    long accept(Visitor visitor);
}

public class Point implements Price {

    @Override
    public long accept(Visitor visitor) {
        return visitor.price(this);
    }
}

public class Coupon implements Price {

    @Override
    public long accept(Visitor visitor) {
        return visitor.price(this);
    }
}

public class Cash implements Price {

    @Override
    public long accept(Visitor visitor) {
        return visitor.price(this);
    }
}

public class Main {

    private static final List<Price> PRICES = List.of(new Cash(), new Coupon(), new Point());

    public static void main(String[] args) {

        Visitor prePayment = new PrePayment();
        long totalPrePayment =  PRICES.stream()
                .mapToLong(price -> price.accept(prePayment))
                .sum();

        System.out.println("총 선결제 금액: " + totalPrePayment); // 16500
    }
}
```

<br>

### 하나의 기능을 더 추가해보자 (각 선결제 마다 적립 마일리지가 다르다는 기능)

- 만약 현금 선결제시 3%의 마일리지를 주고, 포인트 결제시 2%의 마일리지 지급. 쿠폰 결제시 1%의 마일리지 지급을 하는 기능을 추가해야한다고 했을 때 어떻게 할 수 있을까?

```java
```

<br>

#### 👍 장점

#### 🤔 단점

#### 개인적인 생각






