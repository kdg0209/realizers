# 객체지향 프로그래밍 패러다임

<br>

## 객체지향이란 무엇인가?

- 객체지향이란 공통의 목적을 달성하기 위해 클래스간 역할, 책임을 나누고 협력을 통해 공통의 목적을 달성하는 것입니다.
- 각 클래스마다 역할과 책임을 나누고 객체가 다른 객체에게 도움을 요청할 때 비로소 협력이 이루어집니다. 협력은 클래스의 메서드를 통해 이루어질 수 있습니다.
- 객체지향에 대한 내용은 오브젝트라는 도서를 읽으면 도움이 많이 될거 같다.

#### 객체지향 프로그래밍과 객체지향 프로그래밍 언어

- 객체지향 프로그래밍은 프로그래밍 패러다임 혹은 프로그래밍 스타일을 의미합니다. 코드를 구성하는 기본 단위를 클래스 또는 객체를 사용하고, 코드 설계와 구현의 초석을 캡슐화, 추상화, 상속, 다형성의 4가지 특성을 사용합니다.
- 객체지향 프로그래밍 언어는 클래스 또는 객체 문법을 지원하며, 이 문법은 캡슐화, 추상화, 상속, 다형성을 제공합니다.
- 객체지향 프로그래밍 언어로만 객체지향 프로그래밍을 할 수 있는게 아니라 자바스크립트를 사용하더라도 객체지향 프로그래밍적으로 개발 할 수 있습니다.

<br>

## 캡슐화, 추상화, 상속, 다형성이 등장한 이유 

### 캡슐화

- 캡슐화는 데이터의 은닉 및 데이터에 대한 접근을 보호하는데, 클래스는 접근 가능한 인터페이스를 제한적으로 둠으로써 클래스의 내부 정보나 데이터에 대한 외부 접근을 적절히 차단합니다.
- 클래스의 속성에 대해 접근 제한을 두지 않는다면 모든 곳에서 클래스의 속성에 접근하여 값을 수정할 수 있습니다. 얼핏보면 좀 더 유연해지지 않을까? 라는 생각이 들 수 있지만 과도한 유연성은 코드의 응집도를 낮추고, 결합도를 높일 수 있습니다.

```java
public class Wallet {

    private String id;
    private LocalDateTime createdDatetime;
    private BigDecimal balance;
    private LocalDateTime balanceLastModifiedDatetime;

    public Wallet() {
        this.id = UUID.randomUUID().toString();
        this.createdDatetime = LocalDateTime.now();
        this.balance = BigDecimal.ZERO;
        this.balanceLastModifiedDatetime = LocalDateTime.now();
    }

    public void increaseBalance(BigDecimal balance) {
        if (isLessThan(balance)) {
            throw new IllegalArgumentException("");
        }

        this.balance.add(balance);
        this.balanceLastModifiedDatetime = LocalDateTime.now();
    }

    public void decreaseBalance(BigDecimal balance) {
        if (isLessThan(balance)) {
            throw new IllegalArgumentException("");
        }

        if (isGreaterThan(balance)) {
            throw new IllegalArgumentException("");
        }

        this.balance.subtract(balance);
        this.balanceLastModifiedDatetime = LocalDateTime.now();
    }

    private boolean isLessThan(BigDecimal balance) {
        return balance.compareTo(BigDecimal.ZERO) < 0;
    }

    private boolean isGreaterThan(BigDecimal balance) {
        return balance.compareTo(this.balance) > 0;
    }
}
```

### 추상화

- 추상화란 메서드의 내부 구현을 숨기는 것을 의미합니다.
- 추상화를 사용하면 기능의 구현 방식에 대해 고민하지 않고, 메서드가 제공하는 기능에만 집중할 수 있습니다.
- 자바에서는 interface와 abstract 키워드를 사용하여 추상화를 구현할 수 있습니다.

```java
public interface PresignedUrl {
    
    void putObject(Object o);
    
    Object getObject(String objectId);
}

public class AwsPresignedUrl implements PresignedUrl {

    @Override
    public void putObject(Object o) {

    }

    @Override
    public Object getObject(String objectId) {
        return null;
    }
}

public class NcpPresignedUrl implements PresignedUrl {

    @Override
    public void putObject(Object o) {

    }

    @Override
    public Object getObject(String objectId) {
        return null;
    }
}
```

### 상속

- 상속은 '고양이는 포유류의 일종이다' 처럼 클래스 사이의 is-a 관계를 나타내는데 사용됩니다.
- 상속의 가장 큰 역할은 코드 재사용성입니다. 만약 서로 다른 두 개의 클래스에 동일한 속성과 반환값이 같은 메서드가 있다면 중복되는 속성과 메서드를 상위 클래스로 옮기고, 두 개의 하위 클래스에서 상위 클래스를 상속받아 코드 재사용성을 높일 수 있습니다.
- 하지만 상속을 과도하게 사용할 경우 강결합이 발생하게 되고, 코드의 가독성과 유지보수성이 낮아질 수 있습니다. 상속 보다는 합성을 사용하고, 유틸 클래스나 여러가지 방법으로 상속의 문제점을 해결할 수 있습니다.

### 다형성

- 다형성이란 코드를 실행하는 과정에서 하위 클래스를 상위 클래스를 대신 사용하고, 하위 클래스의 메서드를 호출할 수 있는 특성을 의미합니다.
- 다형성을 이용하면 기존 코드를 수정하지 않고 새로운 기능을 추가할 수 있습니다. 확장성이 있으며 OCP 원칙을 지킬 수 있고, 코드 재사용성을 향상시킬 수 있습니다.

```java
public interface PayService {

    void pay();
}

public class KakaoPayService implements PayService {

    @Override
    public void pay() {
        System.out.println("카카오페이를 사용하여 결제...");
    }
}

public class NaverPayService implements PayService {

    @Override
    public void pay() {
        System.out.println("네이버페이를 사용하여 결제...");
    }
}

public class PaymentService {

    private final PayService payService;

    public PaymentService(PayService payService) {
        this.payService = payService;
    }
}

class Main {

    public static void main(String[] args) {
        PaymentService paymentService = new PaymentService(new KakaoPayService());
    }
}
```

<br>

## 객체지향 분석, 객체지향 설계, 객체지향 프로그래밍을 수행하는 방법

- 이 절에서는 객체지향 분석, 설계, 프로그래밍을 어떻게 해야하는지 이해를 해보고 설계 원칙과 디자인 패턴에 대한 기초를 쌓을 수 있도록 요구사항 분석, 책임 분담, 클래스 정의, 상호 작용 및 조합에 대해 소개합니다.

<br>

### 요구사항 분석 방법(객체지향 수행 분석 방법)

- 관리자가 제시한 요구 사항이 다소 모호하고 일반적인 내용으로만 채워져 있는 경우(추상적인 인증 기능) 요구사항 분석을 위해 완벽한 해결 방법을 즉시 제공하는 대신, 대략적인 기본 계획을 제공한 다음 천천히 단계별로 반복적으로 최적화합니다.

#### 1. 기본 분석

- 관리자가 제시한 요구 사항에 대해 지식이 부족하다면 관련 아티클을 찾아 봅니다.
- 인증 기능을 제공해야 한다면 일반적인 id, password 방법을 사용할 지, OAuth, 대칭키, 배대칭키를 동해 인증을 할 지 등을 알아봅니다.

#### 2. 1차 분석

- 기본 분석을 통해 알게 된 내용을 점검하며, 부족한 부분이 무엇인지 파악 후 보완합니다.

#### 3. 2차 분석

- 1차 분석을 통해 부족한 부분을 파악하고 보완합니다.

#### 4. 3차 분석

- 추가적인 고려 사항이 없는지 확인하고, 계속하여 진행합니다.

<br>

### 객체지향 설계 방법

#### 1. 책임과 기능을 나누고 어떤 클래스가 있는지 확인한다.

- 일번적인 객체지향 도서에는 클래스가 현실 세계의 사물을 모델링한다고 하는데 모든 요구사항이 대응될 수 있는것은 아닙니다. 일부 추상적인 개념의 경우 현실 세계의 사물을 클래스로 정의할 수 없는 경우도 있습니다.
- 요구사항 명세를 단일 책임의 원칙에 따라 최대한 분해해야 합니다.
- 단일 책임 원칙에 따라 분해했다면 관련된 역할을 수행하는 기능들을 클래스화합니다.

#### 2. 클래스, 클래스의 속성과 메서드 정의

- 1번 과정에서 클래스를 만들었다면 요구사항 명세에서 동사나 명사를 추출하여 속성과 메서드를 정의합니다.
- 위 정의 방법은 사전같은 내용이므로 와닿지 않습니다. 차라리 기능을 수행하는 메서드를 우선 만들고 단위 테스트를 진행하면서 클래스의 속성을 파악하고 메서드를 리팩토링하는 과정을 거치는게 조금 더 와닿는거 같습니다.

#### 3. 클래스 간의 상호 작용 정의

- 일반화
    - 일반화는 단순한 상속 관계로 이해될 수 있습니다.
- 실체화
    - 실체화는 일반적으로 인터페이스와 구현 클래스 간의 관계를 나타냅니다.
- 집합
    - 집합은 포함 관계입니다.
    - 집합 관계는 클래스 간의 수명 주기가 다릅니다.
- 합성
    - 합성은 포괄적인 관계입니다.
    - 합성 관계는 수명 주기가 동일합니다.
- 연관
    - 연관은 집합과 합성의 두 가지 속성을 모두 가지는 매우 약한 관계입니다.
- 의존
    - 의존은 연관 관계를 포함하며, 연관 관계보다 더 약한 관계입니다.
 
- 위 6가지가 있지만 프로그래밍 관점에서는 일반화, 실체화, 의존, 합성에 대해서만 알면됩니다.

#### 4. 클래스 연결 및 실행 엔트리 포인트 제공

- 클래스와 클래스 간의 상호 작용을 설계했다면 필요한 클래스를 조합하고 실행 엔트리 포인트를 제공합니다.

<br>

### 객체지향 프로그래밍을 하는 방법

- 객체지향 프로그래밍 작업은 설계한 클래스들을 코드로 실체화하는 것입니다.
- 코드화하면서 다시 한번 클래스에 역할과 책임이 명확한지, 잘 분배되어 있는지 공개 인터페이스를 통해 협력을 잘 수행할 수 있는지 생각하며 코드화를 진행합니다.
- 코드화를 진행하면서도 리팩토링을 하며, 반본적으로 리팩토링을 진행합니다.














