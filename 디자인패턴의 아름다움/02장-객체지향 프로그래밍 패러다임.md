# 객체지향 프로그래밍 패러다임

<br>

## 객체지향이란 무엇인가?

- 객체지향이란 공통의 목적을 달성하기 위해 클래스간 역할, 책임을 나누고 협력을 통해 공통의 목적을 달성하는 것입니다.
- 각 클래스마다 역할과 책임을 나누고 객체가 다른 객체에게 도움을 요청할 때 비로소 협력이 이루어집니다. 협력은 클래스의 메서드를 통해 이루어질 수 있습니다.
- 객체지향에 대한 내용은 오브젝트라는 도서를 읽으면 도움이 많이 될거 같다.

#### 객체지향 프로그래밍과 객체지향 프로그래밍 언어

- 객체지향 프로그래밍은 프로그래밍 패러다임 혹은 프로그래밍 스타일을 의미합니다. 코드를 구성하는 기본 단위를 클래스 또는 객체를 사용하고, 코드 설계와 구현의 초석을 캡슐화, 추상화, 상속, 다형성의 4가지 특성을 사용합니다.
- 객체지향 프로그래밍 언어는 클래스 또는 객체 문법을 지원하며, 이 문법은 캡슐화, 추상화, 상속, 다형성을 제공합니다.
- 객체지향 프로그래밍 언어로만 객체지향 프로그래밍을 할 수 있는게 아니라 자바스크립트를 사용하더라도 객체지향 프로그래밍적으로 개발 할 수 있습니다.

<br>

## 캡슐화, 추상화, 상속, 다형성이 등장한 이유 

### 캡슐화

- 캡슐화는 데이터의 은닉 및 데이터에 대한 접근을 보호하는데, 클래스는 접근 가능한 인터페이스를 제한적으로 둠으로써 클래스의 내부 정보나 데이터에 대한 외부 접근을 적절히 차단합니다.
- 클래스의 속성에 대해 접근 제한을 두지 않는다면 모든 곳에서 클래스의 속성에 접근하여 값을 수정할 수 있습니다. 얼핏보면 좀 더 유연해지지 않을까? 라는 생각이 들 수 있지만 과도한 유연성은 코드의 응집도를 낮추고, 결합도를 높일 수 있습니다.

```java
public class Wallet {

    private String id;
    private LocalDateTime createdDatetime;
    private BigDecimal balance;
    private LocalDateTime balanceLastModifiedDatetime;

    public Wallet() {
        this.id = UUID.randomUUID().toString();
        this.createdDatetime = LocalDateTime.now();
        this.balance = BigDecimal.ZERO;
        this.balanceLastModifiedDatetime = LocalDateTime.now();
    }

    public void increaseBalance(BigDecimal balance) {
        if (isLessThan(balance)) {
            throw new IllegalArgumentException("");
        }

        this.balance.add(balance);
        this.balanceLastModifiedDatetime = LocalDateTime.now();
    }

    public void decreaseBalance(BigDecimal balance) {
        if (isLessThan(balance)) {
            throw new IllegalArgumentException("");
        }

        if (isGreaterThan(balance)) {
            throw new IllegalArgumentException("");
        }

        this.balance.subtract(balance);
        this.balanceLastModifiedDatetime = LocalDateTime.now();
    }

    private boolean isLessThan(BigDecimal balance) {
        return balance.compareTo(BigDecimal.ZERO) < 0;
    }

    private boolean isGreaterThan(BigDecimal balance) {
        return balance.compareTo(this.balance) > 0;
    }
}
```

### 추상화

- 추상화란 메서드의 내부 구현을 숨기는 것을 의미합니다.
- 추상화를 사용하면 기능의 구현 방식에 대해 고민하지 않고, 메서드가 제공하는 기능에만 집중할 수 있습니다.
- 자바에서는 interface와 abstract 키워드를 사용하여 추상화를 구현할 수 있습니다.

```java
public interface PresignedUrl {
    
    void putObject(Object o);
    
    Object getObject(String objectId);
}

public class AwsPresignedUrl implements PresignedUrl {

    @Override
    public void putObject(Object o) {

    }

    @Override
    public Object getObject(String objectId) {
        return null;
    }
}

public class NcpPresignedUrl implements PresignedUrl {

    @Override
    public void putObject(Object o) {

    }

    @Override
    public Object getObject(String objectId) {
        return null;
    }
}
```

### 상속

- 상속은 '고양이는 포유류의 일종이다' 처럼 클래스 사이의 is-a 관계를 나타내는데 사용됩니다.
- 상속의 가장 큰 역할은 코드 재사용성입니다. 만약 서로 다른 두 개의 클래스에 동일한 속성과 반환값이 같은 메서드가 있다면 중복되는 속성과 메서드를 상위 클래스로 옮기고, 두 개의 하위 클래스에서 상위 클래스를 상속받아 코드 재사용성을 높일 수 있습니다.
- 하지만 상속을 과도하게 사용할 경우 강결합이 발생하게 되고, 코드의 가독성과 유지보수성이 낮아질 수 있습니다. 상속 보다는 합성을 사용하고, 유틸 클래스나 여러가지 방법으로 상속의 문제점을 해결할 수 있습니다.

### 다형성

- 다형성이란 코드를 실행하는 과정에서 하위 클래스를 상위 클래스를 대신 사용하고, 하위 클래스의 메서드를 호출할 수 있는 특성을 의미합니다.
- 다형성을 이용하면 기존 코드를 수정하지 않고 새로운 기능을 추가할 수 있습니다. 확장성이 있으며 OCP 원칙을 지킬 수 있고, 코드 재사용성을 향상시킬 수 있습니다.

```java
public interface PayService {

    void pay();
}

public class KakaoPayService implements PayService {

    @Override
    public void pay() {
        System.out.println("카카오페이를 사용하여 결제...");
    }
}

public class NaverPayService implements PayService {

    @Override
    public void pay() {
        System.out.println("네이버페이를 사용하여 결제...");
    }
}

public class PaymentService {

    private final PayService payService;

    public PaymentService(PayService payService) {
        this.payService = payService;
    }
}

class Main {

    public static void main(String[] args) {
        PaymentService paymentService = new PaymentService(new KakaoPayService());
    }
}
```




