# 카프카 시작하기

<br>

## 1. 발행/구독 메시지 전달

- 메시지의 전송자는 어떤 형태로든 메시지를 전달하고, 수신자는 메시지를 받습니다. 다만 발행/구독 시스템에서는 보통 전송자가 직접 수신자에게 메시지를 전달하는게 아니라 중간에 브로커를 두고 브로커를 통해 메시지를 전달하고 받습니다.

#### 1-1. 초기의 발행/구독 시스템

- 초기의 발행-구독 패턴에서는 전송자와 수신자 사이에 프로세스간 통신 채널을 만들어 시스템을 설계했다고 합니다. 즉 서버끼리 point-to-point 방법이였습니다.

<br>

## 2. 카프카 입문

- 카프카는 '분산 스트리밍 플랫폼' 또는 '분산 커밋 로그'라 불립니다.
- 카프카는 전달받은 메시지를 파일에 작성함으로써 메시지들을 지속성있게 보존이 가능하고, 일관성 있게 복구할 수 있도록 고안되엇습니다. 또한 카프카에 저장된 데이터는 순서를 유지(append-only)한채로 지속성있게 보관되며 결정적으로 읽을 수 있습니다.

#### 2-1. 메시지와 배치

- 카프카에서 데이터의 기본 단위는 '메시지'입니다.
- '키'라는 개념이 있는데, '키'는 메시지를 특정 파티션에게 전달할 수 있도록 하는 역할을 수행합니다. '키'를 통해 해시값을 만든 뒤 토픽의 파티션 수로 나눴을 때 추출되는 나머지 값으로 특정 파티션에 메시지를 저장하는 것입니다. 파티션 수가 변하지 않는 이상은 항상 같은 파티션으로 메시지가 전달됩니다.

배치

- 카프카는 효율성을 위해 메시지를 배치 단위로 저장합니다. 배치는 메시지의 집합일 뿐인데, 만약 메시지가 생성될 때마다 파티션에 쓰면 네트워크로 인해 오버헤드가 증가되는 문제가 발생합니다. 그렇기 때문에 메시지를 배치 단위로 모아서 작성하면 이러한 오버헤드를 줄일 수 있습니다.
- 배치가 크다고 해서 무조건 좋은것은 아닙니다. 한번에 모아서 처리하니 처리량은 증가될 수 있지만 하나 하나 메시지를 빨리 처리해야 하는 경우에는 지연이 늘어날 수 있기 때문입니다.

<br>

#### 2-2. 토픽과 파티션

- 카프카에 저장되는 메시지는 '토픽' 단위로 분류됩니다. 토픽은 다시 여러개의 '파티션'으로 나뉘어집니다. 메시지는 파티션의 가장 끝에 추가만 됩니다.
- 파티션 내부에서는 append-only이므로 메시지의 순서 보장이 가능하지만 토픽의 범주에서 바라보면 메시지 순서를 보장할 수 없습니다. 

![스크린샷 2024-12-31 오후 4 58 42](https://github.com/user-attachments/assets/d564d3f2-4029-4070-a1f9-50bfc5ea85f8)

<br>

#### 2-3. 프로듀서와 컨슈머

프로듀서

- 프로듀서는 메시지를 생상하는 역할을 수행하며, 메시지를 브로커에게 전달하게 됩니다. 메시지를 토픽에 속한 파티션에게 라운드 로빈 기법으로 고르게 전달할 수도 있지만 특정 파티션에게만 전달할 수도 있습니다.

컨슈머

- 컨슈머는 메시지를 소비하는 역할을 수행하며, 특정 토픽을 구독하여 파티션에 쓰여진 순서대로 메시지를 읽습니다.
- 컨슈머는 메시지에 offset을 기록함으로써 메시지를 어디까지 읽엇는지 파악할 수 있습니다. 파티션의 메시지는 고유한 offset을 가지며, 뒤에 오는 메시지가 앞의 메시지보다 항상 더 큰 offset을 가집니다.
- 컨슈머는 컨슈머 그룹에 참여해야하며, 컨슈머 그룹은 파티션이 하나의 컨슈머에 의해서만 읽히도록 합니다.
- 컨슈머 그룹을 통해 컨슈머들을 수평 확장할 수 있을뿐만 아니라 컨슈머 중 하나에 장애가 발생하더라도 다른 컨슈머가 이를 대처할 수 있습니다.

![스크린샷 2025-01-01 오후 12 33 19](https://github.com/user-attachments/assets/2ecf52d4-749a-4a98-8d5f-4ad411fed456)

<br>

#### 2-4. 브로커와 클러스터

- 하나의 카프카 서버를 브로커라합니다. 브로커는 프로듀서로부터 메시지를 전달받아 offset을 할당한 뒤 디스크에 저장하게 됩니다.
- 카프카 브로커는 클러스터 내에 속하며, 하나의 클러스터 안에 여러개의 브로커가 포함될 수 있습니다. 그리고 그 중 하나의 브로커가 컨트롤러 역할을 수행하며 컨트롤러는 파티션을 브로커에게 할당해주거나 장애가 발생한 브로커가 있는지 모니터링하게 됩니다.
- 브로커는 파티션 리더와 팔로워로 구분하게 되고 팔로워가 있는 이유는 리더에 문제가 발생했을 때 팔로워가 리더로 승격되어 고가용성을 보장하기 위함입니다.

<br>

#### 2-5. 다중 클러스터

- 서비스가 확장되어감에 따라 다수의 클러스터를 운용하는게 더 나은 경우가 있는데 이는 아래와 같은 장점이 있습니다.
  - 데이터 유형별 분리
  - 보안 요구사항을 충족시키기 위한 격리
  - 재해 복구를 대비한 다중화

<br>

## 3. 왜 카프카인가?

#### 3-1. 다중 컨슈머

- 컨슈머는 상호 관섭없이 어떠한 메시지 스트림도 읽을 수 있도록 설계 되었으며, 이는 하나의 메시지를 하나의 클라이언트에서만 소비할 수 있도록 설계되어 있는 많은 queue 시스템과 차이를 보입니다.
- 다수의 컨슈머는 컨슈머 그룹의 일원으로써 하나의 스트림을 여럿이서 나눠 읽을 수 있습니다.

<br>

#### 3-2. 디스크 기반 보존

- 메시지는 디스크에 쓰여진 뒤 설정된 보유 규칙에 따라 보유할 수 있으며, 이 보유 규칙들은 토픽별로 설정이 가능하기 때문에 서로 다른 메시지 스트림이 필요에 따라 서로 다른 보유 규칙을 가질 수 있습니다.
- 컨슈머에 문제가 생기더라도 메시지는 디스크에 저장되어 있기 때문에 컨슈머를 다시 시작하면 offset을 기반으로 다시 메시지를 읽을 수 있습니다.

<br>

#### 3-3. 확장성과 고성능 

- 브로커의 수를 증가시키거나 토픽의 파티션 수를 증가시킴으로써 확장성을 유연하게 가져갈 수 있습니다.
- Zero Copy를 사용하여 성능을 향상시켰습니다.

#### 💡 일반적인 데이터 전달

- 일반적으로 디스크로부터 데이터를 읽고, 읽어온 데이터를 네트워크로 전송하는 흐름은 아래 그림과 같습니다.
  1. read system call을 통해 디스크에 있는 데이터를 kernel 영역에 있는 read buffer로 데이터를 복사합니다.
  2. read buffer에 있는 데이터를 application의 buffer로 복사합니다.
  3. send system call을 통해 application의 buffer에 있는 데이터를 kernel 영역에 있는 socket buffer로 복사합니다.
  4. socket buffer에 있는 데이터를 실제 네트워크로 전송시키 위해 NIC에 있는 buffer로 데이터를 복사합니다.

![스크린샷 2025-01-01 오후 10 36 29](https://github.com/user-attachments/assets/71f47f81-aa87-4c03-80f5-8bb26b59ef53)

<br>

#### 💡 Zero Copy를 사용하면?

- 자바에서는 transferTo() 메서드를 통해 zero copy를 사용할 수 있습니다.
  1. application에서 transferTo() 메서드를 호출합니다.
  2. read system call을 통해 디스크로부터 데이터를 읽어 read buffer로 데이터를 복사합니다.
  3. kernel 모드에서 바로 socket buffer로 데이터를 복사합니다.
  4. socket buffer에서 복사된 데이터를 NIC buffer로 복사합니다.

![스크린샷 2025-01-01 오후 10 41 24](https://github.com/user-attachments/assets/db3ff5c4-a3bd-4798-b221-620779c366fd)


