# 정확히 한 번 의미의 구조

- 카프카의 '정확히 한 번' 의미 구조는 멱등적 프로듀서와 트랜잭션 구조의 조합으로 이루어 집니다.
- 멱등적 프로듀서는 재시도로 인해 발생하는 중복을 방지해줍니다.
- 트랜잭션은 컨슈머 애플리케이션에서 '정확히 한 '처리를 보장해줍니다.

<br>

## 1. 멱등적 프로듀서

- 멱등적이란 동일한 작업을 N번 실행해도 결과는 한 번만 동작된것처럼 결과가 같은 것을 의미합니다.
- 멱등적 동작이 아닌 '최소 한 번'만 동작하도록 처리한다면 프로듀서가 메시지를 재시도함으로써 컨슈머에서는 중복처리의 발생 가능성이 생깁니다.

### 1-1. 프로듀서의 메시지 전송 방식

#### 최대 한 번

- 최대 한 번은 `Acks:0`으로 설정한 것을 의미합니다. 프로듀서는 브로커에게 메시지를 보낸 후 응답을 받지 않습니다. 즉 `fire and forget`방식입니다.

#### 최소 한 번

- 최소 한 번은 `Acks:1`로 설정한 것을 의미합니다. 프로듀서는 브로커에게 메시지를 보내고 응답을 받게 됩니다.
- 하지만 이 방식에서는 프로듀서가 브로커로부터 Ack를 받지 못했을 때 브로커가 메시지를 저장은 했지만 응답을 못했는지, 아니면 메시지 저장과 응답을 모두 못했는지 판단할 수 없습니다. 만약 브로커가 메시지는 저장했지만 프로듀서에게 Ack를 보내지 못한 경우 프로듀서는 메시지를 재발행하게 되어 메시지 중복이 발생할 수 있습니다.

#### 정확히 한 번

- 정확히 한 번은 `Acks:all` 또는 `Acks:-1`로 설정한 것을 의미합니다. 이 방식은 멱등성을 가장 잘 따르며, 메시지는 딱 한 번 전송되고 어떠한 메시지도 손실되지 않아야 합니다.
- 리더 파티션 뿐만 아니라 ISR 그룹 내에 있는 모든 팔로워 파티션에 메시지가 처리되었다는 확인을 받고나서 리더 파티션은 프로듀서에게 응답을 하게 됩니다.
- 카프카 3.0 버전이후로는 기본 설정입니다.

#### 🧐 정확히 한 번이여도 중복이 발생하지 않을까?

- 아래 그림은 프로듀서가 브로커에게 메시지를 보내고 정상적으로 Ack를 받는 상황입니다. 하지만 프로듀서가 브로커로부터 보낸 메시지에 대한 응답이 네트워크 지연이나 다른 이유로 인해 응답을 받지 못한다면 어떻게 될까요?

![스크린샷 2025-01-22 오후 9 40 54](https://github.com/user-attachments/assets/8211334f-f492-411f-959e-7b01a17f2f53)

#### 📌 네트워크 지연으로 중복이 발생하는 경우

- 아래 그림에서는 프로듀서가 브로커에게 `Y`라는 메시지를 보냈는데, 이 메시지는 파티션에 정상적으로 저장이 되었지만 브로커 네트워크 이슈로 인해 프로듀서에게 Ack를 전달하지 못하였습니다. 이 때 프로듀서는 재시도 정책에 의해 Retry가 수행되고 다시 브로커에게 메시지 `Y`를 보내게 됩니다. 그리고 브로커는 다시 파티션에 `Y`를 저장하게 되고, 프로듀서에게 응답을 보내면 결과적으로 메시지 중복이 발생하게 됩니다.

![스크린샷 2025-01-22 오후 9 48 31](https://github.com/user-attachments/assets/123b20ab-ec0f-4d47-9f40-1dc2c1d44dc6)

#### 🧐 그럼 어떤 구성이 더 필요한가?

- 정확히 한 번을 구현하기 위해서는 `Acks:-1`뿐만 아니라 `idempotent`설정과 브로커의 `max.in.flight.requests.per.connection` 설정, `min.insync.replicas` 설정, `retries` 설정을 함께 고려해야 합니다.

<br>

## 2. 멱등성 보장 

- 멱등성이란 프로듀서가 브로커에게 메시지를 전달했지만 네트워크 이슈로 인해 Ack를 받지 못한 경우에도 중복 메시지 전달 및 저장을 방지하는 것입니다.
- 이를위해 카프카는 프로듀서 아이디(PID)와 시퀀스 번호를 기반으로 메시지를 추적하고 중복 메시지를 판별하게 됩니다.

### 2-1. enable.idempotence

- 카프카 3.0버전 이후로는 기본적으로 `Acks:-1`과 `enable.idempotence:true` 설정이 기본입니다.
- `enable.idempotence:true`로 설정한다면 아래 그림에서 보이는 것처럼 프로듀서에는 고유한 아이디(PID)가 할당받게 됩니다.
- 프로듀서가 브로커에게 메시지를 보낼 때 PID와 순차적으로 증가하는 시퀀스 번호를 받게되고, 프로듀서가 보낸 메시지는 각 토픽의 파티션별로 시퀀스가 유지되고 브로커는 파티션별로 처리된 `PID-시퀀스 번호` 조합 중 가장 큰 값을 추적합니다.

#### 💡 정상적인 경우

- 정상적인 경우에는 과정은 아래와 같습니다.

![스크린샷 2025-01-22 오후 9 59 49](https://github.com/user-attachments/assets/3a0bf2c0-d995-451f-aeda-d2f4543546c2)

#### 📌 네트워크 지연으로 중복이 발생하는 경우

- 네트워크 이슈로 인해 브로커가 프로듀서에게 응답을 주지못해 프로듀서가 메시지를 재발행하는 경우에는 시퀀스 번호가 정확히 1만큼 크지 않기 때문에 중복이 있다고 알립니다.
- 이를통해 프로듀서는 실패에 대해 재시도를 할 수 있을 뿐만 아니라 메시지가 한 번 전달될 수 있도록 합니다.

![스크린샷 2025-01-22 오후 10 06 40](https://github.com/user-attachments/assets/7c89e461-179b-434a-9dfc-7bc79398dbd4)

#### 🧨 프로듀서 장애로 인해 PID가 변경되는 경우

- 가장 큰 문제는 프로듀서에 장애가 발생하여 PID가 변경되는 경우에는 메시지가 중복되어 저장될 수 있습니다.

![스크린샷 2025-01-22 오후 10 21 51](https://github.com/user-attachments/assets/8f5614d7-ad35-4f76-b47c-fefeb5703039)

<br>

### 2-2. max.in.flight.requests.per.connection

- 프로듀서가 브로커에게 Ack를 받지 않고 한번에 보낼 수 있는 최대 메시지의 배치 개수입니다. (`기본값:5`)
- max.in.flight.requests.per.connection 설정으로 인해 메시지의 순서가 변경되지 않도록 보장할 수 있습니다.

![스크린샷 2025-01-22 오후 10 43 57](https://github.com/user-attachments/assets/e0458d3e-db6c-4c55-975c-3dd569fe59d9)

<br>

## 3. 멱등적 프로듀서의 한계

### 3-1. PID가 변경되는 경우
- 멱등적 프로듀서는 PID의 생명주기에 많은 영향을 받습니다. 만약 멱등적 프로듀서로 동작하는 프로듀서 애플리케이션에 장애가 발생하여 PID가 변경되면 동일한 데이터를 전송하더라도 PID가 다르므로 브로커는 다른 데이터라고 판단하고 저정하게 됩니다.

<br>

### 3-2. 하나의 애플리케이션에서 동일한 메시지로 N번 producer.send() 메서드를 호출하는 경우

- 하나의 애플리케이션에서 동일한 메시지를 가지고 producer.send() 메서드를 여러번 호출하여 브로커에게 메시지를 저장하면 동일한 메시지가 중복되어 저장될 수 있습니다.
  - 그 이유는 PID와 메시지의 내용(페이로드) 자체가 동일하더라도 SEQ가 다르면 별개의 메시지로 간주하기 때문입니다.

<br>

### 3-3. 하나의 애플리케이션에 여러개의 프로듀서가 있는 경우

설정

- 애플리케이션 A에서 3개의 프로듀서가 실행되고 있음: `Producer1`, `Producer2`, `Producer3`
- `enable.idempotence=true`과 `acks=all` 설정이 되어 있음
- 모든 프로듀서가 브로커에게 `A`의 메시지를 보냄

동작

- `Producer1`(PID: 1001) → `X` (SEQ: 0) 전송
- `Producer2`(PID: 2001) → `X` (SEQ: 0) 전송
- `Producer3`(PID: 3001) → `X` (SEQ: 0) 전송

브로커의 처리

- 브로커는 PID를 기반으로 메시지 중복을 판단하므로 각 프로듀서의 PID가 다르기 때문에 별개의 메시지로 간주하여 저장합니다.

<br>

## 4. 트랜잭션

- spring kafka transaction은 아래 링크를 참조하면 설정하는 방법이 나옵니다.
  - https://docs.spring.io/spring-kafka/reference/kafka/transactions.html#transaction-synchronization

### 4-1. 트랜잭션이란?

- 카프카의 트랜잭션 처리 기능은 스트림 처리 애플리케이션을 위해 특별히 개발되었습니다.
- 스트림 처리 애플리케이션의 기본 패턴인 '읽기-처리-쓰기' 패턴에서 사용하도록 개발되었습니다.

<br>

### 4-2. 트랜잭션이 해결하는 문제

#### 애플리케이션 크래시로 인한 재처리

- 컨슈머가 토픽으로부터 메시지를 받아서 데이터를 가공하고 다른 브로커에게 메시지를 보내고, 또 읽어온 메시지를 오프셋 커밋을해야 하는 상황에서 다른 브로커에게는 메시지를 전달했지만 장애가 발생하여 기존 브로커에 오프셋 커밋을 못한 경우 다른 컨슈머에서 메시지 재처리를 하는 경우 중복이 발생할 수 있습니다.

#### 좀비 애플리케이션에 의해 발생하는 재처리

- 컨슈머가 토픽으로부터 메시지를 받았지만 하트비트가 끊겨 죽은것으로 간주되어 다른 컨슈머에서 메시지를 다시 처리하고, 기존 컨슈머에서 메시지 처리 또한 이루어지는 경우 메시지 중복이 발생할 수 있습니다.

<br>

### 4-3. 트랜잭션은 어떻게 '정확히 한 번'을 보장하는가?

- 프로듀서에서 `transactional.id`를 설정합니다.
- 컨슈머의 `isolation.level:read_committed`로 설정합니다.
- 컨슈머의 `isolation.level:read_committed`로 설정하면 `consumer.poll()` 메서드 호출시 커밋된 트랙잭션에 속한 메시지나 처음부터 트랜잭션에 속하지 않은 메시지만 반환됩니다. 중단된 트랜잭션에 속한 메시지나 아직 진행중인 트랜잭션에 속한 메시지는 반환되지 않는다고 합니다. 



<br>

#### 참고

- https://dkswnkk.tistory.com/741
- https://medium.com/@shesh.soft/kafka-idempotent-producer-and-consumer-25c52402ceb9
- https://px201226.github.io/trasaction_in_kafka/
- https://www.inflearn.com/community/questions/1400386/max-in-flight-requests-per-connection-%EC%9D%98-%EC%84%A4%EB%AA%85%EC%9D%B4-%EC%A1%B0%EA%B8%88-%ED%97%B7%EA%B0%88%EB%A6%BD%EB%8B%88%EB%8B%A4?srsltid=AfmBOops0Nma-1LpxBF03-l-BZQk8NJ05ZruA-sUVBOzdrpdMalVmLcd

