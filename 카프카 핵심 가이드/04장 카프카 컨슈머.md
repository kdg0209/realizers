# 카프카 컨슈머

<br>

## 1. 개념

### 1-1. 컨슈머와 컨슈머 그룹

- 컨슈머는 보통 컨슈머 그룹의 일부로서 동작합니다. 동일한 컨슈머 그룹에 속한 여러 개의 컨슈머들이 동일한 토픽을 구독할 경우 각각의 컨슈머들은 토픽의 서로다른 파티션으로부터 메시지를 받게 됩니다.
- 만약 하나의 토픽을 구독하는 컨슈머 그룹에 속한 컨슈머의 수가 파티션 수보다 많다면 파티션을 할당받지 않은 컨슈머들은 유휴 컨슈머가 됩니다. 

### 1-2. 컨슈머 그룹과 파티션 리밸런스

#### 💡언제 리밸런싱이 발생하는가?

- 컨슈머 그룹에 새로운 컨슈머가 추가된 경우
- 컨슈머 그룹에 속한 컨슈머가 종료되거나 크래시된 경우
- 토픽에 파티션이 추가된 경우
- max.poll.interval.ms로 설정된 시간내에 poll() 메서드를 통해 요청을 보내지 못한 경우
- session.timeout.ms로 설정된 시간내에 HeartBeat Thread가 그룹 코디네이터에게 생존을 알리지 못한 경우

#### Eager 모드

- 리밸런싱 수행시 모든 컨슈머들에게 할당되어 있던 파티션에 대한 소유권을 포기하고, 잠시동안 메시지를 소비하지 않습니다. 이후 컨슈머 그룹에 새롭게 참여하여 새로운 파티션을 할당받은 후 메시지를 소비하게 됩니다.
- 이러한 방식은 전체 컨슈머 그룹에 짧은 Stop the world가 발생하며, 모든 컨슈머들이 잠시 레코드를 소비하지 않는 시간으로 인해 Lag가 상대적으로 크게 발생할 수 있습니다.

![스크린샷 2025-01-08 오후 9 50 37](https://github.com/user-attachments/assets/c2d10a38-b9a3-4e43-91cf-315fce620311)

#### Cooperative 모드
  
- 리밸런싱 수행시 기존 컨슈머들에게 할당되어 있던 모든 파티션에 대한 소유권을 포기하는게 아니라 대상이 되는 컨슈머에 대해서만 파티션의 소유권을 포기하고, 해당 컨슈머만 리밸런싱됩니다.
- 재할당되지 않은 파티션에서 메시지를 읽어 처리하던 컨슈머들은 작업에 방해받지 않고 하던일을 계속하게 됩니다.
- 전체 컨슈머를 중지하는게 아니라 개별 컨슈머가 협력적으로 리밸런싱하기 때문에 Stop the world가 짧습니다. 다만 컨슈머 그룹에 속한 컨슈머들이 많을 경우 전체 리밸런싱하는데 시간이 오래걸릴 수 있습니다.

![스크린샷 2025-01-08 오후 10 03 54](https://github.com/user-attachments/assets/d735f3b8-f1d0-4e0a-b685-11b64e96b6d1)

<br>

### 1-3. 파티션은 어떻게 컨슈머에게 할당되는가?

#### 🚗 과정

1. 여러 컨슈머들에서 첫 poll() 메서드를 호출합니다.
2. poll 요청을 받은 브로커 중에서 하나의 브로커가 Group Coordinator를 생성하고, 컨슈머에게 응답을 보내게 됩니다.
3. 컨슈머 그룹에 있는 여러 컨슈머가 Group Coordinator에게 Join Group 요청을 보냅니다.
4. Group Coordinator는 가장 먼저 Join Group을 보낸 컨슈머가 리더 컨슈머가 되었다고 요청을 보냅니다.
5. 가장 먼저 Join Group을 요청한 컨슈머가 리더 컨슈머가 됩니다.
6. 리더 컨슈머는 파티션 할당 전략에 따라 컨슈머들에게 파티션을 할당해줍니다.
7. 리더 컨슈머는 최종 할당된 파티션 정보를 Group Coordinator에게 전달합니다.
8. Group Coordinator는 해당 정보를 캐싱하고, 컨슈머들에게 성공을 알립니다.
9. 컨슈머들은 이제 각자 지정된 토픽의 파티션으로부터 메시지를 가져옵니다.

![스크린샷 2025-01-08 오후 10 06 14](https://github.com/user-attachments/assets/e50aba4d-b698-45e3-8e80-39accbc9eb4a)

<br>

### 1-4. 정적 그룹 멤버쉽(Static Group Membership)

- 기본적으로 컨슈머가 갖는 컨슈머 그룹의 멤버십은 일시적인 것입니다. 컨슈머가 컨슈머 그룹을 떠나는 순간 해당 컨슈머에게 할당되어 있는 멤버십은 없어지게 되고, 리밸런싱이 발생하게 됩니다.
- group.instance.id를 지정함으로써 특정 컨슈머를 정적 멤버십으로 만들 수 있습니다.
- 정적 멤버십 컨슈머는 session.timeout.ms(45초) 내에 재가동된다면 리밸런싱이 발생하지 않고, 기존 파티션에서 메시지를 소비하게 됩니다. 만약 컨슈머가 session.timeout.ms(45초) 내에 재기동되지 못한다면 리밸런싱이 발생하게 됩니다.
- 정적 멤버로서 컨슈머 그룹에 처음 참여하면 기존처럼 파티션 할당 전략에 의해 파티션을 할당받게 됩니다.

#### 📌 주의점

- session.timeout.ms(45초)내에만 재가동되면 리밸런싱이 발생하지 않아 문제없어 보일 수 있지만 45초 내에 프로듀서가 급격히 많은 메시지를 발생하면 해당 컨슈머가 재시작되었을 때 밀린 메시지를 따라잡을 수 있는지 확인해야 합니다.

<br>

## 2. 컨슈머 설정하기

#### 2-1. fetch.min.bytes

- 이 속성은 컨슈머가 브로커로부터 메시지를 가져올 때 데이터의 최소 바이트량을 지정할 수 있으며, 기본값은 1바이트입니다.
- 브로커가 보낼 메시지의 양이 fetch.min.bytes보다 작을 경우 브로커는 충분한 메시지가 쌓일때까지 기다립니다. 단 fetch.max.wait.ms 시간을 넘어가면 전송해버립니다.

#### 2-2. fetch.max.wait.ms

- 이 속성은 브로커가 fetch.min.bytes에 충족하는 양만큼 메시지가 쌓이지 않았을 경우 얼마나 오래 기다릴것인지 결정하는 값이며, 기본적으로는 500ms입니다.

#### 2-3. fetch.max.bytes

- 이 속성은 컨슈머가 브로커를 폴링할 때 브로커가 리턴하는 최대 바이트 수를 지정합니다. 기본값은 50MB입니다.

#### 2-4. max.poll.records

- 이 속성은 poll() 메서드를 호출할 때마다 반환되는 최대 레코드의 수를 지정합니다.

#### 2-5. max.partition.fetch.bytes

- 이 속성은 서버가 파티션별로 반환하는 최대 바이트 수를 결정합니다. 이 값 대신 fetch.max.bytes 설정을 사용할 것을 권장합니다.

#### 2-6. session.timeout.ms

- 컨슈머가 브로커와 신호를 주고받지 않아도 살아 있는 것으로 판전되는 최대 시간의 기본값(45초)입니다.

#### 2-7. heartbeat.interval.ms

- 그룹 코디네이터에게 얼마나 자주 poll() 메서드를 통해 heartbeat를 보낼것인지 조정하는 할 수 있습니다.
- 일반적으로 session.timeout.ms보다 1/3 정도로 설정합니다.

#### 2-8. max.poll.interval.ms

- 컨슈머가 지속적으로 heartbeat는 보내지만 실제로 메시지를 가져가지 않을 수 있습니다. 이러한 경우 컨슈머가 특정 파티션을 무한정으로 소유할 수 없도록 주기적으로 poll() 메서드를 호출하지 않으면 장애라고 판단하고 리밸런싱 됩니다.
- session.timeout.ms이 있는데 이 속성이 있는 이유는 메인 스레드는 데드락에 걸렸는데 백그라운드 스레드는 멀쩡히 하트비트를 보내 정상적으로 살아있다고 알립니다. 사실 컨슈머는 할당된 파티션의 레코드를 처리하고 있지 않음에도 불구하고 정상으로 판단해버리는 문제가 발생합니다. 그렇기 때문에 컨슈머가 여전히 레코드를 잘 처리하고 있는지 확인하는 가장 쉬운 방법은 컨슈머가 주기적으로 메시지를 요청하는지 확인하는 것입니다.

#### 2-9. offsets.retention.minutes

- 이 속성은 브로커 설정이지만 주의가 필요합니다.
- 컨슈머 그룹에 하나 이상의 컨슈머들이 속해 있는 한 컨슈머들이 보낸 파티션에 대해 커밋한 마지막 오프셋 값은 브로커에 보존되어 있기 때문에 재할당되거나 재시작될 때 커밋된 오프셋을 기반으로 메시지를 가져갈 수 있습니다. 하지만 컨슈머 그룹이 비어있게 되면 브로커는 커밋된 오프셋값을 해당 설정값에 지정된 기간 동안만 보관합니다.(7일)
- 7일 후에 커밋된 오프셋이 삭제된 상태에서 컨슈머 그룹이 다시 활동을 하면 처음부터 메시지를 가져오게 됩니다.

<br>

## 3. 컨슈머의 파티션 분배 전략

#### Range 할당 전략

- 컨슈머가 구독하는 각 토픽의 파티션들을 연속된 그룹으로 나누고, 나머지 연산을 통해 파티션을 할당합니다.

![스크린샷 2025-01-08 오후 11 15 28](https://github.com/user-attachments/assets/c7c41960-5854-4fb1-a708-57e9f3b2837a)

<br>

#### Round Robin 할당 전략

- 파티션별로 consumer들이 균등하게 부하를 분배할 수 있도록 여러 토픽들의 파티션들을 consumer들에게 순차적인 방식으로 할당하는 전략입니다.

![스크린샷 2025-01-08 오후 11 17 51](https://github.com/user-attachments/assets/0d44d7f9-0993-4a8d-abe3-60ae7ef7f9c6)

<br>

#### Sticky 할당 전략

- 최초 파티션 할당은 Round Robin 할당 전략을 사용합니다.
- 최초에 할당된 파티션과 컨슈머가 리밸런싱이 수행되어도 가급적 그대로 유지할 수 있도록 지원하는 전략입니다.
- 해당 전략은 Eager 모드이므로 리밸런싱시 모든 컨슈머들에게 할당되어 있던 파티션들의 소유권은 포기하게 됩니다.

![스크린샷 2025-01-08 오후 11 08 49](https://github.com/user-attachments/assets/d23c3559-11c3-4e95-8281-e4dbf8e6eda4)

<br>

#### Cooperative Sticky 할당 전략

- 최초에 할당된 파티션과 컨슈머들의 매핑이 리밸런싱이 발생하더라도 가급적 유지할 수 있도록 지원함과 동시에 리밸런싱이 발생할 때 모든 컨슈머들에게 할당되어 있던 파티션의 소유권을 포기하지 않고, 리밸런싱에 연관된 파티션과 컨슈머만 재매핑됩니다.

![스크린샷 2025-01-08 오후 11 11 28](https://github.com/user-attachments/assets/ee70528e-eee6-4e27-a992-c5ea4dcfe6bb)


<br>





