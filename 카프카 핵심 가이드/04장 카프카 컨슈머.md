# 카프카 컨슈머

<br>

## 1. 개념

### 1-1. 컨슈머와 컨슈머 그룹

- 컨슈머는 보통 컨슈머 그룹의 일부로서 동작합니다. 동일한 컨슈머 그룹에 속한 여러 개의 컨슈머들이 동일한 토픽을 구독할 경우 각각의 컨슈머들은 토픽의 서로다른 파티션으로부터 메시지를 받게 됩니다.
- 만약 하나의 토픽을 구독하는 컨슈머 그룹에 속한 컨슈머의 수가 파티션 수보다 많다면 파티션을 할당받지 않은 컨슈머들은 유휴 컨슈머가 됩니다. 

### 1-2. 컨슈머 그룹과 파티션 리밸런스

#### 💡언제 리밸런싱이 발생하는가?

- 컨슈머 그룹에 새로운 컨슈머가 추가된 경우
- 컨슈머 그룹에 속한 컨슈머가 종료되거나 크래시된 경우
- 토픽에 파티션이 추가된 경우
- max.poll.interval.ms로 설정된 시간내에 poll() 메서드를 통해 요청을 보내지 못한 경우
- session.timeout.ms로 설정된 시간내에 HeartBeat Thread가 그룹 코디네이터에게 생존을 알리지 못한 경우

#### Eager 모드

- 리밸런싱 수행시 모든 컨슈머들에게 할당되어 있던 파티션에 대한 소유권을 포기하고, 잠시동안 메시지를 소비하지 않습니다. 이후 컨슈머 그룹에 새롭게 참여하여 새로운 파티션을 할당받은 후 메시지를 소비하게 됩니다.
- 이러한 방식은 전체 컨슈머 그룹에 짧은 Stop the world가 발생하며, 모든 컨슈머들이 잠시 레코드를 소비하지 않는 시간으로 인해 Lag가 상대적으로 크게 발생할 수 있습니다.

![스크린샷 2025-01-08 오후 9 50 37](https://github.com/user-attachments/assets/c2d10a38-b9a3-4e43-91cf-315fce620311)

#### Cooperative 모드
  
- 리밸런싱 수행시 기존 컨슈머들에게 할당되어 있던 모든 파티션에 대한 소유권을 포기하는게 아니라 대상이 되는 컨슈머에 대해서만 파티션의 소유권을 포기하고, 해당 컨슈머만 리밸런싱됩니다.
- 재할당되지 않은 파티션에서 메시지를 읽어 처리하던 컨슈머들은 작업에 방해받지 않고 하던일을 계속하게 됩니다.
- 전체 컨슈머를 중지하는게 아니라 개별 컨슈머가 협력적으로 리밸런싱하기 때문에 Stop the world가 짧습니다. 다만 컨슈머 그룹에 속한 컨슈머들이 많을 경우 전체 리밸런싱하는데 시간이 오래걸릴 수 있습니다.

![스크린샷 2025-01-08 오후 10 03 54](https://github.com/user-attachments/assets/d735f3b8-f1d0-4e0a-b685-11b64e96b6d1)

<br>

### 1-3. 파티션은 어떻게 컨슈머에게 할당되는가?

#### 🚗 과정

1. 여러 컨슈머들에서 첫 poll() 메서드를 호출합니다.
2. poll 요청을 받은 브로커 중에서 하나의 브로커가 Group Coordinator를 생성하고, 컨슈머에게 응답을 보내게 됩니다.
3. 컨슈머 그룹에 있는 여러 컨슈머가 Group Coordinator에게 Join Group 요청을 보냅니다.
4. Group Coordinator는 가장 먼저 Join Group을 보낸 컨슈머가 리더 컨슈머가 되었다고 요청을 보냅니다.
5. 가장 먼저 Join Group을 요청한 컨슈머가 리더 컨슈머가 됩니다.
6. 리더 컨슈머는 파티션 할당 전략에 따라 컨슈머들에게 파티션을 할당해줍니다.
7. 리더 컨슈머는 최종 할당된 파티션 정보를 Group Coordinator에게 전달합니다.
8. Group Coordinator는 해당 정보를 캐싱하고, 컨슈머들에게 성공을 알립니다.
9. 컨슈머들은 이제 각자 지정된 토픽의 파티션으로부터 메시지를 가져옵니다.

![스크린샷 2025-01-08 오후 10 06 14](https://github.com/user-attachments/assets/e50aba4d-b698-45e3-8e80-39accbc9eb4a)

<br>

### 1-4. 정적 그룹 멤버쉽(Static Group Membership)

- 기본적으로 컨슈머가 갖는 컨슈머 그룹의 멤버십은 일시적인 것입니다. 컨슈머가 컨슈머 그룹을 떠나는 순간 해당 컨슈머에게 할당되어 있는 멤버십은 없어지게 되고, 리밸런싱이 발생하게 됩니다.
- group.instance.id를 지정함으로써 특정 컨슈머를 정적 멤버십으로 만들 수 있습니다.
- 정적 멤버십 컨슈머는 session.timeout.ms(45초) 내에 재가동된다면 리밸런싱이 발생하지 않고, 기존 파티션에서 메시지를 소비하게 됩니다. 만약 컨슈머가 session.timeout.ms(45초) 내에 재기동되지 못한다면 리밸런싱이 발생하게 됩니다.
- 정적 멤버로서 컨슈머 그룹에 처음 참여하면 기존처럼 파티션 할당 전략에 의해 파티션을 할당받게 됩니다.

#### 📌 주의점

- session.timeout.ms(45초)내에만 재가동되면 리밸런싱이 발생하지 않아 문제없어 보일 수 있지만 45초 내에 프로듀서가 급격히 많은 메시지를 발생하면 해당 컨슈머가 재시작되었을 때 밀린 메시지를 따라잡을 수 있는지 확인해야 합니다.

<br>

## 2. 컨슈머 설정하기

#### 2-1. fetch.min.bytes

- 이 속성은 컨슈머가 브로커로부터 메시지를 가져올 때 데이터의 최소 바이트량을 지정할 수 있으며, 기본값은 1바이트입니다.
- 브로커가 보낼 메시지의 양이 fetch.min.bytes보다 작을 경우 브로커는 충분한 메시지가 쌓일때까지 기다립니다. 단 fetch.max.wait.ms 시간을 넘어가면 전송해버립니다.

#### 2-2. fetch.max.wait.ms

- 이 속성은 브로커가 fetch.min.bytes에 충족하는 양만큼 메시지가 쌓이지 않았을 경우 얼마나 오래 기다릴것인지 결정하는 값이며, 기본적으로는 500ms입니다.

#### 2-3. fetch.max.bytes

- 이 속성은 컨슈머가 브로커를 폴링할 때 브로커가 리턴하는 최대 바이트 수를 지정합니다. 기본값은 50MB입니다.

#### 2-4. max.poll.records

- 이 속성은 poll() 메서드를 호출할 때마다 반환되는 최대 레코드의 수를 지정합니다.

#### 2-5. max.partition.fetch.bytes

- 이 속성은 서버가 파티션별로 반환하는 최대 바이트 수를 결정합니다. 이 값 대신 fetch.max.bytes 설정을 사용할 것을 권장합니다.

#### 2-6. session.timeout.ms

- 컨슈머가 브로커와 신호를 주고받지 않아도 살아 있는 것으로 판전되는 최대 시간의 기본값(45초)입니다.

#### 2-7. heartbeat.interval.ms

- 그룹 코디네이터에게 얼마나 자주 poll() 메서드를 통해 heartbeat를 보낼것인지 조정하는 할 수 있습니다.
- 일반적으로 session.timeout.ms보다 1/3 정도로 설정합니다.

#### 2-8. max.poll.interval.ms

- 컨슈머가 지속적으로 heartbeat는 보내지만 실제로 메시지를 가져가지 않을 수 있습니다. 이러한 경우 컨슈머가 특정 파티션을 무한정으로 소유할 수 없도록 주기적으로 poll() 메서드를 호출하지 않으면 장애라고 판단하고 리밸런싱 됩니다.
- session.timeout.ms이 있는데 이 속성이 있는 이유는 메인 스레드는 데드락에 걸렸는데 백그라운드 스레드는 멀쩡히 하트비트를 보내 정상적으로 살아있다고 알립니다. 사실 컨슈머는 할당된 파티션의 레코드를 처리하고 있지 않음에도 불구하고 정상으로 판단해버리는 문제가 발생합니다. 그렇기 때문에 컨슈머가 여전히 레코드를 잘 처리하고 있는지 확인하는 가장 쉬운 방법은 컨슈머가 주기적으로 메시지를 요청하는지 확인하는 것입니다.

#### 2-9. offsets.retention.minutes

- 이 속성은 브로커 설정이지만 주의가 필요합니다.
- 컨슈머 그룹에 하나 이상의 컨슈머들이 속해 있는 한 컨슈머들이 보낸 파티션에 대해 커밋한 마지막 오프셋 값은 브로커에 보존되어 있기 때문에 재할당되거나 재시작될 때 커밋된 오프셋을 기반으로 메시지를 가져갈 수 있습니다. 하지만 컨슈머 그룹이 비어있게 되면 브로커는 커밋된 오프셋값을 해당 설정값에 지정된 기간 동안만 보관합니다.(7일)
- 7일 후에 커밋된 오프셋이 삭제된 상태에서 컨슈머 그룹이 다시 활동을 하면 처음부터 메시지를 가져오게 됩니다.

<br>

## 3. 컨슈머의 파티션 분배 전략

### 3-1. Range 할당 전략

- 컨슈머가 구독하는 각 토픽의 파티션들을 연속된 그룹으로 나누고, 나머지 연산을 통해 파티션을 할당합니다.

![스크린샷 2025-01-08 오후 11 15 28](https://github.com/user-attachments/assets/c7c41960-5854-4fb1-a708-57e9f3b2837a)

<br>

### 3-2. Round Robin 할당 전략

- 파티션별로 consumer들이 균등하게 부하를 분배할 수 있도록 여러 토픽들의 파티션들을 consumer들에게 순차적인 방식으로 할당하는 전략입니다.

![스크린샷 2025-01-08 오후 11 17 51](https://github.com/user-attachments/assets/0d44d7f9-0993-4a8d-abe3-60ae7ef7f9c6)

<br>

### 3-3. Sticky 할당 전략

- 최초 파티션 할당은 Round Robin 할당 전략을 사용합니다.
- 최초에 할당된 파티션과 컨슈머가 리밸런싱이 수행되어도 가급적 그대로 유지할 수 있도록 지원하는 전략입니다.
- 해당 전략은 Eager 모드이므로 리밸런싱시 모든 컨슈머들에게 할당되어 있던 파티션들의 소유권은 포기하게 됩니다.

![스크린샷 2025-01-08 오후 11 08 49](https://github.com/user-attachments/assets/d23c3559-11c3-4e95-8281-e4dbf8e6eda4)

<br>

### 3-4. Cooperative Sticky 할당 전략

- 최초에 할당된 파티션과 컨슈머들의 매핑이 리밸런싱이 발생하더라도 가급적 유지할 수 있도록 지원함과 동시에 리밸런싱이 발생할 때 모든 컨슈머들에게 할당되어 있던 파티션의 소유권을 포기하지 않고, 리밸런싱에 연관된 파티션과 컨슈머만 재매핑됩니다.

![스크린샷 2025-01-08 오후 11 11 28](https://github.com/user-attachments/assets/ee70528e-eee6-4e27-a992-c5ea4dcfe6bb)

<br>

## 4. 오프셋과 커밋

### 4-1. 오프셋이란?

- 카프카에서 오프셋은 특정 파티션내에 메시지의 고유 번호입니다.
- 예를들어 파티션에 메시지가 순서대로 저장된다면 각 메시지는 0, 1, 2, 3 ...과 같은 오프셋 값을 갖습니다.

<br>

### 4-2. 오프셋 커밋이란?

- 컨슈머는 메시지를 처리한 후 브로커에게 "내가 메시지를 여기까지 처리했어!"라고 알려줘야 합니다. 이 과정을 오프셋 커밋이라 합니다.
- 컨슈머는 카프카의 특수 토픽은 __consumer_offsets 토픽에 각 파티션별로 커밋된 오프셋을 업데이트하도록 메시지를 보냅니다.
- __consumer_offset에 저장되는 offset은 컨슈머가 마지막까지 읽은 위치가 아니라 다음으로 읽어야 할 위치를 말합니다.

<br>

### 4-3. 💡 메시지 중복 처리가 발생하는 경우

- 커밋된 오프셋이 클라이언트가 처리한 마지막 오프셋보다 작을 경우 마지막으처 처리된 오프셋과 커밋된 오프셋 사이의 메시지는 중복되어 처리됩니다.

예시

1. 컨슈머가 오프셋 3부터 10까지 읽어오고 3~10까지 처리를 완료하였습니다.
2. 그러나 커밋은 3까지만 완료하고 4~10의 처리는 끝났지만 아직 커밋되지 않은 상태입니다.
3. 이때 리밸런싱이 발생하여 새로운 컨슈머는 "마지막 커밋된 오프셋(3)"부터 다시 읽기 시작합니다. 따라서 메시지 중복처리가 발생할 수 있게 됩니다.

![스크린샷 2025-01-09 오후 9 20 43](https://github.com/user-attachments/assets/ab4ec711-3826-4941-8769-8e44e89098eb)

<br>

### 4-4. 💡 메시지 누락이 발생하는 경우

- 커밋된 메시지가 클라이언트가 실제로 처리한 마지막 메시지의 오프셋보다 큰 경우 마지막으로 처리된 오프셋과 커밋된 오프셋 사이의 모든 메시지들은 누락되게 됩니다.

예시

1. 컨슈머가 오프셋 6~11의 메시지를 poll() 메서드를 통해 가져옵니다.
2. 컨슈머가 현재 오프셋 6번 메시지를 처리 중입니다.
3. 하지만 오프셋 11까지 커밋을 완료합니다. (commitAsync() 메서드를 통해 커밋)
4. 이때 리밸런싱이 발생하여 새로운 컨슈머는 "마지막 커밋된 오프셋(11)"이후의 메시지부터 읽기 시작합니다. 이로인해 메시지 누락이 발생하게 됩니다.

![스크린샷 2025-01-09 오후 9 31 21](https://github.com/user-attachments/assets/1110e71b-3690-46a3-8d02-92675df87445)

<br>

## 5. 컨슈머의 다양한 커밋 방법

### 5-1. Auto Commit

- 'enable.auto.commit'의 속성값을 TRUE로 설정하면 컨슈머는 5초에 한 번, poll() 메서드를 통해 받은 메시지 중 가장 마지막 메시지의 오프셋을 커밋합니다. (auto.commit.interval.ms: 5000(5초))
- 메시지 중복 처리가 발생할 수 있습니다.
  - 예를들어 마지막으로 커밋한 지 3초뒤에 컨슈머에 장애가 발생했다고 가정하면 아래와 같은 과정이 이루어지게 됩니다.
    - 리밸런싱이 완료된 뒤부터 남은 컨슈머들은 장애가 발생한 컨슈머가 읽고 있던 파티션을 이어처리하게 됩니다. 문제는 재할당받은 컨슈머가 마지막으로 커밋된 오프셋부터 작업을 시작하는데, 이 경우 커밋되어 있는 오프셋은 3초 전의 것이기 때문에 장애가 발생하기 전 3초전까지 처리한 메시지들을 중복하여 처리하게 됩니다.

<br>

### 5-2. Sync Commit

- 'enable.auto.commit'의 속성값을 FALSE로 설정함으로써 애플리케이션이 명시적으로 커밋할 수 있도록 합니다.
- commitSync 메서드를 사용하면 커밋을 보낼때 다음 poll 메서드는 blocking됩니다.
- commit에 실패하면 retry를 하다가 더 이상 재시도를 할 수 없는 경우 CommitFailedException이 발생합니다.

![스크린샷 2025-01-09 오후 9 52 40](https://github.com/user-attachments/assets/ace8d34c-5a44-4d09-80df-7e339c04fcda)

<br>

### 5-3. Async Commit

- 레코드를 poll 메서드를 통해 읽어온 뒤 레코드들의 마지막 offset을 브로커에게 커밋 요청을 보내지만 브로커에 커밋이 정상적으로 반영되었는지 확인하지 않고 계속하여 poll 메서드를 수행합니다.
- 브로커에 커밋이 실패하더라도 커밋을 재시도하지 않습니다. 그렇기 때문에 리밸런싱으로 인해 한번 읽은 레코드를 다시 읽을 수 있습니다.
- callback을 통해 로그를 남길 수 있습니다.

![스크린샷 2025-01-09 오후 9 58 00](https://github.com/user-attachments/assets/ad1ac130-963c-445c-9eef-ac8d6f44fd58)

<br>

#### 비동기적 커밋 재시도하기 (107p)

- 순차적으로 단조증가하는 번호를 사용하면 비동기적 커밋을 재시도할 때 순서를 맞출 수 있다고 합니다. 커밋할 때마다 번호를 1씩 증가시킨 뒤 commitAsync 콜백에 해당 번호 넣어주고, 재시도 요청을 보낼 때 콜백에 주어진 번호와 현재번호 비교하는 방식
- 만약 콜백에 주어진 번호가 더 크다면 새로운 커밋이 없었다는 의미이므로 재시도를 해도됩니다. 하지만 그게 아니라면 새로운 커밋이 있엇다는 의미이기 때문에 재시도하면 안됩니다.

```java
public class CustomCallback implements Callback {

    private final int seq;

    public CustomCallback(int seq) {
        this.seq = seq;
    }

    @Override
    public void onCompletion(RecordMetadata metadata, Exception exception) {
        if (exception != null) {
            exception.printStackTrace();
        } else {
            ...
        }
    }
}

// 시퀀스를 발행하여 메시지 발행 후 콜백에 시퀀스 넣어서 파악?
for (int seq = 0; seq < 20; seq++) {

    // 3. kafkaProducerRecord object create
    ProducerRecord<Integer, String> record = new ProducerRecord<>(TOPIC_NAME, seq, "hello-world");

    // 4. producer message send
    kafkaProducer.send(record, new CustomCallback(seq));
}
```


