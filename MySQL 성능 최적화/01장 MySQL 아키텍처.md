# MySQL 아키텍처

- 이 장에서는 MySQL 서버 아키텍처에 대해 살펴보고, 스토리지 엔진 간의 주요 차이점과 이러한 차이점이 중요한 이유에 대해 설명합니다.

## MySQL의 논리적 아키텍처

### 동시성 제어

- 두 개 이상의 쿼리가 동시에 데이터를 변경해야하는 경우 동시성 문제가 발생할 수 있습니다. 그리고 하나의 쿼리가 데이터를 읽고 있는 동시에 다른 쿼리가 데이터를 수정하게 된다면 기존 쿼리는 어떤 데이터를 봐야할까요? 이러한 문제를 공유 잠금(Shared Lock)과 전용 잠금(Exclusive Lock)을 활용하여 문제를 해결할 수 있습니다.

#### Shared Lock

- Shared Lock이 걸린 데이터에 대해서는 읽기(SELECT)만 가능하며, 쓰기 연산은 불가능합니다.
- Shared Lock이 걸린 데이터에 대해서 다른 트랜잭션에서도 똑같이 Shared Lock을 획득할 수 있으나, Exclusive Lock은 획득할 수 없습니다.

#### Exclusive Lock

- Exclusive Lock이 걸린 데이터에 대해서는 다른 트랜잭션이 읽기 연산이나 쓰기 연산을 할 수 없습니다.
- Exclusive Lock으로 인해 데드락에 빠질 수 있으니 수행시간 설정을 통해 데드락을 사전에 방지해야 합니다.

<br>


### 잠금 세분화

- MySQL은 다양한 자체 잠금 정책과 잠금 단위를 제공하고 있으며 이로인해 잠금으로 인한 오버헤드를 줄이며 성능을 향상시킬 수 있는 방법을 제공하고 있습니다.

#### 테이블 락

- 테이블 락은 개별 테이블 단위로 설정되는 잠금이며, 사용자가 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있습니다.
- 명시적 락은 LOCK TABLES [테이블 명 READ | WRITE]와 같은 명령어를 통해 락을 획득할 수 있으며 UNLOCK TABLES 명령어를 통해 락을 해제할 수도 있습니다.
- 묵시적 락은 테이블을 변경하는 쿼리가 실행되었을 경우 MySQL 서버가 해당 테이블에 대해 락을 획득하고 데이터를 변경한 다음 바로 락을 반납하게 됩니다. 이렇게 자동으로 획득 및 반납과정이 일어나기 때문에 편리하지만 InnoDB 스토리지 엔진의 경우 레코드 락을 기반으로 하기 때문에 테이블 락이 실행되더라도 DML에서는 무시되고, DDL에 대해서만 영향을 미칩니다.

#### 레코드 락

- 레코드 자체만을 잠그는 것을 레코드 락이라고 하며, InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드에 락을 설정합니다.
- 인덱스가 없더라도 내부적으로 6byte인 hidden key를 사용하여 레코드 락을 걸게됩니다.

#### 갭 락

- 갭 락은 레코드 자체가 아니라 레코드와 레코드 사이의 간격만을 잠그는 것을 의미합니다.
- 갭 락의 역할은 레코드와 레코드 사이에 새로운 레코드가 생성되는 것을 제어하는 역할을 합니다. 

#### 넥스트 키 락

- 레코드 락과 갭 락을 합친 형태입니다.
- InnoDB 스토리지 엔진의 갭 락이나 넥스트 키락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적입니다. 하지만 이외로 넥스트 키락과 갭락으로 인해 데드락이 발생할 수 있는데 가능하다면 바이너리 로그 포맷을 ROW 형태로 지정하는 것이 좋습니다.
(8.0버전 부터는 ROW 포맷이 기본 설정입니다.)

<br>

### 트랜잭션

- 트랜잭션은 ACID를 통해 안정성을 높일 수 있습니다.

#### 원자성(Atomicity)

- 트랜잭션은 전체 트랜잭션이 적용되거나 롤백되어야 합니다. 일부만 성공이거나 실패할 수 없습니다.

#### 일관성(Consistency)

- 트랜잭션이 성공적으로 완료되면 일관적인 데이터베이스 상태를 가져야합니다.
- 즉 데이터 타입이 정수였는데 갑자기 문자열로 되면 안됩니다.

#### 격리성(Isolation)

- 트랜잭션 수행시 다른 트랜잭션이 해당 작업에 끼어들 수 없습니다.
- 트랜잭션끼리 서로 간섭할 수 없습니다.

#### 지속성(Durability)

- 트랜잭션이 성공적으로 완료된다면 영구적으로 반영되어야 합니다.

<br>

### 격리 수준

- 일반적으로 격리 수준이 낮을수록 동시성 문제가 빈번히 발생하며, 오버헤드가 줄어들고 처리량을 높일 수 있습니다.
- 참고: https://mangkyu.tistory.com/299

#### READ UNCOMMITTED

- 해당 격리 수준에서는 커밋되지 않은 트랜잭션의 결과를 볼 수 있습니다.
- 커밋되지 않은 데이터를 조회할 수 있으므로 Dirty Read가 발생할 수 있습니다.

#### READ COMMITTED

- Mysql을 제외한 대부분의 데이터베이스 시스템의 기본 격리 수준은 READ COMMITTED입니다.
- 커밋된 데이터만 조회할 수 있습니다. Phantom Read와 Non-Repeatable Read(반복 읽기 불가능) 문제가 발생할 수 있습니다.

#### REPEATABLE READ

- 해당 커밋 방식은 READ COMMITTED의 문제를 해결하고 Mysql의 기본 트랜잭션 격리 수준입니다.
- MVCC를 통해 변경 전의 데이터를 언두로그 공간에 백업을 해놓습니다. 이렇게 하면 변경 전/후의 데이터가 모두 존재하게 되는데, MVCC를 통해 트랜잭션이 롤백된 경우 데이터를 복원할 수 있을뿐만 아니라 서로 다른 트랜잭션 간에 접근할 수 있는 데이터를 세밀하게 제어할 수도 있습니다.
- REPEATABLE READ는 MVCC를 통해 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우 Phantom Read가 발생할 수 있습니다. 그렇지만 MySQL에서 REPEATABLE READ 격리 수준을 사용한다면 일반적인 상황에서는 Phantom Read가 발생하지 않습니다.

#### SERIALIZABLE

- SERIALIZABLE은 가장 엄격한 격리 수준으로, 트랜잭션을 순차적으로 실행시킵니다. 여러 트랜잭션이 동일한 레코드에 접근할 수 없으며, 동일한 레코드 접근시 순차적으로 접근하게 됩니다.
- 레코드 조회시 공유락이나 배타적락을 설정하지 않았더라도 기본적으로 공유락이 설정됩니다. 안정성은 높지만 성능이 떨어지므로 사용하면 안됩나다.

<br>

### MySQL에서의 트랜잭션

#### AUTOCOMMIT 이해

- AUTOCOMMIT이란 사용자가 INSERT, UPDATE, DELETE 쿼리에 대해 커밋을 따로 하지 않아도 자동으로 모든 쿼리에 대해 커밋되는 명령어입니다.
- AUTOCOMMIT을 활성화 해놓으면 잘못된 쿼리라도 바로 커밋이 되므로 롤백이 불가능합니다.
- 만약 비지니스 로직중에서 UPDATE 쿼리로 이름을 수정해야하는데 첫번째 쿼리는 정상적으로 커밋되고, 두번째 쿼리는 실패되어 DB에 반영되지 않았는데 이러면 원자성이 깨지게됩니다. 하나의 트랜잭션은 모두 커밋되던가 롤백되어야 하는데 AUTOCOMMIT을 활성화해놓으면 원자성이 깨질 수 있습니다.

```mysql
SET AUTOCOMMIT = 1;
update students set name = "홍길동" where id = 1; -- 이하 첫번째 쿼리
update students set name = "이순신" where id = 2; -- 이하 두번째 쿼리
```

<br>

### 다중 버전 동시성 제어(MVCC)

- MVCC란 데이터베이스가 동시성을 제어하기 위해 사용하는 방법 중 하나로 스냅샷을 이용합니다. 이러한 스냅샷을 통해 하나의 레코드에 대해 여러 버전을 관리할 수 있습니다.
- MVCC를 사용하는 목적은 락을 사용하지 않기 위해서인데, 락은 동시성을 제어하는데 쉬운 방법이지만 그만큼 성능이 저하됩니다. 따라서 MVCC를 사용하면 스냅샷을 통해 락 설정없이도 성능을 높일 수 있습니다.
- MVCC는 구현하는 스토리지 엔진별로 다르며, InnoDB 스토리지 엔진의 경우 시작되는 트랜잭션마다 트랜잭션 ID를 할당하여 MVCC를 구현합니다. 이 ID는 트랜잭션이 데이터를 처음 읽을때 할당됩니다.
- MVCC는 READ COMMITTED과 REPEATABLE READ의 격리 수준에서만 작동됩니다.

#### 언두로그란?

- 언두 로그란 트랜잭션의 격리 수준을 보장하기 위해 백업해둔 이전 버전의 데이터입니다.
1. 아래 UPDATE 쿼리를 보내면 우선 데이터베이스는 커밋 여부와 무관하게 버퍼풀(메모리)의 내용을 이순신에서 홍길동으로 변경합니다.
2. 이후 언두 로그에 변경 전의 값인 이순신을 백업해두었다가 커밋되면 백그라운드 스레드가 알아서 언두로그에 있는 값을 삭제하고, 디스크에 홍길동의 값을 저장하게 됩니다. 만약 롤백이 된다면 언두 로그에 있는 이순신의 값으로 복구되게 됩니다.

```mysql
# 원래 이름은 이순신입니다.
UPDATE member SET name = "홍길동" WHERE member_id = 1;
```

#### 언두로그에 대해 조심해야 하는 경우

1. 대량의 데이터를 변경 또는 삭제하는 경우
  - 예를들어 1억건의 데이터가 저장된 10GB의 테이블을 삭제한다고 했을 경우 테이블에서 우선 데이터가 삭제되지만 동시에 언두 로그에 데이터가 복사되면서 공간을 2배 차지하게 되어 문제가 발생할 수 있습니다. 따라서 대량으로 삭제를 해야하는 경우 청크를 나눠서 삭제하는게 안정적입니다.
3. 트랜잭션을 오래 유지하는 경우
  - 트랜잭션이 완료되지 않고 오래 유지되는 경우 언두 로그에서도 데이터가 계속 남아있게되어 문제가 발생할 수 있는 여지가 있습니다. 트래픽이 많지 않은 경우에 문제가 되지 않겠지만 트래픽이 많은 경우 다른 트랜잭션이 언두 로그에서 데이터를 조회해야하는 경우에 언두 로그를 뒤져야하는 이슈와 트랜잭션 사이에 네트워크 요청이 함깨 있는 경우에도 동일한 문제가 발생할 수 있습니다.

#### 리두로그란?

- 리두로그도 언두로그와 비슷하게 데이터 변경 내용을 리두로그에 저장하게 됩니다. 이를 통해 MySQL 서버가 비정상적으로 종료되었을 경우 백업을 통해 데이터를 복구할 수 있습니다.

#### 버퍼풀이란?

- 버퍼풀은 캐싱을 통한 읽기 성능 향상과 쓰기 지연을 통해 쓰기 성능을 향상시킵니다.
- 버퍼풀은 데이터를 임시 저장하기 위한 메모리 공간이므로, 읽기 작업시 디스크 읽는 횟수를 줄여 성능을 높일 수 있습니다.
- 쓰기 작업을 지연시키는 역할도 하는데 쓰기 작업을 각각의 트랜잭션에 대해 처리하면 데이터를 처리할 위치를 찾아야하는 랜덤 I/O가 발생하는데 버퍼풀을 통해 지연을 시켜 한번에 N개의 데이터를 일괄적으로 처리하면 I/O를 줄여 성능을 높일 수 있습니다.

