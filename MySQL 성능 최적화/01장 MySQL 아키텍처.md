# MySQL 아키텍처

- 이 장에서는 MySQL 서버 아키텍처에 대해 살펴보고, 스토리지 엔진 간의 주요 차이점과 이러한 차이점이 중요한 이유에 대해 설명합니다.

## MySQL의 논리적 아키텍처

### 동시성 제어

- 두 개 이상의 쿼리가 동시에 데이터를 변경해야하는 경우 동시성 문제가 발생할 수 있습니다. 그리고 하나의 쿼리가 데이터를 읽고 있는 동시에 다른 쿼리가 데이터를 수정하게 된다면 기존 쿼리는 어떤 데이터를 봐야할까요? 이러한 문제를 공유 잠금(Shared Lock)과 전용 잠금(Exclusive Lock)을 활용하여 문제를 해결할 수 있습니다.

#### Shared Lock

- Shared Lock이 걸린 데이터에 대해서는 읽기(SELECT)만 가능하며, 쓰기 연산은 불가능합니다.
- Shared Lock이 걸린 데이터에 대해서 다른 트랜잭션에서도 똑같이 Shared Lock을 획득할 수 있으나, Exclusive Lock은 획득할 수 없습니다.

#### Exclusive Lock

- Exclusive Lock이 걸린 데이터에 대해서는 다른 트랜잭션이 읽기 연산이나 쓰기 연산을 할 수 없습니다.
- Exclusive Lock으로 인해 데드락에 빠질 수 있으니 수행시간 설정을 통해 데드락을 사전에 방지해야 합니다.

<br>


### 잠금 세분화

- MySQL은 다양한 자체 잠금 정책과 잠금 단위를 제공하고 있으며 이로인해 잠금으로 인한 오버헤드를 줄이며 성능을 향상시킬 수 있는 방법을 제공하고 있습니다.

#### 테이블 락

- 테이블 락은 개별 테이블 단위로 설정되는 잠금이며, 사용자가 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있습니다.
- 명시적 락은 LOCK TABLES [테이블 명 READ | WRITE]와 같은 명령어를 통해 락을 획득할 수 있으며 UNLOCK TABLES 명령어를 통해 락을 해제할 수도 있습니다.
- 묵시적 락은 테이블을 변경하는 쿼리가 실행되었을 경우 MySQL 서버가 해당 테이블에 대해 락을 획득하고 데이터를 변경한 다음 바로 락을 반납하게 됩니다. 이렇게 자동으로 획득 및 반납과정이 일어나기 때문에 편리하지만 InnoDB 스토리지 엔진의 경우 레코드 락을 기반으로 하기 때문에 테이블 락이 실행되더라도 DML에서는 무시되고, DDL에 대해서만 영향을 미칩니다.

#### 레코드 락

- 레코드 자체만을 잠그는 것을 레코드 락이라고 하며, InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드에 락을 설정합니다.
- 인덱스가 없더라도 내부적으로 6byte인 hidden key를 사용하여 레코드 락을 걸게됩니다.

#### 갭 락

- 갭 락은 레코드 자체가 아니라 레코드와 레코드 사이의 간격만을 잠그는 것을 의미합니다.
- 갭 락의 역할은 레코드와 레코드 사이에 새로운 레코드가 생성되는 것을 제어하는 역할을 합니다. 

#### 넥스트 키 락

- 레코드 락과 갭 락을 합친 형태입니다.
- InnoDB 스토리지 엔진의 갭 락이나 넥스트 키락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적입니다. 하지만 이외로 넥스트 키락과 갭락으로 인해 데드락이 발생할 수 있는데 가능하다면 바이너리 로그 포맷을 ROW 형태로 지정하는 것이 좋습니다.
(8.0버전 부터는 ROW 포맷이 기본 설정입니다.)

<br>

### 트랜잭션

- 트랜잭션은 ACID를 통해 안정성을 높일 수 있습니다.

#### 원자성(Atomicity)

- 트랜잭션은 전체 트랜잭션이 적용되거나 롤백되어야 합니다. 일부만 성공이거나 실패할 수 없습니다.

#### 일관성(Consistency)

- 트랜잭션이 성공적으로 완료되면 일관적인 데이터베이스 상태를 가져야합니다.
- 즉 데이터 타입이 정수였는데 갑자기 문자열로 되면 안됩니다.

#### 격리성(Isolation)

- 트랜잭션 수행시 다른 트랜잭션이 해당 작업에 끼어들 수 없습니다.
- 트랜잭션끼리 서로 간섭할 수 없습니다.

#### 지속성(Durability)

- 트랜잭션이 성공적으로 완료된다면 영구적으로 반영되어야 합니다.

<br>

### 격리 수준

- 일반적으로 격리 수준이 낮을수록 동시성 문제가 빈번히 발생하며, 오버헤드가 줄어들고 처리량을 높일 수 있습니다.

#### READ UNCOMMITTED

- 해당 격리 수준에서는 커밋되지 않은 트랜잭션의 결과를 볼 수 있습니다.
- 커밋되지 않은 데이터를 조회할 수 있으므로 Dirty Read가 발생할 수 있습니다.

#### READ COMMITTED

- Mysql을 제외한 대부분의 데이터베이스 시스템의 기본 격리 수준은 READ COMMITTED입니다.
- 커밋된 데이터만 조회할 수 있습니다. Phantom Read와 Non-Repeatable Read(반복 읽기 불가능) 문제가 발생할 수 있습니다.

#### REPEATABLE READ

- 해당 커밋 방식은 READ COMMITTED의 문제를 해결하고 Mysql의 기본 트랜잭션 격리 수준입니다.
- MVCC를 통해 변경 전의 데이터를 언두로그 공간에 백업을 해놓습니다. 이렇게 하면 변경 전/후의 데이터가 모두 존재하게 되는데, MVCC를 통해 트랜잭션이 롤백된 경우 데이터를 복원할 수 있을뿐만 아니라 서로 다른 트랜잭션 간에 접근할 수 있는 데이터를 세밀하게 제어할 수도 있습니다.
- REPEATABLE READ는 MVCC를 통해 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우 Phantom Read가 발생할 수 있습니다. 그렇지만 MySQL에서 REPEATABLE READ 격리 수준을 사용한다면 일반적인 상황에서는 Phantom Read가 발생하지 않습니다.

#### SERIALIZABLE






















