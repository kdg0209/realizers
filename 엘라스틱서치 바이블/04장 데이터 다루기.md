# 데이터 다루기

<br>

## 1. 단건 문서 API

### 색인 API

#### 여러 색인 API들

|종류|설명|
|------|------|
|PUT [인덱스 이름]/_doc/[_id값]|기본이 되는 API입니다. 만약 해당 인덱스에 같은 id가 있다면 새 문서로 덮어씌웁니다.|
|POST [인덱스 이름]/_doc|id값을 지정하지 않으면 엘라스틱서치가 자동으로 만들어줍니다.|
|PUT [인덱스 이름]/_create/[_id값]|항상 새 문서를 생성하는 경우에만 허용하고, 이미 같은 id가 있다면 예외가 발생합니다.|
|POST [인덱스 이름]/_create/[_id값]|항상 새 문서를 생성하는 경우에만 허용하고, 이미 같은 id가 있다면 예외가 발생합니다.|

#### 라우팅

- 색인 시 routing 매개변수를 통해 라우팅 값을 지정할 수 있습니다. 라우팅을 지정하지 않으면 _id 값의 해시값을 기반으로 샤드가 배정됩니다.

#### refresh

- 색인 시 refresh 매개변수를 지정하면 문서를 색인한 직후에 해당 샤드를 refresh하기 때문에 즉시 검색이 되도록 합니다.
- true나 wait_for 설정은 성능에 대한 고려가 필요합니다.(refresh 비용은 비쌉니다.)
- wait_for를 사용하면 index.refresh_interval 값의 크기만큼 응답 시간이 지연될 수 있습니다. 그러나 wait_for를 사용하더라도 너무 많은 요청이 대기 중인 경우 강제로 refresh가 수행될 수 있습니다. index.max_refresh_listeners 설정값 이상의 요청이 refresh를 대기하는 중이라면 강제로 refresh가 수행됩니다.
기본값은 1000인데 초당 1천 개 이상의 색인 요청이 wait_for로 들어오는 경우 강제 refresh가 수행됩니다.

|refresh 값|동작 방식|
|------|------|
|true|색인 직후 문서가 색인된 샤드를 refresh 하고 응답을 반환합니다.|
|wait_for|색인 이후 문서가 refresh될 때까지 기다린 후 응답을 반환합니다.|
|false|아무 값도 지정하지 않았을 때의 기본값입니다. refresh와 관련된 동작을 수행하지 않습니다.|

<br>

### 조회 API

- 조회 API는 문서 단건을 조회합니다. 또한 조회는 검색과 다르게 색인이 refresh 되지 않은 상태에서도 변경된 내용을 확인할 수 있습니다.
- _doc 명령어를 이용하면 기본적인 메타데이터를 함께 조회할 수 있으며, _source 명령어를 이용하면 메타데이터 없이 본문 내용만 검색됩니다.

```json
> _doc 명령어를 통해 조회
GET routing_test2/_doc/1?routing=my1
{
  "_index": "routing_test2",
  "_id": "1",
  "_version": 2,
  "_seq_no": 1,
  "_primary_term": 1,
  "_routing": "my1",
  "found": true,
  "_source": {
    "login_id": "myid 1",
    "comment": "hello1~",
    "created_date": "2024-07-26T15:25:30"
  }
}

> _source 명령어를 통해 조회
GET routing_test2/_source/1?routing=my1
{
  "login_id": "myid 1",
  "comment": "hello1~",
  "created_date": "2024-07-26T15:25:30"
}
```

<br>

### 업데이트 API

#### doc에 내용을 직접 기술하여 업데이트

- 업데이트 후 조회를 해보면 result가 updated인 것을 알 수 있습니다. 여기서 똑같은 내용으로 한번 더 업데이트를 하게된다면 result는 noop이 됩니다.

```json
> _update 명령어를 통해 업데이트
POST routing_test2/_update/1?routing=my1
{
  "doc": {
    "login_id": "myid 3",
    "comment": "hello1~"
  }
}

> 업데이트 응답값
{
  "_index": "routing_test2",
  "_id": "1",
  "_version": 5,
  "result": "updated", // or noop
  "_shards": {
    "total": 2,
    "successful": 1,
    "failed": 0
  },
  "_seq_no": 4,
  "_primary_term": 1
}
```

#### 💡 noop은 무엇을 의미할까?

- noop은 문서의 내용을 변경하지 않는것입니다.
- noop을 검사하는 것은 불필요한 디스크 I/O를 줄일 수 있으며, 이는 성능에 큰 영향을 미치고 기본적으로 noop 검사는 활성화되어 있습니다.

#### doc_as_upsert

- 업데이트 API는 기본적으로 기존 문서의 내용을 읽어들인 후 업데이트를 수행하는데, 만약 기존 문서가 없다면 예외가 발생합니다. 따라서 옵션을 통해 기존 문서가 없다면 insert 되도록 설정할 수 있습니다.

```json
POST routing_test2/_update/2?routing=my1
{
  "doc": {
    "login_id": "myid 4",
    "comment": "hello1~"
  },
  "doc_as_upsert": true
}
```

#### script를 이용하여 업데이트

- 엘라스틱서치에서 스크립트 언어는 painless를 이용하고 있습니다.
- ctx._source 변수를 통해 문서의 _source를 Map 형태로 반환받을 수 있습니다.

```json
> 문서 색인3
PUT update_script_test/_doc/1
{
  "title": "hello",
  "views": 1
}

> script를 사용하여 업데이트
POST update_script_test/_update/1
{
  "script": {
    "source": "ctx._source.views += params.count",
    "lang": "painless",
    "params": {
      "count": 1
    }
  }, 
  "doc_as_upsert": false
}
```

<br>

### 삭제 API

- 삭제는 아래 명령어 기반으로 사용할 수 있으며, 만약 인덱스 이름만 선언하면 인덱스 전체가 삭제되므로 주의가 필요합니다.

```text
DELETE [인덱스 이름]/_doc/[id 값] // 인덱스의 특정 문서 삭제
DELETE [인덱스 이름] // 인덱스 삭제
```

<br>

## 2. 복수 문서 API

### bulk API

- bulk API는 엘라스틱서치의 다른 API와는 다르게 요청 본문 내용을 JSON이 아닌 NDJSON 형태로 만들어 보냅니다.

#### bulk API의 작업 순서

- bulk API에 기술된 작업은 반드시 그 순서대로 수행된다는 보장이 없습니다. 조정 역할을 하는 노드가 요청을 수신하면 각 요청의 내용을 보고 적절한 주 샤드로 요청을 넘겨줍니다.
- 여러 개의 주 샤드에 넘어간 각 요청은 각자 독자적으로 수행됩니다. 그렇기 때문에 각 순서는 보장되지 않습니다.
- 그러나 동일한 인덱스, _id, 라우팅 조합을 가진 요청은 반드시 동일한 주 샤드로 넘어가기 때문에 동일한 문서에 대한 요청은 순서대로 동작하게 됩니다.

<br>

### multi get API

- multi get API는 _id를 여럿 지정하여 해당 문서를 한 번에 조회하는 API입니다.

```json
> _mget 명령어를 통해 여러 건 조회
GET _mget
{
  "docs": [
    {
      "_index": "movie",
      "_id": 1
    },
    {
      "_index": "movie",
      "_id": 4
    },
    {
      "_index": "movie",
      "_id": 5,
      "_source": {
        "include": ["title", "views"]
      }
    }
  ]
}

> 응답값
{
  "docs": [
    {
      "_index": "movie",
      "_id": "1",
      "_version": 2,
      "_seq_no": 3,
      "_primary_term": 1,
      "found": true,
      "_source": {
        "title": "test",
        "views": 1234,
        "public": true,
        "created": "2024-07-24T16:26:30"
      }
    },
    {
      "_index": "movie",
      "_id": "4",
      "_version": 1,
      "_seq_no": 8,
      "_primary_term": 2,
      "found": true,
      "_source": {
        "title": "집가고 싶어",
        "views": 20,
        "public": true,
        "created": "2024-07-25T16:27:30"
      }
    },
    {
      "_index": "movie",
      "_id": "5",
      "_version": 1,
      "_seq_no": 9,
      "_primary_term": 2,
      "found": true,
      "_source": {
        "title": "집에 언제갈까?f=",
        "views": 25
      }
    }
  ]
}
```

<br>

### update by query

- 검색 쿼리를 통해 주어진 조건을 만족하는 문서를 찾은 뒤 그 문서를 대상으로 업데이트나 삭제 작업을 실시하는 API입니다.
- 여러 문서의 업데이트가 순차적으로 진행되는 도중 다른 작업으로 인해 문서에 변경이 생길 수 있는데, 이때 update by query는 스냅샷을 찍어 뒀던 문서에 변화가 생긴 문서를 발견하면 업데이트하지 않습니다.
- 변화된 문서를 발견하면 전체 작업을 해당 지점에서 그만둘 수도 있고 다음 작업으로 넘어갈 수 있습니다.(abort: 충돌시 작업 중단, proceed: 다음 작업으로 넘김), 아무튼 충돌이 발생해서 작업이 중단되면 그때까지 변경된 내용은 롤백되지 않습니다.

#### 스로틀링

- update by query는 관리적인 목적으로 수행되는 경우가 많은데, 문제가 생긴 데이터를 일괄적으로 처리하거나 변경된 비지니스 요건에 맞게 데이터를 일괄 수정하는 작업 등에 많이 활용됩니다. 이때 대량의 작업을 운영중인 서비스에 하게되면 문제가 발생할 수 있기 때문에 스로틀링을 적용할 수 있습니다.
- update by query는 업데이트 전 먼저 검색을 수행하는데, 검색 갯수는 scroll_size로 설정할 수 있습니다.(1000건씩 검색 후 업데이트)
- update by query는 처음 검색을 수행하면 스냅샷을 찍는데, 스냅샷을 search context에 보존하는 시간입니다. 1m은 1분이며 이 시간은 모든 배치 작업이 끝나는 시간이 아니라 하나의 배치 작업에 필요한 시간을 지정하는 것입니다.
- requests_per_seconds는 평균적으로 초당 몇 개까지의 작업을 수행할 것인지 지정하는 것입니다.

```text
POST [인덱스 이름]/_update_by_query?scroll_size=1000&scroll=1m&requests_per_seconds=500
{
   // ...
}
```

<br>

### delete by query

- delete by query 또한 검색 쿼리를 통해 삭제할 대상을 지정한 뒤에 삭제 작업을 수행하는 것입니다.
- delete by query는 오래된 데이터 등 더 이상 사용되지 않는 데이터를 삭제하는 경우에 많이 사용됩니다.

<br>

## 3. 검색 API





