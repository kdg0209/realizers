# Java volatile

- volatile은 변수의 가시성과 연산의 순서를 제어하기 위해 사용하는 키워드입니다.
- volatile를 사용함으로써 스레드 간의 데이터 일관성과 가시성을 보장할 수 있습니다.

<br>

## CPU 캐시 메모리와 메인 메모리

- CPU 캐시 메모리는 CPU와 메인 메모리 사이에서 데이터 흐름을 최적화 시키고, 성능을 향상시키기 위해 사용되는 고속 메모리입니다.
- CPU는 값을 읽어올 때 우선 CPU 캐시에 값이 있는지 확인하고 없는 경우에만 메인 메모리에 접근하여 값을 가져옵니다.
- 그럼 CPU 캐시에는 어떤 데이터들이 저장될까요?
  - CPU가 메인 메모리에 접근할 때 참조 지역성의 원리를 통해 CPU가 접근한 메모리 근처의 값들을 CPU 캐시에 담게 됩니다.

#### 과정

1. CPU는 메인 메모리로부터 데이터를 CPU 캐시로 읽어들이게 됩니다.
2. 캐시 데이터를 CPU register로 읽어들이고, 읽어온 데이터를 기반으로 ALU, 제어장치로부터 필요한 연산을 수행하게 됩니다.
3. 작업한 결과를 CPU register에서 캐시 메모리로 보내고, 적절한 시점에 CPU 캐시에서 메인 메모리로 보내게 됩니다.
4. 이러한 과정을 반복하게 됩니다.

<br>

<img width="1032" alt="스크린샷 2024-03-09 오후 1 20 16" src="https://github.com/kdg0209/realizers/assets/80187200/ecd43650-5a50-431f-aa6d-9cc8672a9ede">

<br>

#### 🧨 문제점

- 성능을 높이기 위해서 CPU 캐시를 사용하는데 무엇이 문제가 될까요?
- 멀티 스레드 환경에서 CPU에 할당된 스레드가 메인 메모리가 아닌 CPU 캐시에서 공유 변수를 참조하게 되면 서로 다른 변수값을 스레드가 참조하게 되는 상황이 발생하여 데이터의 일관성이 깨질 수 있습니다.

<br>

<img width="1032" alt="스크린샷 2024-03-09 오후 1 26 17" src="https://github.com/kdg0209/realizers/assets/80187200/9e836965-e250-44dc-898e-6f5716f5312f">

<br>
<br>

## 가시성이란?

- 멀티 스레드 환경에서 공유 변수의 변경 내용이 한 스레드에서 다른 스레드에게 어떻게 보이는지를 나타내는 개념입니다.
- 멀티 스레드 프로그래밍에서 여러 스레드가 동시에 변수에 접근하여 수정할 수 있기 때문에 모든 스레드에게 값이 일관되게 보여지도록 가시성이 확보되어야합니다.

### 가시성 문제

- CPU 캐시에 작업한 결과가 메인 메모리에 즉시 반영되지 않을 경우 스레드 간 결과가 다르게 보여지는 현상입니다.

#### 과정

1. 스레드A가 메인 메모리로부터 number라는 값을 가져와 1을 더하여 2가 되었습니다. 그리고 캐시 메모리에는 반영했지만 아직 메인 메모리에는 반영하지 않은 상태입니다.
2. 이제 스레드B가 실행되어 메인 메모리로부터 number라는 값을 가져와서 자신의 로직을 수행하게 되는데, 스레드B는 스레드A가 변경한 데이터가 메인 메모리에 반영되지 않은 상태에서 값을 읽기 때문에 두 스레드는 서로 다른 값을 바라보게 됩니다. 즉 가시성의 문제가 발생합니다.
3. 이 처럼 스레드간 가시성을 확보하기 위해서는 CPU가 작업한 결과를 즉시 메인 메모리에 반영해야 하며, 스레드는 캐시가 아닌 메인 메모리로부터 값을 참조해야 합니다.

<br>

<img width="1032" alt="스크린샷 2024-03-09 오후 1 43 37" src="https://github.com/kdg0209/realizers/assets/80187200/efad74f8-0ff2-440d-a561-b35af0e4d5c1">

<br>
<br>

## volatile의 원리

- CPU 캐시 메모리로 인해 스레드간 가시성 문제가 발생한 경우 volatile 키워드를 사용하여 문제를 해결할 수 있습니다.
- 공유 변수에 volatile 키워드를 사용함으로써 CPU가 데이터를 작업할 때 캐시 메모리를 거치지 않고 메인 메모리에서 직접 공유 변수를 읽고, 수정된 결과를 즉시 메인 메모리에 반영하게 됩니다.

<img width="1032" alt="스크린샷 2024-03-09 오후 1 59 57" src="https://github.com/kdg0209/realizers/assets/80187200/8c624f70-2dae-4d4b-9e17-8a9caf99308a">

<br>

### volatile의 한계점

- volatile 키워드는 스레드간 가시성은 보장하지만 동시성은 보장해주지 않습니다.
- volatile 키워드는 읽기 작업을 하는 스레드가 N개 이고, 수정 작업을 하는 스레드가 1개라면 동시성을 보장하지만 N:N의 상황이라면 동시성을 보장해주지 못합니다.

<img width="1032" alt="스크린샷 2024-03-09 오후 2 26 48" src="https://github.com/kdg0209/realizers/assets/80187200/5cd92c46-9d3d-4047-b8a1-93621e73ecaa">

<br>
<br>

### race condition 

- volatile을 선언함으로써 race condition이 발생하지 않을꺼라는 착각이 들곤합니다. 그 이유는 서로 다른 스레드가 메인 메모리로부터 값을 가져오면 가장 최신의 값을 가져오기 때문에 동시성이 발생하지 않을거라 생각하는데 
동시성 즉 race condition과 가시성은 별개의 문제입니다. 그렇기 때문에 가시성을 확보했더라도 race condition이 발생할 수 있습니다.

#### 과정

1. 스레드A와 스레드B가 동시에 메인 메모리로부터 값을 읽어 들입니다.
2. 스레드A와 스레드B는 동시에 값을 가져와 1을 누적하고 메인 메모리에 반영하더라도 2가 반영됩니다. 정상적으로 작동하다면 3이 반영되어야겠죠?

<img width="1032" alt="스크린샷 2024-03-09 오후 2 11 43" src="https://github.com/kdg0209/realizers/assets/80187200/be594504-7843-400d-bd7e-03dbd9aa7382">

<br>
<br>

### Synchronized

- synchronized 키워드를 사용하면 한 시점에 오직 하나의 스레드만이 임계 영역에 접근할 수 있습니다.
- synchronized 블록 안에서 참조하는 모든 변수들은 메인 메모리로부터 값을 읽어오고, 블록을 벗어나면 그동안 수정된 모든 변수들이 즉시 메인 메모리로 반영됩니다.
- 즉 synchronized는 race condition과 가시성의 문제까지 해결할 수 있습니다. 그리고 synchronized 블록에서는 volatile 키워드가 없어도 됩니다.


