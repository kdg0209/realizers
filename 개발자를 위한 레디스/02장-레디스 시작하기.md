# 레디스 시작하기

### 레디스 설치

```
1. docker ubuntu 이미지 다운로드
- docker image pull ubuntu

2. redis 설치를 위한 ubuntu 컨테이너 실행 포트 6379 개방
- docker run -it --name redis -p 6379:6379 --privileged=true ubuntu

3. ubuntu 컨테이너 접속
- docker exec -it redis bin/bash

4. redis 설치
- apt-get update && upgrade
- apt-get install redis-server

5. redis.conf 수정 (redis-cli 비밀번호 설정)
- vi /etc/redis/redis.conf
- requirepass admin

6. redis 서버 재시작
- service redis-server restart

7. redis 접속
- redis-cli
auth admin
```

<br>

### 주요 옵션 설정

#### THP 비활성화

- 우선 THP(Transparent Huge Pages)가 무엇인지 알 필요성이 있을거 같습니다.
- 리눅스는 메모리를 Page라는 블록으로 분할해 관리를 합니다. 기본 Page의 크기는 4KB인데 만약 1GB의 메모리를 Page로 분할하면 256,000개의 Page로 분할됩니다. 그리고 Page가 많아질수록 페이지를 관리하는 TLB의 크기가 커지는데
- 이를 방지하기 위해 리눅스에서는 Page 자체의 크기를 키우고 Page 개수를 줄여 TLB의 크기를 작게 만드는 THP 기능을 도입하고 있습니다.

<br>

#### 리눅스의 TLB 과정

- 리눅스에서 메모리에 접근하기 위해서는 기존에 페이지 테이블 참조 후 메인 메모리에 접근할 수 있습니다. 이렇게 된다면 메모리에 접근하기 위해서는 2번의 메모리 접근이 필요한데 이는 오버헤드가 발생하기 때문에 TLB라는 하드웨어를 사용하게 됩니다.
TLB는 페이지 테이블에서 빈번히 참조되는 일부 엔트리를 캐싱하고 있으며, key-value 형식으로 데이터를 보관하고 있습니다. key는 페이지 번호, value는 메모리의 프레임 번호를 가지고 있습니다.
- CPU는 페이지 테이블보다 TLB를 우선적으로 참조하여, 만약 원하는 페이지 번호가 TLB에 있는 경우 바로 프레임 번호를 알 수 있지만 그렇지 않은 경우에 메인 메모리에 있는 페이지 테이블을 이용하여 프레임 번호를 알 수 있습니다.
- 결국 THP를 비활성화를 하는 이유는 page가 커질수록 TLB도 커지고, page 크기를 키우고 page 개수를 줄이더라도 결국 오버헤드가 발생하므로 해당 기능을 비활성화하는것 같습니다.
- 더 자세한 내용을 알고 싶다면 아래 링크를 참고해주세요.
  - https://kdg-is.tistory.com/entry/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC
  - https://github.com/kdg0209/realizers/blob/main/self-learning-cs/14%EC%9E%A5%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC.md

<img width="1028" alt="스크린샷 2024-03-17 오후 2 23 20" src="https://github.com/kdg0209/realizers/assets/80187200/7381f6c1-f8cc-43d6-bed8-e4ed075abba6">

<br>
<br>

```
1. THP 설정 확인
- cat /sys/kernel/mm/transparent_hugepage/enabled

2. THP 비활성화
- echo never >  /sys/kernel/mm/transparent_hugepage/enabled
```

<br>

#### vm.overcommit_memory= 1로변경

- redis는 디스크에 파일을 저장할 때 fork() 메서드를 이용해 백그라운드 프로세스를 만든 후 copy-on-write 기법을 통해 자식 프로세스의 페이지를 관리하게 됩니다.
- copy-on-write는 부모 프로세스와 자식 프로세스가 동일한 페이지를 공유하고 있다가 둘 중 하나의 변경이 발생할 때마다 페이지를 복사하기 때문에 변경이 많아질수록 메모리 사용량이 증가하게 됩니다.
- 레디스에서 메모리 할당량을 초과하는 상황이 발생하는데 vm.overcommit_memory= 1로 설정하여 불필요한 오류를 방지하고, 성능을 향상시키고 메모리 부족 문제를 완화시킬 수 있습니다.

- 참고
  - https://medium.com/@akhshyganesh/redis-enabling-memory-overcommit-is-a-crucial-configuration-68dbb77dae5f
  - https://kdg-is.tistory.com/entry/%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC

<br>

#### somaxconn과 SyncBacklog 설정변경

- 해당 옵션은 TCP 3-Way Handshak 과정에서 사용자가 갑자기 몰렸을 때 sny-ack에서 Backlog Queue에 저장되어 있다가 ACK가 올때 Backlog Queue에서 제거됩니다.
그래서 초당 들어오는 많을 경우 Backlog 사이즈가 작다면 이슈가 발생할 수 있으므로 아래 설정을 해줍니다.
- https://steemit.com/sny/@jaerakson/redis-backlog-test

```
1. 영구 저장 방법 아래 두 옵션 저장 후 재시작
- vi /etc/sysctl.conf
net.ipv4.tcp_max_syn_backlog=1024
net.core.somaxconn=1024 

2. 재부팅없이 적용 
sysctl -w net.core.somaxconn=1024 
sysctl -w net.ipv4.tcp_max_syn_backlog=1024
```
