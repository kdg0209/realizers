# 레디스를 메시지 브로커로 사용하기

- 최근 MSA가 유행하고 있는데, 해당 아키텍처에서 모듈간의 통신은 동기보다 비동기적으로 통신하는 것을 권장하며, 각 서비스간 통신이 불가능한 상황에서 바로 장애로 이어지지 않게 당장 메시지를 처리하진 못하더라도 보낸 메시지를 어딘가에 저장한 후 나중에 처리할 수 있도록 해주는 것이 메시지 브로커의 핵심입니다.
- 메시지 브로커는 크게 메시징 큐, 이벤트 스트림으로 구분할 수 있습니다.

<br>

## 메시징 큐

- 메시징 큐는 Producer가 Consumer에게 메시지를 push합니다.
- Push의 단점은 Consumer가 처리하지 못하더라도 메시지는 계속 버퍼에 담길 수 있고, Back Pressure 처리를 할 수 없기 때문에 효율성이 떨어질 수 있습니다.
- 메시지는 단순히 큐에 담기기 때문에 영속성을 가질 수 없습니다. 그리고 consumer가 메시지를 소비하면 큐에서 삭제됩니다.
- 메시지를 보내는 도중 새로운 consumer가 추가된다면 이전 메시지는 소비할 수 없습니다. 
<img width="1032" alt="스크린샷 2024-03-23 오후 3 33 34" src="https://github.com/kdg0209/realizers/assets/80187200/d8ec4727-ba2c-4a9c-94f5-a1f6db87a1e8">

<br>

## 이벤트 스트림

- Subscriber는 자신이 처리할 수 있는 만큼 메시지를 가져오기 때문에 Back Pressure 처리를 할 수 있습니다.
- Subscriber가 메시지를 소비하더라도 메시지 보존 정책에 따라 특정 기간동안 메시지를 보존할 수 있습니다.
- 메시지를 보내는 도중 새로운 Subscriber가 추가되더라도 메시지는 디스크에 저장되어 있기 때문에 특정 구간부터 소비할 수도 있습니다.
<img width="1032" alt="스크린샷 2024-03-23 오후 3 32 55" src="https://github.com/kdg0209/realizers/assets/80187200/a4b7ba67-7b7f-42f7-a372-1da222052ab1">

<br>

## 레디스의 Pub/Sub

- 레디스에서 제공하는 pub/sub을 사용하면 간단한 메시지 브로커를 구축할 수 있습니다.
- publisher가 특정 채널에 메시지를 발행하면 해당 채널을 듣고 있는 subscriber가 데이터를 바로 소비할 수 있지만 어떤 subscriber가 메시지를 읽어 갔는지 잘 받았는지에 대한 정보는 pulisher가 알 수 없습니다.
- 해당 방식은 fire-and-forget 방식이므로 subscriber가 메시지를 잘 받았는지에 대한 ACK를 받을 수 없습니다.

<img width="1032" alt="스크린샷 2024-03-23 오후 3 51 39" src="https://github.com/kdg0209/realizers/assets/80187200/a9cc51ec-7608-4fb0-8f41-77c0dc8a2a4a">

<br>

<img width="1032" alt="스크린샷 2024-03-23 오후 4 03 15" src="https://github.com/kdg0209/realizers/assets/80187200/e6b702a1-18e5-48cd-92fb-a0b80e406435">

<br>
<br>

### 클러스터 구조에서의 pub/sub

- 레디스 클러스터에서 pub/sub을 사용할 때, 메시지를 발행하면 해당 메시지를 클러스터 내에 속한 모든 노드에 자동으로 전달됩니다.
- 클러스터 구조에서 하나의 노드에 메시지를 발행하면 전체 노드에 메시지가 전파되는데, 클러스터 목적을 고려하면 해당 방식은 비효율적일 수 있습니다. 클러스터는 고가용성을 위한 목적인데 대규모 서비스에서 모든 노드에게 메시지를 분산하여 저장한다면 메모리 사용량도 증가하고 불필요한 리소스가 발생하게 됩니다.


### Sharded pub/sub

- 클러스터 구조에서의 pub/sub이 비효율적이기 때문에 레디스 7.0에서 sharded pub/sub이 등장하게 되었습니다.
- sharded pub/sub을 사용하면 클러스터 구조에서 모든 노드에 메시지가 복제되는게 아니라 같은 슬롯을 가지고 있는 노드에게만 복제되므로 블필요한 리소스를 방지할 수 있습니다.

### 레디스의 List를 메시징 큐로 이용하기

- List를 메시징 큐로 활용한다면 RPUSHX, LPUSHX 등의 명령어를 토대로 키가 있는 경우에만 데이터를 삽입할 수 있습니다.
- https://redis.io/commands/lpushx/

```
> RPUSH list-A hello
> RPUSH list-A world
> LRANGE list-A 0 -1
1) "hello"
2) "world"

> RPUSHX list-B hello~
(integer) 0
```

### 레디스 List의 블로킹

- List에 저장되어 있는 데이터를 주기적으로 가져가기 위해서는 스케줄러를 통해 주기적으로 리스트를 폴링하는 방법이 있습니다. 그러나 이 방법은 레디스에 부하를 줄 수 있고, 애플리케이션의 리소스등 불필요한 자원을 소모하게 됩니다.
- 이때 BRPOP BLPOP 명령어를 통해 블로킹을 할 수 있습니다.

<br>

## Stream

- stream은 레디스 5.0에서 새로 추가된 자료 구조로 kafka처럼 로그 파일에 데이터를 append-only하는 방식입니다.
- 레디스에서는 하나의 stream 자료 구조가 하나의 stream을 의미합니다. 레디스의 string, hash, list, set 등 다른 자료 구조와 마찬가지로 stream 형태의 자료구조가 존재합니다.
- stream 또한 자료구조이므로 하나의 키에 연결됩니다.
- 레디스 stream에서 각 메시지는 시간과 관련된 유니크한 ID를 가지며, 이 값은 중복되지 않습니다.
  - millisecondTime:sequenceNumber

### 데이터 저장

- Email이라는 stream을 생성하면서 title이라는 키에 hello!라는 값 삽입, body라는 키에 world라는 값 삽입, *는 millisecondTime을 레디스에서 자동으로 생성되는 타임스탬프로 하겠다는 의미
- 이미 Email stream이 존재하면 새로운 메시지는 로그 파일에 append됩니다.
```
> XADD Email * title "hello!" body "world"
"1711192850502-0"
> XADD Email * title "update hello!" body "update world"
"1711193025488-0"
```

### 데이터 조회

#### 1. 실시간 조회 

```
// test-stream에 데이터 저장
> XADD test-stream * user1 "hello"
"1711193438697-0"
> XADD test-stream * user1 "hello1"
"1711193442513-0"
> XADD test-stream * user1 "hello2"
"1711193444360-0"
> XADD test-stream * user1 "hello3"
"1711193445600-0"
> XADD test-stream * user1 "hello4"
"1711193447431-0"
> XADD test-stream * user1 "hell5"
"1711193525065-0"
> XADD test-stream * user1 "hell6"
"1711193538050-0"
> XADD test-stream * user1 "hell7"

// 데이터 조회
> XREAD BLOCK 0 STREAMS test-stream 0
1) 1) "test-stream"
   2) 1) 1) "1711193438697-0"
         2) 1) "user1"
            2) "hello"
      2) 1) "1711193442513-0"
         2) 1) "user1"
            2) "hello1"
      3) 1) "1711193444360-0"
         2) 1) "user1"
            2) "hello2"
      4) 1) "1711193445600-0"
         2) 1) "user1"
            2) "hello3"
      5) 1) "1711193447431-0"
         2) 1) "user1"
            2) "hello4"
      6) 1) "1711193525065-0"
         2) 1) "user1"
            2) "hell5"
      7) 1) "1711193538050-0"
         2) 1) "user1"
            2) "hell6"
      8) 1) "1711193542377-0"
         2) 1) "user1"
            2) "hell7"
```

#### 2. 특정 데이터 조회

```
// 타임스탬프가 1711193444360 이전인 데이터 조회
> XRANGE test-stream - 1711193444360
1) 1) "1711193438697-0"
   2) 1) "user1"
      2) "hello"
2) 1) "1711193442513-0"
   2) 1) "user1"
      2) "hello1"
3) 1) "1711193444360-0"
   2) 1) "user1"
      2) "hello2"

// 타임스탬프가 1711193444360 이후인 데이터 조회
> XRANGE test-stream 1711193444360 +
... 생략
```

<br>

### 소비자와 소비자 그룹

- 같은 데이터를 여러 소비자에게 전달하는 것을 fan-out이라 합니다.
- 카프카는 하나의 토픽에 여러 소비자가 메시지를 가져갈 수 있기 때문에 fan-out할 수 있습니다.
- 레디스에서도 XREAD 커맨드를 여러 소비자가 수행한다면 fan-out이 가능합니다.
- 레디스에서도 처리 성능을 높이기 위해

#### stream 순서 보장

- 레디스 stream에서는 데이터가 저장될 때마다 고유한 ID를 부여받아 순서대로 저장되기 때문에 소비자 입장에서도 순서가 항상 유지됩니다.

#### 소비자 그룹

- 레디스 stream에서 소비자 그룹 내의 한 소비자는 다른 소비자가 아직 읽지 않은 데이터만을 읽어갑니다.
- 소비자 그룹 1의 소비자가 a라는 메시지를 읽었다면 같은 그룹내에서는 그 메시지를 다시 읽을 수 없지만, 소비자 그룹 2 혹은 다른 소비자는 해당 메시지를 읽을 수 있습니다.

![스크린샷 2024-03-27 오후 10 47 40](https://github.com/kdg0209/realizers/assets/80187200/6110e79e-bf77-4d13-81c8-20d09ab396b6)

<br>

#### ACK와 보류 리스트

- 여러 서비스가 메시지 브로커를 이용해 데이터를 처리할 때, 예상치 못한 장애로 시스템이 종료되었을 경우 재처리할 수 있는 기능이 필요합니다.
- 메시지 브로커는 각 소비자에게 어떤 메시지를 전달했고, 전달된 메시지의 처리 유무를 인지하고 있어야 합니다.
- 레디스 stream에서는 소비자 그룹에 속한 소비자가 메시지를 읽어가면 각 소비자별로 읽어간 메시지에 대한 리스트를 새로 만들며, 마지막으로 읽어간 데이터의 ID로 last_delivered_id 깂을 업데이트합니다.

### 궁금증














