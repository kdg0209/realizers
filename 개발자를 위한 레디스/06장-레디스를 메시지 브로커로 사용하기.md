# 레디스를 메시지 브로커로 사용하기

- 최근 MSA가 유행하고 있는데, 해당 아키텍처에서 모듈간의 통신은 동기보다 비동기적으로 통신하는 것을 권장하며, 각 서비스간 통신이 불가능한 상황에서 바로 장애로 이어지지 않게 당장 메시지를 처리하진 못하더라도 보낸 메시지를 어딘가에 저장한 후 나중에 처리할 수 있도록 해주는 것이 메시지 브로커의 핵심입니다.
- 메시지 브로커는 크게 메시징 큐, 이벤트 스트림으로 구분할 수 있습니다.

<br>

## 메시징 큐

- 메시징 큐는 Producer가 Consumer에게 메시지를 push합니다.
- Push의 단점은 Consumer가 처리하지 못하더라도 메시지는 계속 버퍼에 담길 수 있고, Back Pressure 처리를 할 수 없기 때문에 효율성이 떨어질 수 있습니다.
- 메시지는 단순히 큐에 담기기 때문에 영속성을 가질 수 없습니다. 그리고 consumer가 메시지를 소비하면 큐에서 삭제됩니다.
- 메시지를 보내는 도중 새로운 consumer가 추가된다면 이전 메시지는 소비할 수 없습니다. 
<img width="1032" alt="스크린샷 2024-03-23 오후 3 33 34" src="https://github.com/kdg0209/realizers/assets/80187200/d8ec4727-ba2c-4a9c-94f5-a1f6db87a1e8">

<br>

## 이벤트 스트림

- Subscriber는 자신이 처리할 수 있는 만큼 메시지를 가져오기 때문에 Back Pressure 처리를 할 수 있습니다.
- Subscriber가 메시지를 소비하더라도 메시지 보존 정책에 따라 특정 기간동안 메시지를 보존할 수 있습니다.
- 메시지를 보내는 도중 새로운 Subscriber가 추가되더라도 메시지는 디스크에 저장되어 있기 때문에 특정 구간부터 소비할 수도 있습니다.
<img width="1032" alt="스크린샷 2024-03-23 오후 3 32 55" src="https://github.com/kdg0209/realizers/assets/80187200/a4b7ba67-7b7f-42f7-a372-1da222052ab1">

<br>

## 레디스의 Pub/Sub

- 레디스에서 제공하는 pub/sub을 사용하면 간단한 메시지 브로커를 구축할 수 있습니다.
- publisher가 특정 채널에 메시지를 발행하면 해당 채널을 듣고 있는 subscriber가 데이터를 바로 소비할 수 있지만 어떤 subscriber가 메시지를 읽어 갔는지 잘 받았는지에 대한 정보는 pulisher가 알 수 없습니다.
- 해당 방식은 fire-and-forget 방식이므로 subscriber가 메시지를 잘 받았는지에 대한 ACK를 받을 수 없습니다.

<img width="1032" alt="스크린샷 2024-03-23 오후 3 51 39" src="https://github.com/kdg0209/realizers/assets/80187200/a9cc51ec-7608-4fb0-8f41-77c0dc8a2a4a">

<br>

<img width="1032" alt="스크린샷 2024-03-23 오후 4 03 15" src="https://github.com/kdg0209/realizers/assets/80187200/e6b702a1-18e5-48cd-92fb-a0b80e406435">

<br>
<br>

### 클러스터 구조에서의 pub/sub

- 레디스 클러스터에서 pub/sub을 사용할 때, 메시지를 발행하면 해당 메시지를 클러스터 내에 속한 모든 노드에 자동으로 전달됩니다.
- 클러스터 구조에서 하나의 노드에 메시지를 발행하면 전체 노드에 메시지가 전파되는데, 클러스터 목적을 고려하면 해당 방식은 비효율적일 수 있습니다. 클러스터는 고가용성을 위한 목적인데 대규모 서비스에서 모든 노드에게 메시지를 분산하여 저장한다면 메모리 사용량도 증가하고 불필요한 리소스가 발생하게 됩니다.


### Sharded pub/sub

- 클러스터 구조에서의 pub/sub이 비효율적이기 때문에 레디스 7.0에서 sharded pub/sub이 등장하게 되었습니다.
- sharded pub/sub을 사용하면 클러스터 구조에서 모든 노드에 메시지가 복제되는게 아니라 같은 슬롯을 가지고 있는 노드에게만 복제되므로 블필요한 리소스를 방지할 수 있습니다.

### 레디스의 List를 메시징 큐로 이용하기

- List를 메시징 큐로 활용한다면 RPUSHX, LPUSHX 등의 명령어를 토대로 키가 있는 경우에만 데이터를 삽입할 수 있습니다.
- https://redis.io/commands/lpushx/

```
> RPUSH list-A hello
> RPUSH list-A world
> LRANGE list-A 0 -1
1) "hello"
2) "world"

> RPUSHX list-B hello~
(integer) 0
```

### 레디스 List의 블로킹

- List에 저장되어 있는 데이터를 주기적으로 가져가기 위해서는 스케줄러를 통해 주기적으로 리스트를 폴링하는 방법이 있습니다. 그러나 이 방법은 레디스에 부하를 줄 수 있고, 애플리케이션의 리소스등 불필요한 자원을 소모하게 됩니다.
- 이때 BRPOP BLPOP 명령어를 통해 블로킹을 할 수 있습니다.

<br>

## Stream

### 궁금증














