# 레디스를 캐시로 사용하기

- 캐시란 무엇인지?
- 어떤 상황에서 캐시를 사용해야 하는지?
- 레디스를 캐시로 활용할 때 잘 사용하는 방법과 무엇을 주의해야 하는지?
- 캐시와 세션 차이가 무엇인지?

## 레디스와 캐시

### 캐시란?

- 캐시란 메인 메모리에 저장되어 있는 원본 데이터보다 더 빠르고 효율적으로 접근할 수 있는 임시 데이터 저장소입니다.
- 캐시는 정말 자주사용되고, 평소 우리가 개발할 때 알게 모르게 사용되곤합니다. 자바로 애플리케이션을 개발하다보면 간혹 race-condition 문제가 발생하곤 하는데 이 또한 캐시와 상관이 있습니다.
  cpu는 명령어 수행시 메인 메모리로 바로 접근하는게 아니라 중간에 있는 캐시 메모리를 한번 거치게 됩니다. 이때 가시성 문제가 발생할 수 있는데 이또한 캐시입니다. 그래서 자바에서는 volatile 키워드를 사용하여 가시성 문제를 해결하곤합니다.
  - https://github.com/kdg0209/realizers/blob/main/inflearn-java-concurrency-programming/java%20volatile.md
 
#### 🤔 어떤 상황에서 캐시가 좋을까?

- 원본 데이터 저장소에서 원하는 데이터에 접근할 때 오래 걸리는 경우
- 사용자가 자주 검색하고, 잘 변하지 않는 데이터일 경우

<br>

### 캐시로서의 레디스

- 레디스는 모든 데이터를 메모리에 저장하는 인 메모리 데이터 저장소이기 때문에 데이터를 검색하고 반환하는 것이 빠릅니다.
- RDBMS의 경우는 필요한 데이터를 검색하기 위해서 디스크 I/O가 발생하는데 레디스의 경우 메모리에 모든 데이터가 존재하기 때문에 데이터에 접근하는 시간이 빠릅니다.
- 레디스는 평균 읽기 및 쓰기 작업 속도가 1ms 미만이며, 초당 수백만 건의 작업이 가능합니다.
- 레디스는 고가용성 기능을 자체적으로 가지고 있기 때문에 안정적인 운영을 할 수 있습니다. 레디스의 센티널 또는 클러스터 기능을 사용하면 마스터 노드에 장애가 발생시 자동으로 fail-over를 발생시키기 때문에 운영자의 개입 없이 캐시는 정상적으로 유지될 수 있어서 가용성이 높아집니다.

<br>

### 캐싱 전략

- 캐싱 전략은 캐싱되는 데이터의 유형과 데이터에 접근 패턴에 따라 다르기 때문에 서비스에 맞는 적절한 캐싱 전략을 선택해야 합니다.

#### 읽기 전략(Look Aside) 패턴

- 캐시 히트인 경우
  1. 사용자는 서버에 요청을 보냅니다.
  2. 서버는 우선적으로 레디스에서 데이터를 조회하게됩니다.
  3. 레디스에 원하는 데이터가 있는 경우 캐시 히트가 되며 서버에 반환됩니다.
  4. 서버는 레디스로부터 받은 데이터를 사용자에게 반환합니다.

![스크린샷 2024-03-22 오후 11 31 16](https://github.com/kdg0209/realizers/assets/80187200/840e396e-dad2-4b6b-9f03-cf09e92d0dad)

<br>

- 캐시 미스인 경우
  1. 사용자는 서버에 요청을 보냅니다.
  2. 서버는 우선적으로 레디스에서 데이터를 조회하게됩니다.
  3. 레디스에서 원하는 데이터를 찾지 못해 캐시 미스가 됩니다.
  4. 서버는 다음으로 데이터 베이스에서 원하는 데이터를 찾게됩니다.
  5. 서버는 데이터 베이스에서 검색한 값을 사용자에게 반환합니다.

![스크린샷 2024-03-22 오후 11 33 56](https://github.com/kdg0209/realizers/assets/80187200/6a171277-78c4-4485-9ec8-e1282a236dc2)

<br>

#### 🧨 읽기 전략이 가지고 있는 문제점

- 레디스에 문제가 발생하여 접근을 하지 못하는 경우 수 많은 트래픽이 원본 데이터 베이스로 몰리게 됩니다. 이는 데이터 베이스 읽기 전용 트랜잭션이 급격하게 증가하게되고, 리소스를 많이 차지하는 등의 이슈가 발생하게 됩니다.
- 기존에 사용 중인 서비스에 레디스를 처음 투입하거나, 데이터 베이스만 새로운 값을 저장하고 레디스에는 새로운 값을 저장하지 않은 경우에 사용자가 급격히 몰리는 경우 레디스에 값이 없기 때문에 캐시 미스가 발생하여 데이터 베이스에 커넥션이 많이 몰리게 됩니다. 따라서 예상치 못한 이슈가 발생할 수 있습니다.

#### 💡 캐시 워밍(Cache Warming)

- 캐시 워밍이란 사전에 데이터 베이스에 있는 값을 레디스로 데이터를 밀어 넣는 작업입니다.
- 해당 작업을 수행함으로써 서비스에 레디스를 처음 투입하거나, 데이터 베이스에만 새로운 값이 있고 레디스에는 새로운 값이 없는 경우를 방지하고 캐시 히트를 증가시키며 데이터 베이스의 부하를 줄일 수 있습니다.

<br>

### 쓰기 전략과 캐시의 일관성

- 레디스의 캐시는 단순히 저장되어 있는 값을 읽어오는 역할만 수행합니다. 이때 원본 데이터와 동일한 값을 유지하도록 하는게 필수적인데, 만약 원본 데이터에는 수정을 했지만 캐시에는 변경된 값을 반영하지 않는다면 데이터 간 불일치가 발생합니다. 이를 캐시 불일치라 합니다.

#### Write Through 패턴

- Write Through 패턴은 데이터베이스에 업데이트할 때마다 매번 레디스 캐시에도 함께 데이터를 업데이트하는 방식입니다.
- 캐시는 항상 최신 데이터를 가지고 있을 수 있다는 장점이 있지만 데이터는 매번 2개의 저장소에 저장해야하기 때문에 시간이 추가적으로 소요될 수 있고, 다시 사용되지 않을 데이터일 수도 있는데 무조건 캐시에도 저장되기 때문에 리소스 낭비가 발생할 수 있지만 이때 만료시간을 설정하는 것을 추천합니다.

![스크린샷 2024-03-22 오후 11 56 16](https://github.com/kdg0209/realizers/assets/80187200/94c52a64-113f-4fd5-a896-07ac0b1e292a)

<br>

#### Cache Invalidation 패턴

- Cache Invalidation은 데이터 베이스에 값을 업데이트할 때마다 캐시에서는 데이터를 삭제하는 전략입니다.
- Write Through 패턴은 2개의 저장소에 데이터를 저장해야 하기 때문에 시간이 추가적으로 소요되고, 다시 사용되지 않을 데이터도 저장한다는 단점을 보완하지만 캐시 미스가 발생할 경우를 생각하면 좋은 방법은 아니라 생각합니다.

![스크린샷 2024-03-23 오전 12 00 22](https://github.com/kdg0209/realizers/assets/80187200/afb37171-1438-4d17-ab3e-7e6b49be18d2)

<br>

#### Write Behind(Write Back) 패턴

- 쓰기가 빈번히 발생하는 서비스라면 해당 전략을 고려할 수 있습니다.
- 데이터 베이스에 대량의 쓰기 작업이 발생하면 이는 많은 디스크 I/O를 발생시키고, 성능을 저하시키는 원인이 됩니다. 따라서 데이터를 먼저 레디스에 업데이트 하고 캐시 히트를 높인 다음에 특정 시간 간격에 따라 비동기적으로 데이터 베이스에 업데이트 하는 전략입니다.
- 배치성으로 데이터 베이스에 데이터를 업데이트 하므로 레디스에 문제가 발생하면 데이터 유실이 발생할 수 있습니다. 그러나 클러스터 구조를 적용함으로써 가용성을 높이고, Look Aside과 결합함으로써 처리량을 높일 수 있습니다.

![스크린샷 2024-03-23 오전 12 07 17](https://github.com/kdg0209/realizers/assets/80187200/d1e40544-d473-4e09-8416-08c500446412)

<br>

## 캐시에서의 데이터 흐름

- 인 메모리 데이터베이스는 기본적으로 적은 양의 데이터를 보관할 수 밖에 없습니다. 따라서 캐시는 메모리가 가득차지 않게 일정 양의 데이터를 유지해야 합니다.

### 만료 시간

- 레디스에서 만료시간 TTL(Time to Live)은 데이터가 얼마나 오랫동안 저장할것인지 나타내는 시간 설정입니다.
- TTL과 EXPIRE 명령어는 초 단위로 동작하며, PTTL, PEXPIRE는 명령어는 밀리세컨드 단위로 동작합니다.
- 주의점으로는 기존 키에 새로운 값을 저장할 때 기존 TTL이 사라집니다.

```
> set a 150
> expire a 200 // 만료시간 설정
> ttl a        // 만료시간 조회
(integer) 197

> incr a // a 값 1 증가
> ttl a  // 만료시간 조회
(integer) 149

> rename a apple // 키 이름 변경
> ttl apple      // 만료시간 조회
(integer) 96

> set apple 500 // 값 변경
> ttl apple     // 만료시간 조회
(integer) -1    // 만료 시간 사라짐
```

#### 💡 레디스에서 키가 만료됐다고해도 바로 메모리에서 삭제되는것은 아니다?

- passive 방식
  - 클라이언트가 키에 접근하고자할 때 키가 만료되었다면 메모리에서 수동삭제합니다.
  - 사용자가 키에 접근할 때 삭제되므로 만약 접근하지 않는다면 키 삭제 안됨
- active 방식
  - TTL 값이 있는 키 중 20개를 랜덤으로 추출한 뒤 만료된 키를 메모리에서 삭제합니다.

<br>

## 다양한 키 삭제 전략 

#### 메모리 관리와 maxmemory-policy 설정

- 모든 키에 만료시간을 설정하더라도 메모리의 용량을 초과하는 양의 데이터가 저장되면 레디스는 내부 정책으로 어떤 키를 삭제할지 결정합니다.

### Noeviction 전략

- 기본값입니다.
- 레디스에 데이터가 가득차더라도 임의의 데이터를 삭제하지 않고 더 이상 레디스에 데이터를 저장할 수 없다는 에러 반환

### LRU eviction 전략

- 레디스에 데이터가 가득 찼을 때 가장 최근에 사용하지 않은 데이터부터 삭제하는 정책입니다.
- 최근에 접근하지 않은 데이터는 나중이 되더라도 접근할 가능성이 낮다라는 가정을 전제로합니다.
  - volatile-lfu
    - 만료 시간이 설정되어 있는 키에 한해서 LRU 방식으로 키를 삭제합니다.
    - 만약 키에 만료시간을 설정하지 않고 저장한다면 Noeviction과 동일한 문제가 발생할 수 있습니다.
  - allkeys-lfu
    - 잘 모르겠는 경우 해당 방법을 사용하는걸 추천
    - 만료 시간이 설정되어 있지 않더라도 데이터 삭제

### LFU eviction 전략

- 해당 기법은 얼마나 많이 참조했는가?를 기준으로 생각하면 이해하기 쉽습니다.
- 레디스에 데이터가 가득 찼을 때 자주 사용되지 않은 데이터부터 삭제하는 정책입니다.
- 키가 오랫동안 사용되지 않았더라도 과거에 자주 접근했던 키라면 나중에 다시 사용될 수 있다는 가정하에 우선순위가 높아집니다.

### volatile-ttl 전략

- 해당 방식은 만료시간이 가장 적게 남은 키를 삭제합니다.

<br>

## 캐시 스탬피드 현상

- 대규모 트래픽 환경에서 TTL을 너무 짧게 가지면 해당 문제가 발생할 수 있습니다.
- Look-Aside 패턴에서 레디스에 키가 없을 경우 데이터베이스를 조회하게 되는데 캐시 스탬피드 상황에서 데이터 베이스 부화가 발생할 수 있습니다.

#### 🤔 어떻게 해결할까?

- Jitter 방법을 사용합니다.
- PER 알고리즘
- 분산락을 통해 해결할 수도 있습니다.
- 여러 방법이 있으며 개인적으로는 분산락을 통해 하는 방법이 괜찮지 않을까? 생각을 합니다.

<br>

## 세션 스토어로서의 레디스

#### 세션이란?

- 세션이란 서비스를 사용하는 클라이언트의 상태 정보를 의미합니다.

#### 세션 스토어로서의 레디스

- 유저의 상태는 레디스에 저장되므로 어떤 서버에 연결되더라도 동일한 상태를 조회할 수 있으며 트래픽을 효율적으로 서버로 분산할 수 있고, 데이터 일관성도 유지할 수 있습니다.

<img width="1032" alt="스크린샷 2024-03-23 오후 1 26 47" src="https://github.com/kdg0209/realizers/assets/80187200/9451c0e8-0f18-4194-906e-48b60ec755ce">

<br>

#### 캐시와 세션의 차이

- 캐시
  - 캐시 내부의 데이터가 유실되더라도 데이터 베이스에서 검색할 수 있습니다.
  - 캐시에 저장된 데이터는 많은 클라이언트들이 공유하여 접근하고 사용될 수 있습니다.

- 세션
  - 세션 스토어로서 사용된다면 사용자간에 공유되지 않고 특정 클라이언트만 접근할 수 있습니다.

