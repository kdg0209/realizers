# 레디스를 캐시로 사용하기

- 캐시란 무엇인지?
- 어떤 상황에서 캐시를 사용해야 하는지?
- 레디스를 캐시로 활용할 때 잘 사용하는 방법과 무엇을 주의해야 하는지?
- 캐시와 세션 차이가 무엇인지?

## 레디스와 캐시

### 캐시란?

- 캐시란 메인 메모리에 저장되어 있는 원본 데이터보다 더 빠르고 효율적으로 접근할 수 있는 임시 데이터 저장소입니다.
- 캐시는 정말 자주사용되고, 평소 우리가 개발할 때 알게 모르게 사용되곤합니다. 자바로 애플리케이션을 개발하다보면 간혹 race-condition 문제가 발생하곤 하는데 이 또한 캐시와 상관이 있습니다.
  cpu는 명령어 수행시 메인 메모리로 바로 접근하는게 아니라 중간에 있는 캐시 메모리를 한번 거치게 됩니다. 이때 가시성 문제가 발생할 수 있는데 이또한 캐시입니다. 그래서 자바에서는 volatile 키워드를 사용하여 가시성 문제를 해결하곤합니다.
  - https://github.com/kdg0209/realizers/blob/main/inflearn-java-concurrency-programming/java%20volatile.md
 
#### 🤔 어떤 상황에서 캐시가 좋을까?

- 원본 데이터 저장소에서 원하는 데이터에 접근할 때 오래 걸리는 경우
- 사용자가 자주 검색하고, 잘 변하지 않는 데이터일 경우

<br>

### 캐시로서의 레디스

- 레디스는 모든 데이터를 메모리에 저장하는 인 메모리 데이터 저장소이기 때문에 데이터를 검색하고 반환하는 것이 빠릅니다.
- RDBMS의 경우는 필요한 데이터를 검색하기 위해서 디스크 I/O가 발생하는데 레디스의 경우 메모리에 모든 데이터가 존재하기 때문에 데이터에 접근하는 시간이 빠릅니다.
- 레디스는 평균 읽기 및 쓰기 작업 속도가 1ms 미만이며, 초당 수백만 건의 작업이 가능합니다.
- 레디스는 고가용성 기능을 자체적으로 가지고 있기 때문에 안정적인 운영을 할 수 있습니다. 레디스의 센티널 또는 클러스터 기능을 사용하면 마스터 노드에 장애가 발생시 자동으로 fail-over를 발생시키기 때문에 운영자의 개입 없이 캐시는 정상적으로 유지될 수 있어서 가용성이 높아집니다.

<br>

### 캐싱 전략

- 캐싱 전략은 캐싱되는 데이터의 유형과 데이터에 접근 패턴에 따라 다르기 때문에 서비스에 맞는 적절한 캐싱 전략을 선택해야 합니다.

#### 읽기 전략(Look Aside) 패턴

- 캐시 히트인 경우
  1. 사용자는 서버에 요청을 보냅니다.
  2. 서버는 우선적으로 레디스에서 데이터를 조회하게됩니다.
  3. 레디스에 원하는 데이터가 있는 경우 캐시 히트가 되며 서버에 반환됩니다.
  4. 서버는 레디스로부터 받은 데이터를 사용자에게 반환합니다.

![스크린샷 2024-03-22 오후 11 31 16](https://github.com/kdg0209/realizers/assets/80187200/840e396e-dad2-4b6b-9f03-cf09e92d0dad)

<br>

- 캐시 미스인 경우
  1. 사용자는 서버에 요청을 보냅니다.
  2. 서버는 우선적으로 레디스에서 데이터를 조회하게됩니다.
  3. 레디스에서 원하는 데이터를 찾지 못해 캐시 미스가 됩니다.
  4. 서버는 다음으로 데이터 베이스에서 원하는 데이터를 찾게됩니다.
  5. 서버는 데이터 베이스에서 검색한 값을 사용자에게 반환합니다.

![스크린샷 2024-03-22 오후 11 33 56](https://github.com/kdg0209/realizers/assets/80187200/6a171277-78c4-4485-9ec8-e1282a236dc2)

<br>

#### 🧨 읽기 전략이 가지고 있는 문제점

- 레디스에 문제가 발생하여 접근을 하지 못하는 경우 수 많은 트래픽이 원본 데이터 베이스로 몰리게 됩니다. 이는 데이터 베이스 읽기 전용 트랜잭션이 급격하게 증가하게되고, 리소스를 많이 차지하는 등의 이슈가 발생하게 됩니다.
- 기존에 사용 중인 서비스에 레디스를 처음 투입하거나, 데이터 베이스만 새로운 값을 저장하고 레디스에는 새로운 값을 저장하지 않은 경우에 사용자가 급격히 몰리는 경우 레디스에 값이 없기 때문에 캐시 미스가 발생하여 데이터 베이스에 커넥션이 많이 몰리게 됩니다. 따라서 예상치 못한 이슈가 발생할 수 있습니다.

#### 💡 캐시 워밍(Cache Warming)

- 캐시 워밍이란 사전에 데이터 베이스에 있는 값을 레디스로 데이터를 밀어 넣는 작업입니다.
- 해당 작업을 수행함으로써 서비스에 레디스를 처음 투입하거나, 데이터 베이스에만 새로운 값이 있고 레디스에는 새로운 값이 없는 경우를 방지하고 캐시 히트를 증가시키며 데이터 베이스의 부하를 줄일 수 있습니다.

<br>

### 쓰기 전략과 캐시의 일관성

- 레디스의 캐시는 단순히 저장되어 있는 값을 읽어오는 역할만 수행합니다. 이때 원본 데이터와 동일한 값을 유지하도록 하는게 필수적인데, 만약 원본 데이터에는 수정을 했지만 캐시에는 변경된 값을 반영하지 않는다면 데이터 간 불일치가 발생합니다. 이를 캐시 불일치라 합니다.

#### Write Through 패턴

- Write Through 패턴은 데이터베이스에 업데이트할 때마다 매번 레디스 캐시에도 함께 데이터를 업데이트하는 방식입니다.
- 캐시는 항상 최신 데이터를 가지고 있을 수 있다는 장점이 있지만 데이터는 매번 2개의 저장소에 저장해야하기 때문에 시간이 추가적으로 소요될 수 있고, 다시 사용되지 않을 데이터일 수도 있는데 무조건 캐시에도 저장되기 때문에 리소스 낭비가 발생할 수 있지만 이때 만료시간을 설정하는 것을 추천합니다.

![스크린샷 2024-03-22 오후 11 56 16](https://github.com/kdg0209/realizers/assets/80187200/94c52a64-113f-4fd5-a896-07ac0b1e292a)

<br>

#### Cache Invalidation 패턴

- Cache Invalidation은 데이터 베이스에 값을 업데이트할 때마다 캐시에서는 데이터를 삭제하는 전략입니다.
- Write Through 패턴은 2개의 저장소에 데이터를 저장해야 하기 때문에 시간이 추가적으로 소요되고, 다시 사용되지 않을 데이터도 저장한다는 단점을 보완하지만 캐시 미스가 발생할 경우를 생각하면 좋은 방법은 아니라 생각합니다.

![스크린샷 2024-03-23 오전 12 00 22](https://github.com/kdg0209/realizers/assets/80187200/afb37171-1438-4d17-ab3e-7e6b49be18d2)

<br>

#### Write Behind(Write Back) 패턴

- 쓰기가 빈번히 발생하는 서비스라면 해당 전략을 고려할 수 있습니다.
- 데이터 베이스에 대량의 쓰기 작업이 발생하면 이는 많은 디스크 I/O를 발생시키고, 성능을 저하시키는 원인이 됩니다. 따라서 데이터를 먼저 레디스에 업데이트 하고 캐시 히트를 높인 다음에 특정 시간 간격에 따라 비동기적으로 데이터 베이스에 업데이트 하는 전략입니다.
- 배치성으로 데이터 베이스에 데이터를 업데이트 하므로 레디스에 문제가 발생하면 데이터 유실이 발생할 수 있습니다. 그러나 클러스터 구조를 적용함으로써 가용성을 높이고, Look Aside과 결합함으로써 처리량을 높일 수 있습니다.

![스크린샷 2024-03-23 오전 12 07 17](https://github.com/kdg0209/realizers/assets/80187200/d1e40544-d473-4e09-8416-08c500446412)

<br>

## 레디스에서의 데이터 흐름

<br>

## 세션 스토어로서의 레디스









