# 자바 메모리 영역과 메모리 오버플로

- 2장에서는 JVM이 관리하는 다양한 메모리 영역과 각 메모리 영역의 역할과 관리 대상, 발생할 수 있는 문제를 설명합니다.

## 런타임 데이터 영역

- JVM은 자바 애플리케이션을 실행시키는 동안 몇개의 데이터 영역으로 나뉘는데, 이 영역들은 각각의 목적과 생성/삭제 시점이 있습니다. 어떤 영역은 가상 머신 프로세스의 시작과 동시에 만들어지며, 어떤 영역은 사용자 스레드의 시작/종료에 맞춰 생성/삭제됩니다.

<img width="1038" alt="스크린샷 2024-05-04 오후 2 18 25" src="https://github.com/kdg0209/realizers/assets/80187200/97153083-8d33-40b1-bdc6-03c675504d83">

<br>

### 프로그램 카운터 레지스터

- 프로그램 카운터 레지스터는 작은 메모리 영역으로, 각 스레드들의 다음 명령어 주소가 저장된 영역입니다.
- 자바 가상 머신에서의 멀티 스레딩은 여러 스레드가 교대로 CPU 자원을 사용하는데, CPU 자원은 하나의 스레드만 사용할 수 있으며, CPU 자원을 사용하기 위해서 context switch가 발생합니다. 이때 현재 실행중이던 스레드의 정보는 어딘가에 저장되어 있다가 다시 재가동될 때 복원해야 하는데 이를 프로그램 카운터라고 하며,
프로그램 카운터에는 스레드가 자바 메서드를 실행중일 때 실행중인 바이트코드 명령어의 주소가 담겨있습니다.
- 스레드가 네이티브 메서드를 실행 중일 때 프로그램 카운터의 값은 Undefined입니다.
- 프로그램 카운터는 스레드별로 데이터 영역을 가집니다.

### 자바 가상 머신 스택

- 자바 가상 머신 스택은 스레드의 call stack으로 가장 많이 알려져 있으며, 각 메서드가 호출될 때마다 자바 가상 머신은 스레드에 스택 프레임을 맏들어 지역 변수 테이블, 피연산자 스택, 동적 링크, 매개변수 정보, 메서드 반환값 등을 저장합니다.
- 지역 변수 테이블은 JVM이 컴파일 시점에 알 수 있는 다양한 기본 데이터 타입, 참조 타입, 반환 주소 타입을 저장합니다.
- 지역 변수 테이블에서 데이터 타입들을 저장하는 공간을 지역 변수 슬롯이라 하는데, 일반적으로 슬롯당 크기는 32비트 입니다. double 타입처럼 길이가 64비트인 데이터는 두개의 슬롯을 차지하게 됩니다. (가상 머신에 따라 슬롯의 크기가 32비트이거나 64비트 또는 그 이상일 수 있음)
- 지역 변수 테이블을 구성하는데 필요한 데이터 공간은 컴파일 과정에서 할당됩니다.
- 지역 변수 테이블을 구성하는 슬롯의 개수는 컴파일 과정에서 할당받고 런타임 시점에서 개수는 절대 변하지 않습니다.
- StackOverflowError, OOM문제가 발생할 수 있습니다.

### 네이티브 메서드 스택

- 자바 가상 머신 스택은 스레드가 메서드를 실행할 때 사용하고, 네이티브 메서드 스택은 네이티브 메서드 스택을 실행할 때 사용됩니다.
- GC애 의해 처리되지 않는 메모리이며, Java에서 Java Native Interface라는 기술로 Low Level Language에 의존하는 형식으로 되어 있습니다.
- 실제로는 구현체가 JDK에 숨겨져있으며 내부적으로 C 코드로 되어있어 melloc calloc free로 메모리가 관리되고 있습니다.
- 힙 덤프나 jstat 같은 일반적인 메모리 분석이 안되어 jcmd와 같은 추가적인 도구를 사용하여 분석할 수 있습니다.

### 힙 영역

- 힙 영역은 모든 스레드가 공유하며 가상 머신이 구동될 때 만들어집니다.
- 힙 영역의 목적은 객체 인스턴스를 저장하는 것이고, 거의 모든 객체 인스턴스가 이 영역에 할당됩니다.

### 메서드(메타스페이스) 영역

- 메서드 영역도 모든 스레드가 공유하며, 메서드 영역은 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수, JIT 컴파일러가 컴파일한 코드 캐시 등을 저장하는데 이용됩니다.
- 메서드 영역도 논리적으로 힙의 한 부분으로 기술하지만, 힙 영역과 구분하기 위해 non-heap 이라고도 부릅니다.
- 자바 8부터는 메타스페이스 영역으로 변경되었으며, 클래스의 구조 및 타입 정보, 필드 정보, 메서드 정보, 어노테이션의 정보등을 저장합니다.
- 힙 크기 설정과 별도로 관리 되므로 메타스페이스 영역에 별도로 설정을 할 수 있습니다.

### 런타임 상수 풀

- 자바 8이전에는 Perm 영역에 저장되었고 8버전부터는 메타스페이스 영역에 저장됩니다.
- 상수 풀에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보를 더해 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조가 저장됩니다.

### 다이렉트 메모리

- 다이렉트 메모리는 JDK 1.4에서 NIO가 도입되면서 채널과 버퍼 기반 I/O 메서드가 소개되었습니다. NIO는 힙이 아닌 메모리를 직접 할당할 수 있는 네이티브 함수 라이브러리를 이용하며, 이 메모리에 저장되어 있는 DirectByteBuffer 객체를 통해 작업을 수행할 수 있습니다. 
따라서 자바 힙과 네이티브 힙 사이에서 데이터를 복사해 주고받지 않아도 되므로 일부 시나리오에서 성능을 크게 향샹시켰습니다.
- 물리 메모리를 직접 할당받기 때문에 자바 힙 크기의 제약과는 무관하지만 개발자가 -Xmx 등의 매개변수 설정을 통해 가상 머신의 메모리 크기만 고려할 뿐 다이렉트 메모리는 간과하는 경우가 있는데 모든 메모리의 합이 물리 메모리의 한계를 넘어가면 OOM이 발생하므로 다이렉트 메모리도 신경을 써야합니다.

<br>

## 핫스팟 가상 머신에서의 객체 들여다보기

- 이 주제에서는 핫스팟이 관리하는 자바 힙에서의 객체 생성, 메모리 레이아웃, 접근 방법들을 살펴볼 것입니다.

### 객체 생성

- 자바에서는 new 키워드를 사용하여 객체를 생성할 수 있는데 어떤 과정을 거쳐 객체가 생성될까?
- JVM이 new 명령어에 해당하는 바이트코드를 만나면, 이 명령의 매개변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인합니다. 그런 다음 이 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화되었는지 확인합니다.
- 자바 힙의 메모리 공간은 규칙적이지 않기 때문에 사용중인 메모리와 사용 가능한 메모리가 뒤썩여 있고, 가상 머신은 가용 메모리 블록들을 목록화하여 관리하고 있으며, 객체를 담기 충분한 공간을 찾아 할당한 후 목록을 최신화합니다. 이 방식을 여유 목록(free list)이라 합니다.
- free list를 쓸지는 힙이 규칙적이냐 아니냐에 따라 달라지며, 규직적이냐는 사용하는 GC가 컴팩트(모으기)를 할 수 있느냐에 따라 달라집니다.
- 자바는 멀티 스레딩이기 때문에 여러 스레드가 동시에 new 키워드를 사용하여 객체를 생성할 수 있습니다. 이때 가용 메모리 블록에 동기화를 해야하는데 CAS 연산을 하는 방식과 스레드마다 다른 메모리 공간을 할당받아 놓고 사용하는 방법(TLAB)이 있습니다.

### 메모리 레이아웃

- 핫스팟 가상 머신은 아래 그림처럼 객체를 세 부분으로 나눠 힙에 저장합니다.

<img width="1042" alt="스크린샷 2024-05-04 오후 4 18 47" src="https://github.com/kdg0209/realizers/assets/80187200/cfd3d051-9f60-4f1a-afc1-bb54f9c825c9">

<br>

#### 객체 헤더 [마크 워드]

- 마크 워드는 객체 자체의 런타임 데이터를 담고 있습니다.
- 해시 코드, GC Age, 락 상태 플래그, 스레드가 점유하고 있는 락, 편향된 스레드 아이디, 편햔된 시각의 타임스탬프등입니다.(편향된 스레드 아이디, 시각의 타임스탬프는 JDK 18이후에는 해당하지 않습니다.)
- 객체 헤더에는 객체 자체가 정의한 데이터와 관련 없는 정보까지 담아야해서 한정된 메모리를 최대한 효율적으로 사용해야 합니다. 그렇기 때문에 마크 워드의 데이터 구조는 동적으로 달라집니다.

#### 객체 헤더 [클래스 워드]

- 클래스 워드에는 객체의 클래스 관련 메타데이터를 가리키는 클래스 포인터가 저장됩니다.
- JVM은 이 클래스 포인터를 활용하여 특정 객체가 어떤 클래스의 인스턴스인지 런타임에 알 수 있습니다.
- 모든 가상 머신이 클래스 포인터를 객체 헤더에 저장하는 것은 아닙니다.

#### 객체 헤더 [배열 길이]

- 배열의 경우 배열의 길이도 객체 헤더에 저장합니다.
- JVM은 객체 헤더의 메타데이터로부터 자바 객체의 크기를 얻는데, 객체 헤더에 저장되는 객체 타입은 배열에 담긴 원소 타입입니다. 따라서 배열 길이까지 알아야 배열 객체가 차지하는 메모리 크기를 계산할 수 있습니다.

#### 인스턴스 데이터

- 인스턴스 데이터는 객체가 실제로 담고 있는 정보입니다.
- 코드에서 정의한 다양한 타입의 필드, 부모 클래스에 대한 정보가 이 부분에 기록됩니다.

#### 정렬 패딩

- 정렬 패딩은 존재하지 않을 수도 있으며, 특별한 의미 없이 자리를 확보하는 역할만 수행합니다.
- 핫스팟 가상 머신의 자동 메모리 관리 시스템에서 객체의 시작 주소는 반드시 8바이트 정수배여야 하며, 객체 헤더는 정확히 8바이트의 정수배가 되도록 잘 설계되어 있으며, 만약 인스턴스 데이터가 이 8바이트 정수배를 충족하지 못한다면 패딩으로 채우게 됩니다.

### 객체 접근 방법

- 자바 가상 머신 명세에는 참조 타입을 단지 '객체를 가리키는 참조' 라고만 정의했을 뿐 구체적인 방법은 규정하지 않았습니다. 그렇기 때문에 접근하는 방식 역시 가상 머신에서 구현하기 나름인데 주로 핸들이나 다이렉트 포인터를 사용해서 구현합니다.

#### 핸들 방식

- 핸들 방식에서는 자바 힙에 핸들 저장용 풀이 별도로 존재할 것입니다.
- 핸들 방식에서 장점은 참조에 안정적인 핸들의 주소가 저장됩니다. GC 과정에서 객체가 이동하는 일은 빈번한데 핸들을 이용하면 객체의 위치가 바뀌는 과정에서 참조 자체는 손댈 필요가 없습니다. 대신 핸들내의 인스턴스 데이터 포인터만 변경하면 됩니다.

<img width="1047" alt="스크린샷 2024-05-04 오후 4 53 09" src="https://github.com/kdg0209/realizers/assets/80187200/c632f0ea-3188-4a41-b74e-9a5395d35537">

<br>

#### 다이렉트 포인터

- 핫 스팟 가상 머신은 다이렉트 포인터를 사용하고 있습니다.
- 다이렉트 포인터 방식은 힙 영역에 위치한 객체에서 인스턴스 데이터 뿐만 아니라 타입 데이터에 접근하는 길도 제공해야 합니다.
- 스택의 참조에는 개체의 실제 주소가 바로 저장되어 있습니다.
- 다이렉트 포인터 방식을 사용하면 속도에 장점이 있습니다. 핸등 방식은 핸들 풀이라는 곳을 거쳐 객체 인스턴스 데이터에 접근하지만 다이렉트 포인터는 바로 힙 영역에 있는 객체 인스턴스 데이터에 접근합니다.

<img width="1050" alt="스크린샷 2024-05-04 오후 4 59 03" src="https://github.com/kdg0209/realizers/assets/80187200/98f89f5d-7265-44c2-a408-cf00b036ae8d">

<br>

## 실전 예제

### 가상 머신 스택과 네이티브 메서드 스택 오버플로

- 핫스팟 가상 머신은 가상 머신 스택과 네이티브 메서드 스택을 구분하지 않습니다. 따라서 네이티브 메서드 스택을 설정하는 -Xoss 매개변수를 설정하도 먹히지 않습니다. 스택 크기는 오로지 -Xss 설정을 통해서만 할 수 있습니다.

#### 테스트 1: -Xss 매개변수를 사용하여 스택을 줄여 StackOverflowError가 발생하는지 확인합니다.

- The Java thread stack size specified is too small. Specify at least 144k
- Xss설정을 하다보면 위와 같은 메시지가 출력될 수 있는데 최소 스택 크기는 144K보다 커야한다고 하는데 이는 운영체제마다 다릅니다.

```java
VM 옵션 설정
-Xss150k

public class Main {

    private int stackLength = 1;

    public void stackLeak() {
        this.stackLength++;
        stackLeak();
    }

    public static void main(String[] args) {
        Main main = new Main();

        try {
            main.stackLeak();
        } catch (Throwable e) {
            System.out.println("스택 길이: " + main.stackLength); // 스택 길이: 7223
            throw e;
        }
    }
}
```

<br>

#### 테스트 2: 지역변수를 많이 선언하여 메서드의 스택 프레임의 지역변수 테이블을 증가시켜 StackOverflowError가 발생하는지 확인합니다.












